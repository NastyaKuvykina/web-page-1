(function defineMustache(global, factory) {
  if (typeof exports === 'object' && exports) {
    factory(exports);
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory);
  } else {
    global.Mustache = {};
    factory(Mustache);
  }
})(this, function mustacheFactory(mustache) {
  var objectToString = Object.prototype.toString;
  var isArray =
    Array.isArray ||
    function isArrayPolyfill(object) {
      return objectToString.call(object) === '[object Array]';
    };
  function isFunction(object) {
    return typeof object === 'function';
  }
  function escapeRegExp(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }
  function hasProperty(obj, propName) {
    return obj != null && typeof obj === 'object' && propName in obj;
  }
  var regExpTest = RegExp.prototype.test;
  function testRegExp(re, string) {
    return regExpTest.call(re, string);
  }
  var nonSpaceRe = /\S/;
  function isWhitespace(string) {
    return !testRegExp(nonSpaceRe, string);
  }
  var entityMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '/': '&#x2F;' };
  function escapeHtml(string) {
    return String(string).replace(/[&<>"'\/]/g, function fromEntityMap(s) {
      return entityMap[s];
    });
  }
  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;
  function parseTemplate(template, tags) {
    if (!template) return [];
    var sections = [];
    var tokens = [];
    var spaces = [];
    var hasTag = false;
    var nonSpace = false;
    function stripSpace() {
      if (hasTag && !nonSpace) {
        while (spaces.length) delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }
      hasTag = false;
      nonSpace = false;
    }
    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags(tagsToCompile) {
      if (typeof tagsToCompile === 'string') tagsToCompile = tagsToCompile.split(spaceRe, 2);
      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error('Invalid tags: ' + tagsToCompile);
      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }
    compileTags(tags || mustache.tags);
    var scanner = new Scanner(template);
    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;
      value = scanner.scanUntil(openingTagRe);
      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);
          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }
          tokens.push(['text', chr, start, start + 1]);
          start += 1;
          if (chr === '\n') stripSpace();
        }
      }
      if (!scanner.scan(openingTagRe)) break;
      hasTag = true;
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }
      if (!scanner.scan(closingTagRe)) throw new Error('Unclosed tag at ' + scanner.pos);
      token = [type, value, start, scanner.pos];
      tokens.push(token);
      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        openSection = sections.pop();
        if (!openSection) throw new Error('Unopened section "' + value + '" at ' + start);
        if (openSection[1] !== value) throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        compileTags(value);
      }
    }
    openSection = sections.pop();
    if (openSection) throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
    return nestTokens(squashTokens(tokens));
  }
  function squashTokens(tokens) {
    var squashedTokens = [];
    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];
      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }
    return squashedTokens;
  }
  function nestTokens(tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];
    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];
      switch (token[0]) {
        case '#':
        case '^':
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case '/':
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }
    return nestedTokens;
  }
  function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }
  Scanner.prototype.eos = function eos() {
    return this.tail === '';
  };
  Scanner.prototype.scan = function scan(re) {
    var match = this.tail.match(re);
    if (!match || match.index !== 0) return '';
    var string = match[0];
    this.tail = this.tail.substring(string.length);
    this.pos += string.length;
    return string;
  };
  Scanner.prototype.scanUntil = function scanUntil(re) {
    var index = this.tail.search(re),
      match;
    switch (index) {
      case -1:
        match = this.tail;
        this.tail = '';
        break;
      case 0:
        match = '';
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }
    this.pos += match.length;
    return match;
  };
  function Context(view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }
  Context.prototype.push = function push(view) {
    return new Context(view, this);
  };
  Context.prototype.lookup = function lookup(name) {
    var cache = this.cache;
    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this,
        names,
        index,
        lookupHit = false;
      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;
          while (value != null && index < names.length) {
            if (index === names.length - 1) lookupHit = hasProperty(value, names[index]);
            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }
        if (lookupHit) break;
        context = context.parent;
      }
      cache[name] = value;
    }
    if (isFunction(value)) value = value.call(this.view);
    return value;
  };
  function Writer() {
    this.cache = {};
  }
  Writer.prototype.clearCache = function clearCache() {
    this.cache = {};
  };
  Writer.prototype.parse = function parse(template, tags) {
    var cache = this.cache;
    var tokens = cache[template];
    if (tokens == null) tokens = cache[template] = parseTemplate(template, tags);
    return tokens;
  };
  Writer.prototype.render = function render(template, view, partials) {
    var tokens = this.parse(template);
    var context = view instanceof Context ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };
  Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {
    var buffer = '';
    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];
      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);
      if (value !== undefined) buffer += value;
    }
    return buffer;
  };
  Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);
    function subRender(template) {
      return self.render(template, context, partials);
    }
    if (!value) return;
    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
      if (value != null) buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };
  Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };
  Writer.prototype.renderPartial = function renderPartial(token, context, partials) {
    if (!partials) return;
    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null) return this.renderTokens(this.parse(value), context, partials, value);
  };
  Writer.prototype.unescapedValue = function unescapedValue(token, context) {
    var value = context.lookup(token[1]);
    if (value != null) return value;
  };
  Writer.prototype.escapedValue = function escapedValue(token, context) {
    var value = context.lookup(token[1]);
    if (value != null) return mustache.escape(value);
  };
  Writer.prototype.rawValue = function rawValue(token) {
    return token[1];
  };
  mustache.name = 'mustache.js';
  mustache.version = '2.1.2';
  mustache.tags = ['{{', '}}'];
  var defaultWriter = new Writer();
  mustache.clearCache = function clearCache() {
    return defaultWriter.clearCache();
  };
  mustache.parse = function parse(template, tags) {
    return defaultWriter.parse(template, tags);
  };
  mustache.render = function render(template, view, partials) {
    return defaultWriter.render(template, view, partials);
  };
  mustache.to_html = function to_html(template, view, partials, send) {
    var result = mustache.render(template, view, partials);
    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };
  mustache.escape = escapeHtml;
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;
});

/*! jQuery v1.10.1 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery-1.10.1.min.map
*/
(function(e, t) {
  var n,
    r,
    i = typeof t,
    o = e.location,
    a = e.document,
    s = a.documentElement,
    l = e.jQuery,
    u = e.$,
    c = {},
    p = [],
    f = '1.10.1',
    d = p.concat,
    h = p.push,
    g = p.slice,
    m = p.indexOf,
    y = c.toString,
    v = c.hasOwnProperty,
    b = f.trim,
    x = function(e, t) {
      return new x.fn.init(e, t, r);
    },
    w = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    T = /\S+/g,
    C = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    N = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    k = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    E = /^[\],:{}\s]*$/,
    S = /(?:^|:|,)(?:\s*\[)+/g,
    A = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
    j = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,
    D = /^-ms-/,
    L = /-([\da-z])/gi,
    H = function(e, t) {
      return t.toUpperCase();
    },
    q = function(e) {
      (a.addEventListener || 'load' === e.type || 'complete' === a.readyState) && (_(), x.ready());
    },
    _ = function() {
      a.addEventListener
        ? (a.removeEventListener('DOMContentLoaded', q, !1), e.removeEventListener('load', q, !1))
        : (a.detachEvent('onreadystatechange', q), e.detachEvent('onload', q));
    };
  (x.fn = x.prototype = {
    jquery: f,
    constructor: x,
    init: function(e, n, r) {
      var i, o;
      if (!e) return this;
      if ('string' == typeof e) {
        if (
          ((i = '<' === e.charAt(0) && '>' === e.charAt(e.length - 1) && e.length >= 3 ? [null, e, null] : N.exec(e)),
          !i || (!i[1] && n))
        )
          return !n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e);
        if (i[1]) {
          if (
            ((n = n instanceof x ? n[0] : n),
            x.merge(this, x.parseHTML(i[1], n && n.nodeType ? n.ownerDocument || n : a, !0)),
            k.test(i[1]) && x.isPlainObject(n))
          )
            for (i in n) x.isFunction(this[i]) ? this[i](n[i]) : this.attr(i, n[i]);
          return this;
        }
        if (((o = a.getElementById(i[2])), o && o.parentNode)) {
          if (o.id !== i[2]) return r.find(e);
          (this.length = 1), (this[0] = o);
        }
        return (this.context = a), (this.selector = e), this;
      }
      return e.nodeType
        ? ((this.context = this[0] = e), (this.length = 1), this)
        : x.isFunction(e)
        ? r.ready(e)
        : (e.selector !== t && ((this.selector = e.selector), (this.context = e.context)), x.makeArray(e, this));
    },
    selector: '',
    length: 0,
    toArray: function() {
      return g.call(this);
    },
    get: function(e) {
      return null == e ? this.toArray() : 0 > e ? this[this.length + e] : this[e];
    },
    pushStack: function(e) {
      var t = x.merge(this.constructor(), e);
      return (t.prevObject = this), (t.context = this.context), t;
    },
    each: function(e, t) {
      return x.each(this, e, t);
    },
    ready: function(e) {
      return x.ready.promise().done(e), this;
    },
    slice: function() {
      return this.pushStack(g.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(e) {
      var t = this.length,
        n = +e + (0 > e ? t : 0);
      return this.pushStack(n >= 0 && t > n ? [this[n]] : []);
    },
    map: function(e) {
      return this.pushStack(
        x.map(this, function(t, n) {
          return e.call(t, n, t);
        })
      );
    },
    end: function() {
      return this.prevObject || this.constructor(null);
    },
    push: h,
    sort: [].sort,
    splice: [].splice,
  }),
    (x.fn.init.prototype = x.fn),
    (x.extend = x.fn.extend = function() {
      var e,
        n,
        r,
        i,
        o,
        a,
        s = arguments[0] || {},
        l = 1,
        u = arguments.length,
        c = !1;
      for (
        'boolean' == typeof s && ((c = s), (s = arguments[1] || {}), (l = 2)),
          'object' == typeof s || x.isFunction(s) || (s = {}),
          u === l && ((s = this), --l);
        u > l;
        l++
      )
        if (null != (o = arguments[l]))
          for (i in o)
            (e = s[i]),
              (r = o[i]),
              s !== r &&
                (c && r && (x.isPlainObject(r) || (n = x.isArray(r)))
                  ? (n ? ((n = !1), (a = e && x.isArray(e) ? e : [])) : (a = e && x.isPlainObject(e) ? e : {}),
                    (s[i] = x.extend(c, a, r)))
                  : r !== t && (s[i] = r));
      return s;
    }),
    x.extend({
      expando: 'jQuery' + (f + Math.random()).replace(/\D/g, ''),
      noConflict: function(t) {
        return e.$ === x && (e.$ = u), t && e.jQuery === x && (e.jQuery = l), x;
      },
      isReady: !1,
      readyWait: 1,
      holdReady: function(e) {
        e ? x.readyWait++ : x.ready(!0);
      },
      ready: function(e) {
        if (e === !0 ? !--x.readyWait : !x.isReady) {
          if (!a.body) return setTimeout(x.ready);
          (x.isReady = !0),
            (e !== !0 && --x.readyWait > 0) ||
              (n.resolveWith(a, [x]),
              x.fn.trigger &&
                x(a)
                  .trigger('ready')
                  .off('ready'));
        }
      },
      isFunction: function(e) {
        return 'function' === x.type(e);
      },
      isArray:
        Array.isArray ||
        function(e) {
          return 'array' === x.type(e);
        },
      isWindow: function(e) {
        return null != e && e == e.window;
      },
      isNumeric: function(e) {
        return !isNaN(parseFloat(e)) && isFinite(e);
      },
      type: function(e) {
        return null == e
          ? e + ''
          : 'object' == typeof e || 'function' == typeof e
          ? c[y.call(e)] || 'object'
          : typeof e;
      },
      isPlainObject: function(e) {
        var n;
        if (!e || 'object' !== x.type(e) || e.nodeType || x.isWindow(e)) return !1;
        try {
          if (e.constructor && !v.call(e, 'constructor') && !v.call(e.constructor.prototype, 'isPrototypeOf'))
            return !1;
        } catch (r) {
          return !1;
        }
        if (x.support.ownLast) for (n in e) return v.call(e, n);
        for (n in e);
        return n === t || v.call(e, n);
      },
      isEmptyObject: function(e) {
        var t;
        for (t in e) return !1;
        return !0;
      },
      error: function(e) {
        throw Error(e);
      },
      parseHTML: function(e, t, n) {
        if (!e || 'string' != typeof e) return null;
        'boolean' == typeof t && ((n = t), (t = !1)), (t = t || a);
        var r = k.exec(e),
          i = !n && [];
        return r
          ? [t.createElement(r[1])]
          : ((r = x.buildFragment([e], t, i)), i && x(i).remove(), x.merge([], r.childNodes));
      },
      parseJSON: function(n) {
        return e.JSON && e.JSON.parse
          ? e.JSON.parse(n)
          : null === n
          ? n
          : 'string' == typeof n &&
            ((n = x.trim(n)),
            n &&
              E.test(
                n
                  .replace(A, '@')
                  .replace(j, ']')
                  .replace(S, '')
              ))
          ? Function('return ' + n)()
          : (x.error('Invalid JSON: ' + n), t);
      },
      parseXML: function(n) {
        var r, i;
        if (!n || 'string' != typeof n) return null;
        try {
          e.DOMParser
            ? ((i = new DOMParser()), (r = i.parseFromString(n, 'text/xml')))
            : ((r = new ActiveXObject('Microsoft.XMLDOM')), (r.async = 'false'), r.loadXML(n));
        } catch (o) {
          r = t;
        }
        return (
          (r && r.documentElement && !r.getElementsByTagName('parsererror').length) || x.error('Invalid XML: ' + n), r
        );
      },
      noop: function() {},
      globalEval: function(t) {
        t &&
          x.trim(t) &&
          (
            e.execScript ||
            function(t) {
              e.eval.call(e, t);
            }
          )(t);
      },
      camelCase: function(e) {
        return e.replace(D, 'ms-').replace(L, H);
      },
      nodeName: function(e, t) {
        return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
      },
      each: function(e, t, n) {
        var r,
          i = 0,
          o = e.length,
          a = M(e);
        if (n) {
          if (a) {
            for (; o > i; i++) if (((r = t.apply(e[i], n)), r === !1)) break;
          } else for (i in e) if (((r = t.apply(e[i], n)), r === !1)) break;
        } else if (a) {
          for (; o > i; i++) if (((r = t.call(e[i], i, e[i])), r === !1)) break;
        } else for (i in e) if (((r = t.call(e[i], i, e[i])), r === !1)) break;
        return e;
      },
      trim:
        b && !b.call('\ufeff\u00a0')
          ? function(e) {
              return null == e ? '' : b.call(e);
            }
          : function(e) {
              return null == e ? '' : (e + '').replace(C, '');
            },
      makeArray: function(e, t) {
        var n = t || [];
        return null != e && (M(Object(e)) ? x.merge(n, 'string' == typeof e ? [e] : e) : h.call(n, e)), n;
      },
      inArray: function(e, t, n) {
        var r;
        if (t) {
          if (m) return m.call(t, e, n);
          for (r = t.length, n = n ? (0 > n ? Math.max(0, r + n) : n) : 0; r > n; n++)
            if (n in t && t[n] === e) return n;
        }
        return -1;
      },
      merge: function(e, n) {
        var r = n.length,
          i = e.length,
          o = 0;
        if ('number' == typeof r) for (; r > o; o++) e[i++] = n[o];
        else while (n[o] !== t) e[i++] = n[o++];
        return (e.length = i), e;
      },
      grep: function(e, t, n) {
        var r,
          i = [],
          o = 0,
          a = e.length;
        for (n = !!n; a > o; o++) (r = !!t(e[o], o)), n !== r && i.push(e[o]);
        return i;
      },
      map: function(e, t, n) {
        var r,
          i = 0,
          o = e.length,
          a = M(e),
          s = [];
        if (a) for (; o > i; i++) (r = t(e[i], i, n)), null != r && (s[s.length] = r);
        else for (i in e) (r = t(e[i], i, n)), null != r && (s[s.length] = r);
        return d.apply([], s);
      },
      guid: 1,
      proxy: function(e, n) {
        var r, i, o;
        return (
          'string' == typeof n && ((o = e[n]), (n = e), (e = o)),
          x.isFunction(e)
            ? ((r = g.call(arguments, 2)),
              (i = function() {
                return e.apply(n || this, r.concat(g.call(arguments)));
              }),
              (i.guid = e.guid = e.guid || x.guid++),
              i)
            : t
        );
      },
      access: function(e, n, r, i, o, a, s) {
        var l = 0,
          u = e.length,
          c = null == r;
        if ('object' === x.type(r)) {
          o = !0;
          for (l in r) x.access(e, n, l, r[l], !0, a, s);
        } else if (
          i !== t &&
          ((o = !0),
          x.isFunction(i) || (s = !0),
          c &&
            (s
              ? (n.call(e, i), (n = null))
              : ((c = n),
                (n = function(e, t, n) {
                  return c.call(x(e), n);
                }))),
          n)
        )
          for (; u > l; l++) n(e[l], r, s ? i : i.call(e[l], l, n(e[l], r)));
        return o ? e : c ? n.call(e) : u ? n(e[0], r) : a;
      },
      now: function() {
        return new Date().getTime();
      },
      swap: function(e, t, n, r) {
        var i,
          o,
          a = {};
        for (o in t) (a[o] = e.style[o]), (e.style[o] = t[o]);
        i = n.apply(e, r || []);
        for (o in t) e.style[o] = a[o];
        return i;
      },
    }),
    (x.ready.promise = function(t) {
      if (!n)
        if (((n = x.Deferred()), 'complete' === a.readyState)) setTimeout(x.ready);
        else if (a.addEventListener) a.addEventListener('DOMContentLoaded', q, !1), e.addEventListener('load', q, !1);
        else {
          a.attachEvent('onreadystatechange', q), e.attachEvent('onload', q);
          var r = !1;
          try {
            r = null == e.frameElement && a.documentElement;
          } catch (i) {}
          r &&
            r.doScroll &&
            (function o() {
              if (!x.isReady) {
                try {
                  r.doScroll('left');
                } catch (e) {
                  return setTimeout(o, 50);
                }
                _(), x.ready();
              }
            })();
        }
      return n.promise(t);
    }),
    x.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function(e, t) {
      c['[object ' + t + ']'] = t.toLowerCase();
    });
  function M(e) {
    var t = e.length,
      n = x.type(e);
    return x.isWindow(e)
      ? !1
      : 1 === e.nodeType && t
      ? !0
      : 'array' === n || ('function' !== n && (0 === t || ('number' == typeof t && t > 0 && t - 1 in e)));
  }
  (r = x(a)),
    (function(e, t) {
      var n,
        r,
        i,
        o,
        a,
        s,
        l,
        u,
        c,
        p,
        f,
        d,
        h,
        g,
        m,
        y,
        v,
        b = 'sizzle' + -new Date(),
        w = e.document,
        T = 0,
        C = 0,
        N = lt(),
        k = lt(),
        E = lt(),
        S = !1,
        A = function() {
          return 0;
        },
        j = typeof t,
        D = 1 << 31,
        L = {}.hasOwnProperty,
        H = [],
        q = H.pop,
        _ = H.push,
        M = H.push,
        O = H.slice,
        F =
          H.indexOf ||
          function(e) {
            var t = 0,
              n = this.length;
            for (; n > t; t++) if (this[t] === e) return t;
            return -1;
          },
        B =
          'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',
        P = '[\\x20\\t\\r\\n\\f]',
        R = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+',
        W = R.replace('w', 'w#'),
        $ =
          '\\[' +
          P +
          '*(' +
          R +
          ')' +
          P +
          '*(?:([*^$|!~]?=)' +
          P +
          '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' +
          W +
          ')|)|)' +
          P +
          '*\\]',
        I =
          ':(' +
          R +
          ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' +
          $.replace(3, 8) +
          ')*)|.*)\\)|)',
        z = RegExp('^' + P + '+|((?:^|[^\\\\])(?:\\\\.)*)' + P + '+$', 'g'),
        X = RegExp('^' + P + '*,' + P + '*'),
        U = RegExp('^' + P + '*([>+~]|' + P + ')' + P + '*'),
        V = RegExp(P + '*[+~]'),
        Y = RegExp('=' + P + '*([^\\]\'"]*)' + P + '*\\]', 'g'),
        J = RegExp(I),
        G = RegExp('^' + W + '$'),
        Q = {
          ID: RegExp('^#(' + R + ')'),
          CLASS: RegExp('^\\.(' + R + ')'),
          TAG: RegExp('^(' + R.replace('w', 'w*') + ')'),
          ATTR: RegExp('^' + $),
          PSEUDO: RegExp('^' + I),
          CHILD: RegExp(
            '^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' +
              P +
              '*(even|odd|(([+-]|)(\\d*)n|)' +
              P +
              '*(?:([+-]|)' +
              P +
              '*(\\d+)|))' +
              P +
              '*\\)|)',
            'i'
          ),
          bool: RegExp('^(?:' + B + ')$', 'i'),
          needsContext: RegExp(
            '^' +
              P +
              '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' +
              P +
              '*((?:-\\d)?\\d*)' +
              P +
              '*\\)|)(?=[^-]|$)',
            'i'
          ),
        },
        K = /^[^{]+\{\s*\[native \w/,
        Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        et = /^(?:input|select|textarea|button)$/i,
        tt = /^h\d$/i,
        nt = /'|\\/g,
        rt = RegExp('\\\\([\\da-f]{1,6}' + P + '?|(' + P + ')|.)', 'ig'),
        it = function(e, t, n) {
          var r = '0x' + t - 65536;
          return r !== r || n
            ? t
            : 0 > r
            ? String.fromCharCode(r + 65536)
            : String.fromCharCode(55296 | (r >> 10), 56320 | (1023 & r));
        };
      try {
        M.apply((H = O.call(w.childNodes)), w.childNodes), H[w.childNodes.length].nodeType;
      } catch (ot) {
        M = {
          apply: H.length
            ? function(e, t) {
                _.apply(e, O.call(t));
              }
            : function(e, t) {
                var n = e.length,
                  r = 0;
                while ((e[n++] = t[r++]));
                e.length = n - 1;
              },
        };
      }
      function at(e, t, n, i) {
        var o, a, s, l, u, c, d, m, y, x;
        if (((t ? t.ownerDocument || t : w) !== f && p(t), (t = t || f), (n = n || []), !e || 'string' != typeof e))
          return n;
        if (1 !== (l = t.nodeType) && 9 !== l) return [];
        if (h && !i) {
          if ((o = Z.exec(e)))
            if ((s = o[1])) {
              if (9 === l) {
                if (((a = t.getElementById(s)), !a || !a.parentNode)) return n;
                if (a.id === s) return n.push(a), n;
              } else if (t.ownerDocument && (a = t.ownerDocument.getElementById(s)) && v(t, a) && a.id === s)
                return n.push(a), n;
            } else {
              if (o[2]) return M.apply(n, t.getElementsByTagName(e)), n;
              if ((s = o[3]) && r.getElementsByClassName && t.getElementsByClassName)
                return M.apply(n, t.getElementsByClassName(s)), n;
            }
          if (r.qsa && (!g || !g.test(e))) {
            if (((m = d = b), (y = t), (x = 9 === l && e), 1 === l && 'object' !== t.nodeName.toLowerCase())) {
              (c = bt(e)),
                (d = t.getAttribute('id')) ? (m = d.replace(nt, '\\$&')) : t.setAttribute('id', m),
                (m = "[id='" + m + "'] "),
                (u = c.length);
              while (u--) c[u] = m + xt(c[u]);
              (y = (V.test(e) && t.parentNode) || t), (x = c.join(','));
            }
            if (x)
              try {
                return M.apply(n, y.querySelectorAll(x)), n;
              } catch (T) {
              } finally {
                d || t.removeAttribute('id');
              }
          }
        }
        return At(e.replace(z, '$1'), t, n, i);
      }
      function st(e) {
        return K.test(e + '');
      }
      function lt() {
        var e = [];
        function t(n, r) {
          return e.push((n += ' ')) > o.cacheLength && delete t[e.shift()], (t[n] = r);
        }
        return t;
      }
      function ut(e) {
        return (e[b] = !0), e;
      }
      function ct(e) {
        var t = f.createElement('div');
        try {
          return !!e(t);
        } catch (n) {
          return !1;
        } finally {
          t.parentNode && t.parentNode.removeChild(t), (t = null);
        }
      }
      function pt(e, t, n) {
        e = e.split('|');
        var r,
          i = e.length,
          a = n ? null : t;
        while (i--) ((r = o.attrHandle[e[i]]) && r !== t) || (o.attrHandle[e[i]] = a);
      }
      function ft(e, t) {
        var n = e.getAttributeNode(t);
        return n && n.specified ? n.value : e[t] === !0 ? t.toLowerCase() : null;
      }
      function dt(e, t) {
        return e.getAttribute(t, 'type' === t.toLowerCase() ? 1 : 2);
      }
      function ht(e) {
        return 'input' === e.nodeName.toLowerCase() ? e.defaultValue : t;
      }
      function gt(e, t) {
        var n = t && e,
          r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || D) - (~e.sourceIndex || D);
        if (r) return r;
        if (n) while ((n = n.nextSibling)) if (n === t) return -1;
        return e ? 1 : -1;
      }
      function mt(e) {
        return function(t) {
          var n = t.nodeName.toLowerCase();
          return 'input' === n && t.type === e;
        };
      }
      function yt(e) {
        return function(t) {
          var n = t.nodeName.toLowerCase();
          return ('input' === n || 'button' === n) && t.type === e;
        };
      }
      function vt(e) {
        return ut(function(t) {
          return (
            (t = +t),
            ut(function(n, r) {
              var i,
                o = e([], n.length, t),
                a = o.length;
              while (a--) n[(i = o[a])] && (n[i] = !(r[i] = n[i]));
            })
          );
        });
      }
      (s = at.isXML = function(e) {
        var t = e && (e.ownerDocument || e).documentElement;
        return t ? 'HTML' !== t.nodeName : !1;
      }),
        (r = at.support = {}),
        (p = at.setDocument = function(e) {
          var n = e ? e.ownerDocument || e : w,
            i = n.parentWindow;
          return n !== f && 9 === n.nodeType && n.documentElement
            ? ((f = n),
              (d = n.documentElement),
              (h = !s(n)),
              i &&
                i.frameElement &&
                i.attachEvent('onbeforeunload', function() {
                  p();
                }),
              (r.attributes = ct(function(e) {
                return (
                  (e.innerHTML = "<a href='#'></a>"),
                  pt('type|href|height|width', dt, '#' === e.firstChild.getAttribute('href')),
                  pt(B, ft, null == e.getAttribute('disabled')),
                  (e.className = 'i'),
                  !e.getAttribute('className')
                );
              })),
              (r.input = ct(function(e) {
                return (
                  (e.innerHTML = '<input>'),
                  e.firstChild.setAttribute('value', ''),
                  '' === e.firstChild.getAttribute('value')
                );
              })),
              pt('value', ht, r.attributes && r.input),
              (r.getElementsByTagName = ct(function(e) {
                return e.appendChild(n.createComment('')), !e.getElementsByTagName('*').length;
              })),
              (r.getElementsByClassName = ct(function(e) {
                return (
                  (e.innerHTML = "<div class='a'></div><div class='a i'></div>"),
                  (e.firstChild.className = 'i'),
                  2 === e.getElementsByClassName('i').length
                );
              })),
              (r.getById = ct(function(e) {
                return (d.appendChild(e).id = b), !n.getElementsByName || !n.getElementsByName(b).length;
              })),
              r.getById
                ? ((o.find.ID = function(e, t) {
                    if (typeof t.getElementById !== j && h) {
                      var n = t.getElementById(e);
                      return n && n.parentNode ? [n] : [];
                    }
                  }),
                  (o.filter.ID = function(e) {
                    var t = e.replace(rt, it);
                    return function(e) {
                      return e.getAttribute('id') === t;
                    };
                  }))
                : (delete o.find.ID,
                  (o.filter.ID = function(e) {
                    var t = e.replace(rt, it);
                    return function(e) {
                      var n = typeof e.getAttributeNode !== j && e.getAttributeNode('id');
                      return n && n.value === t;
                    };
                  })),
              (o.find.TAG = r.getElementsByTagName
                ? function(e, n) {
                    return typeof n.getElementsByTagName !== j ? n.getElementsByTagName(e) : t;
                  }
                : function(e, t) {
                    var n,
                      r = [],
                      i = 0,
                      o = t.getElementsByTagName(e);
                    if ('*' === e) {
                      while ((n = o[i++])) 1 === n.nodeType && r.push(n);
                      return r;
                    }
                    return o;
                  }),
              (o.find.CLASS =
                r.getElementsByClassName &&
                function(e, n) {
                  return typeof n.getElementsByClassName !== j && h ? n.getElementsByClassName(e) : t;
                }),
              (m = []),
              (g = []),
              (r.qsa = st(n.querySelectorAll)) &&
                (ct(function(e) {
                  (e.innerHTML = "<select><option selected=''></option></select>"),
                    e.querySelectorAll('[selected]').length || g.push('\\[' + P + '*(?:value|' + B + ')'),
                    e.querySelectorAll(':checked').length || g.push(':checked');
                }),
                ct(function(e) {
                  var t = n.createElement('input');
                  t.setAttribute('type', 'hidden'),
                    e.appendChild(t).setAttribute('t', ''),
                    e.querySelectorAll("[t^='']").length && g.push('[*^$]=' + P + '*(?:\'\'|"")'),
                    e.querySelectorAll(':enabled').length || g.push(':enabled', ':disabled'),
                    e.querySelectorAll('*,:x'),
                    g.push(',.*:');
                })),
              (r.matchesSelector = st(
                (y = d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.msMatchesSelector)
              )) &&
                ct(function(e) {
                  (r.disconnectedMatch = y.call(e, 'div')), y.call(e, "[s!='']:x"), m.push('!=', I);
                }),
              (g = g.length && RegExp(g.join('|'))),
              (m = m.length && RegExp(m.join('|'))),
              (v =
                st(d.contains) || d.compareDocumentPosition
                  ? function(e, t) {
                      var n = 9 === e.nodeType ? e.documentElement : e,
                        r = t && t.parentNode;
                      return (
                        e === r ||
                        !(
                          !r ||
                          1 !== r.nodeType ||
                          !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))
                        )
                      );
                    }
                  : function(e, t) {
                      if (t) while ((t = t.parentNode)) if (t === e) return !0;
                      return !1;
                    }),
              (r.sortDetached = ct(function(e) {
                return 1 & e.compareDocumentPosition(n.createElement('div'));
              })),
              (A = d.compareDocumentPosition
                ? function(e, t) {
                    if (e === t) return (S = !0), 0;
                    var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition(t);
                    return i
                      ? 1 & i || (!r.sortDetached && t.compareDocumentPosition(e) === i)
                        ? e === n || v(w, e)
                          ? -1
                          : t === n || v(w, t)
                          ? 1
                          : c
                          ? F.call(c, e) - F.call(c, t)
                          : 0
                        : 4 & i
                        ? -1
                        : 1
                      : e.compareDocumentPosition
                      ? -1
                      : 1;
                  }
                : function(e, t) {
                    var r,
                      i = 0,
                      o = e.parentNode,
                      a = t.parentNode,
                      s = [e],
                      l = [t];
                    if (e === t) return (S = !0), 0;
                    if (!o || !a)
                      return e === n ? -1 : t === n ? 1 : o ? -1 : a ? 1 : c ? F.call(c, e) - F.call(c, t) : 0;
                    if (o === a) return gt(e, t);
                    r = e;
                    while ((r = r.parentNode)) s.unshift(r);
                    r = t;
                    while ((r = r.parentNode)) l.unshift(r);
                    while (s[i] === l[i]) i++;
                    return i ? gt(s[i], l[i]) : s[i] === w ? -1 : l[i] === w ? 1 : 0;
                  }),
              n)
            : f;
        }),
        (at.matches = function(e, t) {
          return at(e, null, null, t);
        }),
        (at.matchesSelector = function(e, t) {
          if (
            ((e.ownerDocument || e) !== f && p(e),
            (t = t.replace(Y, "='$1']")),
            !(!r.matchesSelector || !h || (m && m.test(t)) || (g && g.test(t))))
          )
            try {
              var n = y.call(e, t);
              if (n || r.disconnectedMatch || (e.document && 11 !== e.document.nodeType)) return n;
            } catch (i) {}
          return at(t, f, null, [e]).length > 0;
        }),
        (at.contains = function(e, t) {
          return (e.ownerDocument || e) !== f && p(e), v(e, t);
        }),
        (at.attr = function(e, n) {
          (e.ownerDocument || e) !== f && p(e);
          var i = o.attrHandle[n.toLowerCase()],
            a = i && L.call(o.attrHandle, n.toLowerCase()) ? i(e, n, !h) : t;
          return a === t
            ? r.attributes || !h
              ? e.getAttribute(n)
              : (a = e.getAttributeNode(n)) && a.specified
              ? a.value
              : null
            : a;
        }),
        (at.error = function(e) {
          throw Error('Syntax error, unrecognized expression: ' + e);
        }),
        (at.uniqueSort = function(e) {
          var t,
            n = [],
            i = 0,
            o = 0;
          if (((S = !r.detectDuplicates), (c = !r.sortStable && e.slice(0)), e.sort(A), S)) {
            while ((t = e[o++])) t === e[o] && (i = n.push(o));
            while (i--) e.splice(n[i], 1);
          }
          return e;
        }),
        (a = at.getText = function(e) {
          var t,
            n = '',
            r = 0,
            i = e.nodeType;
          if (i) {
            if (1 === i || 9 === i || 11 === i) {
              if ('string' == typeof e.textContent) return e.textContent;
              for (e = e.firstChild; e; e = e.nextSibling) n += a(e);
            } else if (3 === i || 4 === i) return e.nodeValue;
          } else for (; (t = e[r]); r++) n += a(t);
          return n;
        }),
        (o = at.selectors = {
          cacheLength: 50,
          createPseudo: ut,
          match: Q,
          attrHandle: {},
          find: {},
          relative: {
            '>': { dir: 'parentNode', first: !0 },
            ' ': { dir: 'parentNode' },
            '+': { dir: 'previousSibling', first: !0 },
            '~': { dir: 'previousSibling' },
          },
          preFilter: {
            ATTR: function(e) {
              return (
                (e[1] = e[1].replace(rt, it)),
                (e[3] = (e[4] || e[5] || '').replace(rt, it)),
                '~=' === e[2] && (e[3] = ' ' + e[3] + ' '),
                e.slice(0, 4)
              );
            },
            CHILD: function(e) {
              return (
                (e[1] = e[1].toLowerCase()),
                'nth' === e[1].slice(0, 3)
                  ? (e[3] || at.error(e[0]),
                    (e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ('even' === e[3] || 'odd' === e[3]))),
                    (e[5] = +(e[7] + e[8] || 'odd' === e[3])))
                  : e[3] && at.error(e[0]),
                e
              );
            },
            PSEUDO: function(e) {
              var n,
                r = !e[5] && e[2];
              return Q.CHILD.test(e[0])
                ? null
                : (e[3] && e[4] !== t
                    ? (e[2] = e[4])
                    : r &&
                      J.test(r) &&
                      (n = bt(r, !0)) &&
                      (n = r.indexOf(')', r.length - n) - r.length) &&
                      ((e[0] = e[0].slice(0, n)), (e[2] = r.slice(0, n))),
                  e.slice(0, 3));
            },
          },
          filter: {
            TAG: function(e) {
              var t = e.replace(rt, it).toLowerCase();
              return '*' === e
                ? function() {
                    return !0;
                  }
                : function(e) {
                    return e.nodeName && e.nodeName.toLowerCase() === t;
                  };
            },
            CLASS: function(e) {
              var t = N[e + ' '];
              return (
                t ||
                ((t = RegExp('(^|' + P + ')' + e + '(' + P + '|$)')) &&
                  N(e, function(e) {
                    return t.test(
                      ('string' == typeof e.className && e.className) ||
                        (typeof e.getAttribute !== j && e.getAttribute('class')) ||
                        ''
                    );
                  }))
              );
            },
            ATTR: function(e, t, n) {
              return function(r) {
                var i = at.attr(r, e);
                return null == i
                  ? '!=' === t
                  : t
                  ? ((i += ''),
                    '=' === t
                      ? i === n
                      : '!=' === t
                      ? i !== n
                      : '^=' === t
                      ? n && 0 === i.indexOf(n)
                      : '*=' === t
                      ? n && i.indexOf(n) > -1
                      : '$=' === t
                      ? n && i.slice(-n.length) === n
                      : '~=' === t
                      ? (' ' + i + ' ').indexOf(n) > -1
                      : '|=' === t
                      ? i === n || i.slice(0, n.length + 1) === n + '-'
                      : !1)
                  : !0;
              };
            },
            CHILD: function(e, t, n, r, i) {
              var o = 'nth' !== e.slice(0, 3),
                a = 'last' !== e.slice(-4),
                s = 'of-type' === t;
              return 1 === r && 0 === i
                ? function(e) {
                    return !!e.parentNode;
                  }
                : function(t, n, l) {
                    var u,
                      c,
                      p,
                      f,
                      d,
                      h,
                      g = o !== a ? 'nextSibling' : 'previousSibling',
                      m = t.parentNode,
                      y = s && t.nodeName.toLowerCase(),
                      v = !l && !s;
                    if (m) {
                      if (o) {
                        while (g) {
                          p = t;
                          while ((p = p[g])) if (s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) return !1;
                          h = g = 'only' === e && !h && 'nextSibling';
                        }
                        return !0;
                      }
                      if (((h = [a ? m.firstChild : m.lastChild]), a && v)) {
                        (c = m[b] || (m[b] = {})),
                          (u = c[e] || []),
                          (d = u[0] === T && u[1]),
                          (f = u[0] === T && u[2]),
                          (p = d && m.childNodes[d]);
                        while ((p = (++d && p && p[g]) || (f = d = 0) || h.pop()))
                          if (1 === p.nodeType && ++f && p === t) {
                            c[e] = [T, d, f];
                            break;
                          }
                      } else if (v && (u = (t[b] || (t[b] = {}))[e]) && u[0] === T) f = u[1];
                      else
                        while ((p = (++d && p && p[g]) || (f = d = 0) || h.pop()))
                          if (
                            (s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) &&
                            ++f &&
                            (v && ((p[b] || (p[b] = {}))[e] = [T, f]), p === t)
                          )
                            break;
                      return (f -= i), f === r || (0 === f % r && f / r >= 0);
                    }
                  };
            },
            PSEUDO: function(e, t) {
              var n,
                r = o.pseudos[e] || o.setFilters[e.toLowerCase()] || at.error('unsupported pseudo: ' + e);
              return r[b]
                ? r(t)
                : r.length > 1
                ? ((n = [e, e, '', t]),
                  o.setFilters.hasOwnProperty(e.toLowerCase())
                    ? ut(function(e, n) {
                        var i,
                          o = r(e, t),
                          a = o.length;
                        while (a--) (i = F.call(e, o[a])), (e[i] = !(n[i] = o[a]));
                      })
                    : function(e) {
                        return r(e, 0, n);
                      })
                : r;
            },
          },
          pseudos: {
            not: ut(function(e) {
              var t = [],
                n = [],
                r = l(e.replace(z, '$1'));
              return r[b]
                ? ut(function(e, t, n, i) {
                    var o,
                      a = r(e, null, i, []),
                      s = e.length;
                    while (s--) (o = a[s]) && (e[s] = !(t[s] = o));
                  })
                : function(e, i, o) {
                    return (t[0] = e), r(t, null, o, n), !n.pop();
                  };
            }),
            has: ut(function(e) {
              return function(t) {
                return at(e, t).length > 0;
              };
            }),
            contains: ut(function(e) {
              return function(t) {
                return (t.textContent || t.innerText || a(t)).indexOf(e) > -1;
              };
            }),
            lang: ut(function(e) {
              return (
                G.test(e || '') || at.error('unsupported lang: ' + e),
                (e = e.replace(rt, it).toLowerCase()),
                function(t) {
                  var n;
                  do
                    if ((n = h ? t.lang : t.getAttribute('xml:lang') || t.getAttribute('lang')))
                      return (n = n.toLowerCase()), n === e || 0 === n.indexOf(e + '-');
                  while ((t = t.parentNode) && 1 === t.nodeType);
                  return !1;
                }
              );
            }),
            target: function(t) {
              var n = e.location && e.location.hash;
              return n && n.slice(1) === t.id;
            },
            root: function(e) {
              return e === d;
            },
            focus: function(e) {
              return e === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
            },
            enabled: function(e) {
              return e.disabled === !1;
            },
            disabled: function(e) {
              return e.disabled === !0;
            },
            checked: function(e) {
              var t = e.nodeName.toLowerCase();
              return ('input' === t && !!e.checked) || ('option' === t && !!e.selected);
            },
            selected: function(e) {
              return e.parentNode && e.parentNode.selectedIndex, e.selected === !0;
            },
            empty: function(e) {
              for (e = e.firstChild; e; e = e.nextSibling)
                if (e.nodeName > '@' || 3 === e.nodeType || 4 === e.nodeType) return !1;
              return !0;
            },
            parent: function(e) {
              return !o.pseudos.empty(e);
            },
            header: function(e) {
              return tt.test(e.nodeName);
            },
            input: function(e) {
              return et.test(e.nodeName);
            },
            button: function(e) {
              var t = e.nodeName.toLowerCase();
              return ('input' === t && 'button' === e.type) || 'button' === t;
            },
            text: function(e) {
              var t;
              return (
                'input' === e.nodeName.toLowerCase() &&
                'text' === e.type &&
                (null == (t = e.getAttribute('type')) || t.toLowerCase() === e.type)
              );
            },
            first: vt(function() {
              return [0];
            }),
            last: vt(function(e, t) {
              return [t - 1];
            }),
            eq: vt(function(e, t, n) {
              return [0 > n ? n + t : n];
            }),
            even: vt(function(e, t) {
              var n = 0;
              for (; t > n; n += 2) e.push(n);
              return e;
            }),
            odd: vt(function(e, t) {
              var n = 1;
              for (; t > n; n += 2) e.push(n);
              return e;
            }),
            lt: vt(function(e, t, n) {
              var r = 0 > n ? n + t : n;
              for (; --r >= 0; ) e.push(r);
              return e;
            }),
            gt: vt(function(e, t, n) {
              var r = 0 > n ? n + t : n;
              for (; t > ++r; ) e.push(r);
              return e;
            }),
          },
        });
      for (n in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) o.pseudos[n] = mt(n);
      for (n in { submit: !0, reset: !0 }) o.pseudos[n] = yt(n);
      function bt(e, t) {
        var n,
          r,
          i,
          a,
          s,
          l,
          u,
          c = k[e + ' '];
        if (c) return t ? 0 : c.slice(0);
        (s = e), (l = []), (u = o.preFilter);
        while (s) {
          (!n || (r = X.exec(s))) && (r && (s = s.slice(r[0].length) || s), l.push((i = []))),
            (n = !1),
            (r = U.exec(s)) &&
              ((n = r.shift()), i.push({ value: n, type: r[0].replace(z, ' ') }), (s = s.slice(n.length)));
          for (a in o.filter)
            !(r = Q[a].exec(s)) ||
              (u[a] && !(r = u[a](r))) ||
              ((n = r.shift()), i.push({ value: n, type: a, matches: r }), (s = s.slice(n.length)));
          if (!n) break;
        }
        return t ? s.length : s ? at.error(e) : k(e, l).slice(0);
      }
      function xt(e) {
        var t = 0,
          n = e.length,
          r = '';
        for (; n > t; t++) r += e[t].value;
        return r;
      }
      function wt(e, t, n) {
        var r = t.dir,
          o = n && 'parentNode' === r,
          a = C++;
        return t.first
          ? function(t, n, i) {
              while ((t = t[r])) if (1 === t.nodeType || o) return e(t, n, i);
            }
          : function(t, n, s) {
              var l,
                u,
                c,
                p = T + ' ' + a;
              if (s) {
                while ((t = t[r])) if ((1 === t.nodeType || o) && e(t, n, s)) return !0;
              } else
                while ((t = t[r]))
                  if (1 === t.nodeType || o)
                    if (((c = t[b] || (t[b] = {})), (u = c[r]) && u[0] === p)) {
                      if ((l = u[1]) === !0 || l === i) return l === !0;
                    } else if (((u = c[r] = [p]), (u[1] = e(t, n, s) || i), u[1] === !0)) return !0;
            };
      }
      function Tt(e) {
        return e.length > 1
          ? function(t, n, r) {
              var i = e.length;
              while (i--) if (!e[i](t, n, r)) return !1;
              return !0;
            }
          : e[0];
      }
      function Ct(e, t, n, r, i) {
        var o,
          a = [],
          s = 0,
          l = e.length,
          u = null != t;
        for (; l > s; s++) (o = e[s]) && (!n || n(o, r, i)) && (a.push(o), u && t.push(s));
        return a;
      }
      function Nt(e, t, n, r, i, o) {
        return (
          r && !r[b] && (r = Nt(r)),
          i && !i[b] && (i = Nt(i, o)),
          ut(function(o, a, s, l) {
            var u,
              c,
              p,
              f = [],
              d = [],
              h = a.length,
              g = o || St(t || '*', s.nodeType ? [s] : s, []),
              m = !e || (!o && t) ? g : Ct(g, f, e, s, l),
              y = n ? (i || (o ? e : h || r) ? [] : a) : m;
            if ((n && n(m, y, s, l), r)) {
              (u = Ct(y, d)), r(u, [], s, l), (c = u.length);
              while (c--) (p = u[c]) && (y[d[c]] = !(m[d[c]] = p));
            }
            if (o) {
              if (i || e) {
                if (i) {
                  (u = []), (c = y.length);
                  while (c--) (p = y[c]) && u.push((m[c] = p));
                  i(null, (y = []), u, l);
                }
                c = y.length;
                while (c--) (p = y[c]) && (u = i ? F.call(o, p) : f[c]) > -1 && (o[u] = !(a[u] = p));
              }
            } else (y = Ct(y === a ? y.splice(h, y.length) : y)), i ? i(null, a, y, l) : M.apply(a, y);
          })
        );
      }
      function kt(e) {
        var t,
          n,
          r,
          i = e.length,
          a = o.relative[e[0].type],
          s = a || o.relative[' '],
          l = a ? 1 : 0,
          c = wt(
            function(e) {
              return e === t;
            },
            s,
            !0
          ),
          p = wt(
            function(e) {
              return F.call(t, e) > -1;
            },
            s,
            !0
          ),
          f = [
            function(e, n, r) {
              return (!a && (r || n !== u)) || ((t = n).nodeType ? c(e, n, r) : p(e, n, r));
            },
          ];
        for (; i > l; l++)
          if ((n = o.relative[e[l].type])) f = [wt(Tt(f), n)];
          else {
            if (((n = o.filter[e[l].type].apply(null, e[l].matches)), n[b])) {
              for (r = ++l; i > r; r++) if (o.relative[e[r].type]) break;
              return Nt(
                l > 1 && Tt(f),
                l > 1 && xt(e.slice(0, l - 1).concat({ value: ' ' === e[l - 2].type ? '*' : '' })).replace(z, '$1'),
                n,
                r > l && kt(e.slice(l, r)),
                i > r && kt((e = e.slice(r))),
                i > r && xt(e)
              );
            }
            f.push(n);
          }
        return Tt(f);
      }
      function Et(e, t) {
        var n = 0,
          r = t.length > 0,
          a = e.length > 0,
          s = function(s, l, c, p, d) {
            var h,
              g,
              m,
              y = [],
              v = 0,
              b = '0',
              x = s && [],
              w = null != d,
              C = u,
              N = s || (a && o.find.TAG('*', (d && l.parentNode) || l)),
              k = (T += null == C ? 1 : Math.random() || 0.1);
            for (w && ((u = l !== f && l), (i = n)); null != (h = N[b]); b++) {
              if (a && h) {
                g = 0;
                while ((m = e[g++]))
                  if (m(h, l, c)) {
                    p.push(h);
                    break;
                  }
                w && ((T = k), (i = ++n));
              }
              r && ((h = !m && h) && v--, s && x.push(h));
            }
            if (((v += b), r && b !== v)) {
              g = 0;
              while ((m = t[g++])) m(x, y, l, c);
              if (s) {
                if (v > 0) while (b--) x[b] || y[b] || (y[b] = q.call(p));
                y = Ct(y);
              }
              M.apply(p, y), w && !s && y.length > 0 && v + t.length > 1 && at.uniqueSort(p);
            }
            return w && ((T = k), (u = C)), x;
          };
        return r ? ut(s) : s;
      }
      l = at.compile = function(e, t) {
        var n,
          r = [],
          i = [],
          o = E[e + ' '];
        if (!o) {
          t || (t = bt(e)), (n = t.length);
          while (n--) (o = kt(t[n])), o[b] ? r.push(o) : i.push(o);
          o = E(e, Et(i, r));
        }
        return o;
      };
      function St(e, t, n) {
        var r = 0,
          i = t.length;
        for (; i > r; r++) at(e, t[r], n);
        return n;
      }
      function At(e, t, n, i) {
        var a,
          s,
          u,
          c,
          p,
          f = bt(e);
        if (!i && 1 === f.length) {
          if (
            ((s = f[0] = f[0].slice(0)),
            s.length > 2 && 'ID' === (u = s[0]).type && r.getById && 9 === t.nodeType && h && o.relative[s[1].type])
          ) {
            if (((t = (o.find.ID(u.matches[0].replace(rt, it), t) || [])[0]), !t)) return n;
            e = e.slice(s.shift().value.length);
          }
          a = Q.needsContext.test(e) ? 0 : s.length;
          while (a--) {
            if (((u = s[a]), o.relative[(c = u.type)])) break;
            if ((p = o.find[c]) && (i = p(u.matches[0].replace(rt, it), (V.test(s[0].type) && t.parentNode) || t))) {
              if ((s.splice(a, 1), (e = i.length && xt(s)), !e)) return M.apply(n, i), n;
              break;
            }
          }
        }
        return l(e, f)(i, t, !h, n, V.test(e)), n;
      }
      o.pseudos.nth = o.pseudos.eq;
      function jt() {}
      (jt.prototype = o.filters = o.pseudos),
        (o.setFilters = new jt()),
        (r.sortStable =
          b
            .split('')
            .sort(A)
            .join('') === b),
        p(),
        [0, 0].sort(A),
        (r.detectDuplicates = S),
        (x.find = at),
        (x.expr = at.selectors),
        (x.expr[':'] = x.expr.pseudos),
        (x.unique = at.uniqueSort),
        (x.text = at.getText),
        (x.isXMLDoc = at.isXML),
        (x.contains = at.contains);
    })(e);
  var O = {};
  function F(e) {
    var t = (O[e] = {});
    return (
      x.each(e.match(T) || [], function(e, n) {
        t[n] = !0;
      }),
      t
    );
  }
  (x.Callbacks = function(e) {
    e = 'string' == typeof e ? O[e] || F(e) : x.extend({}, e);
    var n,
      r,
      i,
      o,
      a,
      s,
      l = [],
      u = !e.once && [],
      c = function(t) {
        for (r = e.memory && t, i = !0, a = s || 0, s = 0, o = l.length, n = !0; l && o > a; a++)
          if (l[a].apply(t[0], t[1]) === !1 && e.stopOnFalse) {
            r = !1;
            break;
          }
        (n = !1), l && (u ? u.length && c(u.shift()) : r ? (l = []) : p.disable());
      },
      p = {
        add: function() {
          if (l) {
            var t = l.length;
            (function i(t) {
              x.each(t, function(t, n) {
                var r = x.type(n);
                'function' === r ? (e.unique && p.has(n)) || l.push(n) : n && n.length && 'string' !== r && i(n);
              });
            })(arguments),
              n ? (o = l.length) : r && ((s = t), c(r));
          }
          return this;
        },
        remove: function() {
          return (
            l &&
              x.each(arguments, function(e, t) {
                var r;
                while ((r = x.inArray(t, l, r)) > -1) l.splice(r, 1), n && (o >= r && o--, a >= r && a--);
              }),
            this
          );
        },
        has: function(e) {
          return e ? x.inArray(e, l) > -1 : !(!l || !l.length);
        },
        empty: function() {
          return (l = []), (o = 0), this;
        },
        disable: function() {
          return (l = u = r = t), this;
        },
        disabled: function() {
          return !l;
        },
        lock: function() {
          return (u = t), r || p.disable(), this;
        },
        locked: function() {
          return !u;
        },
        fireWith: function(e, t) {
          return (t = t || []), (t = [e, t.slice ? t.slice() : t]), !l || (i && !u) || (n ? u.push(t) : c(t)), this;
        },
        fire: function() {
          return p.fireWith(this, arguments), this;
        },
        fired: function() {
          return !!i;
        },
      };
    return p;
  }),
    x.extend({
      Deferred: function(e) {
        var t = [
            ['resolve', 'done', x.Callbacks('once memory'), 'resolved'],
            ['reject', 'fail', x.Callbacks('once memory'), 'rejected'],
            ['notify', 'progress', x.Callbacks('memory')],
          ],
          n = 'pending',
          r = {
            state: function() {
              return n;
            },
            always: function() {
              return i.done(arguments).fail(arguments), this;
            },
            then: function() {
              var e = arguments;
              return x
                .Deferred(function(n) {
                  x.each(t, function(t, o) {
                    var a = o[0],
                      s = x.isFunction(e[t]) && e[t];
                    i[o[1]](function() {
                      var e = s && s.apply(this, arguments);
                      e && x.isFunction(e.promise)
                        ? e
                            .promise()
                            .done(n.resolve)
                            .fail(n.reject)
                            .progress(n.notify)
                        : n[a + 'With'](this === r ? n.promise() : this, s ? [e] : arguments);
                    });
                  }),
                    (e = null);
                })
                .promise();
            },
            promise: function(e) {
              return null != e ? x.extend(e, r) : r;
            },
          },
          i = {};
        return (
          (r.pipe = r.then),
          x.each(t, function(e, o) {
            var a = o[2],
              s = o[3];
            (r[o[1]] = a.add),
              s &&
                a.add(
                  function() {
                    n = s;
                  },
                  t[1 ^ e][2].disable,
                  t[2][2].lock
                ),
              (i[o[0]] = function() {
                return i[o[0] + 'With'](this === i ? r : this, arguments), this;
              }),
              (i[o[0] + 'With'] = a.fireWith);
          }),
          r.promise(i),
          e && e.call(i, i),
          i
        );
      },
      when: function(e) {
        var t = 0,
          n = g.call(arguments),
          r = n.length,
          i = 1 !== r || (e && x.isFunction(e.promise)) ? r : 0,
          o = 1 === i ? e : x.Deferred(),
          a = function(e, t, n) {
            return function(r) {
              (t[e] = this),
                (n[e] = arguments.length > 1 ? g.call(arguments) : r),
                n === s ? o.notifyWith(t, n) : --i || o.resolveWith(t, n);
            };
          },
          s,
          l,
          u;
        if (r > 1)
          for (s = Array(r), l = Array(r), u = Array(r); r > t; t++)
            n[t] && x.isFunction(n[t].promise)
              ? n[t]
                  .promise()
                  .done(a(t, u, n))
                  .fail(o.reject)
                  .progress(a(t, l, s))
              : --i;
        return i || o.resolveWith(u, n), o.promise();
      },
    }),
    (x.support = (function(t) {
      var n,
        r,
        o,
        s,
        l,
        u,
        c,
        p,
        f,
        d = a.createElement('div');
      if (
        (d.setAttribute('className', 't'),
        (d.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>"),
        (n = d.getElementsByTagName('*') || []),
        (r = d.getElementsByTagName('a')[0]),
        !r || !r.style || !n.length)
      )
        return t;
      (s = a.createElement('select')),
        (u = s.appendChild(a.createElement('option'))),
        (o = d.getElementsByTagName('input')[0]),
        (r.style.cssText = 'top:1px;float:left;opacity:.5'),
        (t.getSetAttribute = 't' !== d.className),
        (t.leadingWhitespace = 3 === d.firstChild.nodeType),
        (t.tbody = !d.getElementsByTagName('tbody').length),
        (t.htmlSerialize = !!d.getElementsByTagName('link').length),
        (t.style = /top/.test(r.getAttribute('style'))),
        (t.hrefNormalized = '/a' === r.getAttribute('href')),
        (t.opacity = /^0.5/.test(r.style.opacity)),
        (t.cssFloat = !!r.style.cssFloat),
        (t.checkOn = !!o.value),
        (t.optSelected = u.selected),
        (t.enctype = !!a.createElement('form').enctype),
        (t.html5Clone = '<:nav></:nav>' !== a.createElement('nav').cloneNode(!0).outerHTML),
        (t.inlineBlockNeedsLayout = !1),
        (t.shrinkWrapBlocks = !1),
        (t.pixelPosition = !1),
        (t.deleteExpando = !0),
        (t.noCloneEvent = !0),
        (t.reliableMarginRight = !0),
        (t.boxSizingReliable = !0),
        (o.checked = !0),
        (t.noCloneChecked = o.cloneNode(!0).checked),
        (s.disabled = !0),
        (t.optDisabled = !u.disabled);
      try {
        delete d.test;
      } catch (h) {
        t.deleteExpando = !1;
      }
      (o = a.createElement('input')),
        o.setAttribute('value', ''),
        (t.input = '' === o.getAttribute('value')),
        (o.value = 't'),
        o.setAttribute('type', 'radio'),
        (t.radioValue = 't' === o.value),
        o.setAttribute('checked', 't'),
        o.setAttribute('name', 't'),
        (l = a.createDocumentFragment()),
        l.appendChild(o),
        (t.appendChecked = o.checked),
        (t.checkClone = l.cloneNode(!0).cloneNode(!0).lastChild.checked),
        d.attachEvent &&
          (d.attachEvent('onclick', function() {
            t.noCloneEvent = !1;
          }),
          d.cloneNode(!0).click());
      for (f in { submit: !0, change: !0, focusin: !0 })
        d.setAttribute((c = 'on' + f), 't'), (t[f + 'Bubbles'] = c in e || d.attributes[c].expando === !1);
      (d.style.backgroundClip = 'content-box'),
        (d.cloneNode(!0).style.backgroundClip = ''),
        (t.clearCloneStyle = 'content-box' === d.style.backgroundClip);
      for (f in x(t)) break;
      return (
        (t.ownLast = '0' !== f),
        x(function() {
          var n,
            r,
            o,
            s =
              'padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;',
            l = a.getElementsByTagName('body')[0];
          l &&
            ((n = a.createElement('div')),
            (n.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px'),
            l.appendChild(n).appendChild(d),
            (d.innerHTML = '<table><tr><td></td><td>t</td></tr></table>'),
            (o = d.getElementsByTagName('td')),
            (o[0].style.cssText = 'padding:0;margin:0;border:0;display:none'),
            (p = 0 === o[0].offsetHeight),
            (o[0].style.display = ''),
            (o[1].style.display = 'none'),
            (t.reliableHiddenOffsets = p && 0 === o[0].offsetHeight),
            (d.innerHTML = ''),
            (d.style.cssText =
              'box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;'),
            x.swap(l, null != l.style.zoom ? { zoom: 1 } : {}, function() {
              t.boxSizing = 4 === d.offsetWidth;
            }),
            e.getComputedStyle &&
              ((t.pixelPosition = '1%' !== (e.getComputedStyle(d, null) || {}).top),
              (t.boxSizingReliable = '4px' === (e.getComputedStyle(d, null) || { width: '4px' }).width),
              (r = d.appendChild(a.createElement('div'))),
              (r.style.cssText = d.style.cssText = s),
              (r.style.marginRight = r.style.width = '0'),
              (d.style.width = '1px'),
              (t.reliableMarginRight = !parseFloat((e.getComputedStyle(r, null) || {}).marginRight))),
            typeof d.style.zoom !== i &&
              ((d.innerHTML = ''),
              (d.style.cssText = s + 'width:1px;padding:1px;display:inline;zoom:1'),
              (t.inlineBlockNeedsLayout = 3 === d.offsetWidth),
              (d.style.display = 'block'),
              (d.innerHTML = '<div></div>'),
              (d.firstChild.style.width = '5px'),
              (t.shrinkWrapBlocks = 3 !== d.offsetWidth),
              t.inlineBlockNeedsLayout && (l.style.zoom = 1)),
            l.removeChild(n),
            (n = d = o = r = null));
        }),
        (n = s = l = u = r = o = null),
        t
      );
    })({}));
  var B = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
    P = /([A-Z])/g;
  function R(e, n, r, i) {
    if (x.acceptData(e)) {
      var o,
        a,
        s = x.expando,
        l = e.nodeType,
        u = l ? x.cache : e,
        c = l ? e[s] : e[s] && s;
      if ((c && u[c] && (i || u[c].data)) || r !== t || 'string' != typeof n)
        return (
          c || (c = l ? (e[s] = p.pop() || x.guid++) : s),
          u[c] || (u[c] = l ? {} : { toJSON: x.noop }),
          ('object' == typeof n || 'function' == typeof n) &&
            (i ? (u[c] = x.extend(u[c], n)) : (u[c].data = x.extend(u[c].data, n))),
          (a = u[c]),
          i || (a.data || (a.data = {}), (a = a.data)),
          r !== t && (a[x.camelCase(n)] = r),
          'string' == typeof n ? ((o = a[n]), null == o && (o = a[x.camelCase(n)])) : (o = a),
          o
        );
    }
  }
  function W(e, t, n) {
    if (x.acceptData(e)) {
      var r,
        i,
        o = e.nodeType,
        a = o ? x.cache : e,
        s = o ? e[x.expando] : x.expando;
      if (a[s]) {
        if (t && (r = n ? a[s] : a[s].data)) {
          x.isArray(t)
            ? (t = t.concat(x.map(t, x.camelCase)))
            : t in r
            ? (t = [t])
            : ((t = x.camelCase(t)), (t = t in r ? [t] : t.split(' '))),
            (i = t.length);
          while (i--) delete r[t[i]];
          if (n ? !I(r) : !x.isEmptyObject(r)) return;
        }
        (n || (delete a[s].data, I(a[s]))) &&
          (o ? x.cleanData([e], !0) : x.support.deleteExpando || a != a.window ? delete a[s] : (a[s] = null));
      }
    }
  }
  x.extend({
    cache: {},
    noData: { applet: !0, embed: !0, object: 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000' },
    hasData: function(e) {
      return (e = e.nodeType ? x.cache[e[x.expando]] : e[x.expando]), !!e && !I(e);
    },
    data: function(e, t, n) {
      return R(e, t, n);
    },
    removeData: function(e, t) {
      return W(e, t);
    },
    _data: function(e, t, n) {
      return R(e, t, n, !0);
    },
    _removeData: function(e, t) {
      return W(e, t, !0);
    },
    acceptData: function(e) {
      if (e.nodeType && 1 !== e.nodeType && 9 !== e.nodeType) return !1;
      var t = e.nodeName && x.noData[e.nodeName.toLowerCase()];
      return !t || (t !== !0 && e.getAttribute('classid') === t);
    },
  }),
    x.fn.extend({
      data: function(e, n) {
        var r,
          i,
          o = null,
          a = 0,
          s = this[0];
        if (e === t) {
          if (this.length && ((o = x.data(s)), 1 === s.nodeType && !x._data(s, 'parsedAttrs'))) {
            for (r = s.attributes; r.length > a; a++)
              (i = r[a].name), 0 === i.indexOf('data-') && ((i = x.camelCase(i.slice(5))), $(s, i, o[i]));
            x._data(s, 'parsedAttrs', !0);
          }
          return o;
        }
        return 'object' == typeof e
          ? this.each(function() {
              x.data(this, e);
            })
          : arguments.length > 1
          ? this.each(function() {
              x.data(this, e, n);
            })
          : s
          ? $(s, e, x.data(s, e))
          : null;
      },
      removeData: function(e) {
        return this.each(function() {
          x.removeData(this, e);
        });
      },
    });
  function $(e, n, r) {
    if (r === t && 1 === e.nodeType) {
      var i = 'data-' + n.replace(P, '-$1').toLowerCase();
      if (((r = e.getAttribute(i)), 'string' == typeof r)) {
        try {
          r =
            'true' === r
              ? !0
              : 'false' === r
              ? !1
              : 'null' === r
              ? null
              : +r + '' === r
              ? +r
              : B.test(r)
              ? x.parseJSON(r)
              : r;
        } catch (o) {}
        x.data(e, n, r);
      } else r = t;
    }
    return r;
  }
  function I(e) {
    var t;
    for (t in e) if (('data' !== t || !x.isEmptyObject(e[t])) && 'toJSON' !== t) return !1;
    return !0;
  }
  x.extend({
    queue: function(e, n, r) {
      var i;
      return e
        ? ((n = (n || 'fx') + 'queue'),
          (i = x._data(e, n)),
          r && (!i || x.isArray(r) ? (i = x._data(e, n, x.makeArray(r))) : i.push(r)),
          i || [])
        : t;
    },
    dequeue: function(e, t) {
      t = t || 'fx';
      var n = x.queue(e, t),
        r = n.length,
        i = n.shift(),
        o = x._queueHooks(e, t),
        a = function() {
          x.dequeue(e, t);
        };
      'inprogress' === i && ((i = n.shift()), r--),
        i && ('fx' === t && n.unshift('inprogress'), delete o.stop, i.call(e, a, o)),
        !r && o && o.empty.fire();
    },
    _queueHooks: function(e, t) {
      var n = t + 'queueHooks';
      return (
        x._data(e, n) ||
        x._data(e, n, {
          empty: x.Callbacks('once memory').add(function() {
            x._removeData(e, t + 'queue'), x._removeData(e, n);
          }),
        })
      );
    },
  }),
    x.fn.extend({
      queue: function(e, n) {
        var r = 2;
        return (
          'string' != typeof e && ((n = e), (e = 'fx'), r--),
          r > arguments.length
            ? x.queue(this[0], e)
            : n === t
            ? this
            : this.each(function() {
                var t = x.queue(this, e, n);
                x._queueHooks(this, e), 'fx' === e && 'inprogress' !== t[0] && x.dequeue(this, e);
              })
        );
      },
      dequeue: function(e) {
        return this.each(function() {
          x.dequeue(this, e);
        });
      },
      delay: function(e, t) {
        return (
          (e = x.fx ? x.fx.speeds[e] || e : e),
          (t = t || 'fx'),
          this.queue(t, function(t, n) {
            var r = setTimeout(t, e);
            n.stop = function() {
              clearTimeout(r);
            };
          })
        );
      },
      clearQueue: function(e) {
        return this.queue(e || 'fx', []);
      },
      promise: function(e, n) {
        var r,
          i = 1,
          o = x.Deferred(),
          a = this,
          s = this.length,
          l = function() {
            --i || o.resolveWith(a, [a]);
          };
        'string' != typeof e && ((n = e), (e = t)), (e = e || 'fx');
        while (s--) (r = x._data(a[s], e + 'queueHooks')), r && r.empty && (i++, r.empty.add(l));
        return l(), o.promise(n);
      },
    });
  var z,
    X,
    U = /[\t\r\n\f]/g,
    V = /\r/g,
    Y = /^(?:input|select|textarea|button|object)$/i,
    J = /^(?:a|area)$/i,
    G = /^(?:checked|selected)$/i,
    Q = x.support.getSetAttribute,
    K = x.support.input;
  x.fn.extend({
    attr: function(e, t) {
      return x.access(this, x.attr, e, t, arguments.length > 1);
    },
    removeAttr: function(e) {
      return this.each(function() {
        x.removeAttr(this, e);
      });
    },
    prop: function(e, t) {
      return x.access(this, x.prop, e, t, arguments.length > 1);
    },
    removeProp: function(e) {
      return (
        (e = x.propFix[e] || e),
        this.each(function() {
          try {
            (this[e] = t), delete this[e];
          } catch (n) {}
        })
      );
    },
    addClass: function(e) {
      var t,
        n,
        r,
        i,
        o,
        a = 0,
        s = this.length,
        l = 'string' == typeof e && e;
      if (x.isFunction(e))
        return this.each(function(t) {
          x(this).addClass(e.call(this, t, this.className));
        });
      if (l)
        for (t = (e || '').match(T) || []; s > a; a++)
          if (
            ((n = this[a]), (r = 1 === n.nodeType && (n.className ? (' ' + n.className + ' ').replace(U, ' ') : ' ')))
          ) {
            o = 0;
            while ((i = t[o++])) 0 > r.indexOf(' ' + i + ' ') && (r += i + ' ');
            n.className = x.trim(r);
          }
      return this;
    },
    removeClass: function(e) {
      var t,
        n,
        r,
        i,
        o,
        a = 0,
        s = this.length,
        l = 0 === arguments.length || ('string' == typeof e && e);
      if (x.isFunction(e))
        return this.each(function(t) {
          x(this).removeClass(e.call(this, t, this.className));
        });
      if (l)
        for (t = (e || '').match(T) || []; s > a; a++)
          if (
            ((n = this[a]), (r = 1 === n.nodeType && (n.className ? (' ' + n.className + ' ').replace(U, ' ') : '')))
          ) {
            o = 0;
            while ((i = t[o++])) while (r.indexOf(' ' + i + ' ') >= 0) r = r.replace(' ' + i + ' ', ' ');
            n.className = e ? x.trim(r) : '';
          }
      return this;
    },
    toggleClass: function(e, t) {
      var n = typeof e,
        r = 'boolean' == typeof t;
      return x.isFunction(e)
        ? this.each(function(n) {
            x(this).toggleClass(e.call(this, n, this.className, t), t);
          })
        : this.each(function() {
            if ('string' === n) {
              var o,
                a = 0,
                s = x(this),
                l = t,
                u = e.match(T) || [];
              while ((o = u[a++])) (l = r ? l : !s.hasClass(o)), s[l ? 'addClass' : 'removeClass'](o);
            } else (n === i || 'boolean' === n) && (this.className && x._data(this, '__className__', this.className), (this.className = this.className || e === !1 ? '' : x._data(this, '__className__') || ''));
          });
    },
    hasClass: function(e) {
      var t = ' ' + e + ' ',
        n = 0,
        r = this.length;
      for (; r > n; n++)
        if (1 === this[n].nodeType && (' ' + this[n].className + ' ').replace(U, ' ').indexOf(t) >= 0) return !0;
      return !1;
    },
    val: function(e) {
      var n,
        r,
        i,
        o = this[0];
      {
        if (arguments.length)
          return (
            (i = x.isFunction(e)),
            this.each(function(n) {
              var o;
              1 === this.nodeType &&
                ((o = i ? e.call(this, n, x(this).val()) : e),
                null == o
                  ? (o = '')
                  : 'number' == typeof o
                  ? (o += '')
                  : x.isArray(o) &&
                    (o = x.map(o, function(e) {
                      return null == e ? '' : e + '';
                    })),
                (r = x.valHooks[this.type] || x.valHooks[this.nodeName.toLowerCase()]),
                (r && 'set' in r && r.set(this, o, 'value') !== t) || (this.value = o));
            })
          );
        if (o)
          return (
            (r = x.valHooks[o.type] || x.valHooks[o.nodeName.toLowerCase()]),
            r && 'get' in r && (n = r.get(o, 'value')) !== t
              ? n
              : ((n = o.value), 'string' == typeof n ? n.replace(V, '') : null == n ? '' : n)
          );
      }
    },
  }),
    x.extend({
      valHooks: {
        option: {
          get: function(e) {
            var t = x.find.attr(e, 'value');
            return null != t ? t : e.text;
          },
        },
        select: {
          get: function(e) {
            var t,
              n,
              r = e.options,
              i = e.selectedIndex,
              o = 'select-one' === e.type || 0 > i,
              a = o ? null : [],
              s = o ? i + 1 : r.length,
              l = 0 > i ? s : o ? i : 0;
            for (; s > l; l++)
              if (
                ((n = r[l]),
                !(
                  (!n.selected && l !== i) ||
                  (x.support.optDisabled ? n.disabled : null !== n.getAttribute('disabled')) ||
                  (n.parentNode.disabled && x.nodeName(n.parentNode, 'optgroup'))
                ))
              ) {
                if (((t = x(n).val()), o)) return t;
                a.push(t);
              }
            return a;
          },
          set: function(e, t) {
            var n,
              r,
              i = e.options,
              o = x.makeArray(t),
              a = i.length;
            while (a--) (r = i[a]), (r.selected = x.inArray(x(r).val(), o) >= 0) && (n = !0);
            return n || (e.selectedIndex = -1), o;
          },
        },
      },
      attr: function(e, n, r) {
        var o,
          a,
          s = e.nodeType;
        if (e && 3 !== s && 8 !== s && 2 !== s)
          return typeof e.getAttribute === i
            ? x.prop(e, n, r)
            : ((1 === s && x.isXMLDoc(e)) ||
                ((n = n.toLowerCase()), (o = x.attrHooks[n] || (x.expr.match.bool.test(n) ? X : z))),
              r === t
                ? o && 'get' in o && null !== (a = o.get(e, n))
                  ? a
                  : ((a = x.find.attr(e, n)), null == a ? t : a)
                : null !== r
                ? o && 'set' in o && (a = o.set(e, r, n)) !== t
                  ? a
                  : (e.setAttribute(n, r + ''), r)
                : (x.removeAttr(e, n), t));
      },
      removeAttr: function(e, t) {
        var n,
          r,
          i = 0,
          o = t && t.match(T);
        if (o && 1 === e.nodeType)
          while ((n = o[i++]))
            (r = x.propFix[n] || n),
              x.expr.match.bool.test(n)
                ? (K && Q) || !G.test(n)
                  ? (e[r] = !1)
                  : (e[x.camelCase('default-' + n)] = e[r] = !1)
                : x.attr(e, n, ''),
              e.removeAttribute(Q ? n : r);
      },
      attrHooks: {
        type: {
          set: function(e, t) {
            if (!x.support.radioValue && 'radio' === t && x.nodeName(e, 'input')) {
              var n = e.value;
              return e.setAttribute('type', t), n && (e.value = n), t;
            }
          },
        },
      },
      propFix: { for: 'htmlFor', class: 'className' },
      prop: function(e, n, r) {
        var i,
          o,
          a,
          s = e.nodeType;
        if (e && 3 !== s && 8 !== s && 2 !== s)
          return (
            (a = 1 !== s || !x.isXMLDoc(e)),
            a && ((n = x.propFix[n] || n), (o = x.propHooks[n])),
            r !== t
              ? o && 'set' in o && (i = o.set(e, r, n)) !== t
                ? i
                : (e[n] = r)
              : o && 'get' in o && null !== (i = o.get(e, n))
              ? i
              : e[n]
          );
      },
      propHooks: {
        tabIndex: {
          get: function(e) {
            var t = x.find.attr(e, 'tabindex');
            return t ? parseInt(t, 10) : Y.test(e.nodeName) || (J.test(e.nodeName) && e.href) ? 0 : -1;
          },
        },
      },
    }),
    (X = {
      set: function(e, t, n) {
        return (
          t === !1
            ? x.removeAttr(e, n)
            : (K && Q) || !G.test(n)
            ? e.setAttribute((!Q && x.propFix[n]) || n, n)
            : (e[x.camelCase('default-' + n)] = e[n] = !0),
          n
        );
      },
    }),
    x.each(x.expr.match.bool.source.match(/\w+/g), function(e, n) {
      var r = x.expr.attrHandle[n] || x.find.attr;
      x.expr.attrHandle[n] =
        (K && Q) || !G.test(n)
          ? function(e, n, i) {
              var o = x.expr.attrHandle[n],
                a = i ? t : (x.expr.attrHandle[n] = t) != r(e, n, i) ? n.toLowerCase() : null;
              return (x.expr.attrHandle[n] = o), a;
            }
          : function(e, n, r) {
              return r ? t : e[x.camelCase('default-' + n)] ? n.toLowerCase() : null;
            };
    }),
    (K && Q) ||
      (x.attrHooks.value = {
        set: function(e, n, r) {
          return x.nodeName(e, 'input') ? ((e.defaultValue = n), t) : z && z.set(e, n, r);
        },
      }),
    Q ||
      ((z = {
        set: function(e, n, r) {
          var i = e.getAttributeNode(r);
          return (
            i || e.setAttributeNode((i = e.ownerDocument.createAttribute(r))),
            (i.value = n += ''),
            'value' === r || n === e.getAttribute(r) ? n : t
          );
        },
      }),
      (x.expr.attrHandle.id = x.expr.attrHandle.name = x.expr.attrHandle.coords = function(e, n, r) {
        var i;
        return r ? t : (i = e.getAttributeNode(n)) && '' !== i.value ? i.value : null;
      }),
      (x.valHooks.button = {
        get: function(e, n) {
          var r = e.getAttributeNode(n);
          return r && r.specified ? r.value : t;
        },
        set: z.set,
      }),
      (x.attrHooks.contenteditable = {
        set: function(e, t, n) {
          z.set(e, '' === t ? !1 : t, n);
        },
      }),
      x.each(['width', 'height'], function(e, n) {
        x.attrHooks[n] = {
          set: function(e, r) {
            return '' === r ? (e.setAttribute(n, 'auto'), r) : t;
          },
        };
      })),
    x.support.hrefNormalized ||
      x.each(['href', 'src'], function(e, t) {
        x.propHooks[t] = {
          get: function(e) {
            return e.getAttribute(t, 4);
          },
        };
      }),
    x.support.style ||
      (x.attrHooks.style = {
        get: function(e) {
          return e.style.cssText || t;
        },
        set: function(e, t) {
          return (e.style.cssText = t + '');
        },
      }),
    x.support.optSelected ||
      (x.propHooks.selected = {
        get: function(e) {
          var t = e.parentNode;
          return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null;
        },
      }),
    x.each(
      [
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable',
      ],
      function() {
        x.propFix[this.toLowerCase()] = this;
      }
    ),
    x.support.enctype || (x.propFix.enctype = 'encoding'),
    x.each(['radio', 'checkbox'], function() {
      (x.valHooks[this] = {
        set: function(e, n) {
          return x.isArray(n) ? (e.checked = x.inArray(x(e).val(), n) >= 0) : t;
        },
      }),
        x.support.checkOn ||
          (x.valHooks[this].get = function(e) {
            return null === e.getAttribute('value') ? 'on' : e.value;
          });
    });
  var Z = /^(?:input|select|textarea)$/i,
    et = /^key/,
    tt = /^(?:mouse|contextmenu)|click/,
    nt = /^(?:focusinfocus|focusoutblur)$/,
    rt = /^([^.]*)(?:\.(.+)|)$/;
  function it() {
    return !0;
  }
  function ot() {
    return !1;
  }
  function at() {
    try {
      return a.activeElement;
    } catch (e) {}
  }
  (x.event = {
    global: {},
    add: function(e, n, r, o, a) {
      var s,
        l,
        u,
        c,
        p,
        f,
        d,
        h,
        g,
        m,
        y,
        v = x._data(e);
      if (v) {
        r.handler && ((c = r), (r = c.handler), (a = c.selector)),
          r.guid || (r.guid = x.guid++),
          (l = v.events) || (l = v.events = {}),
          (f = v.handle) ||
            ((f = v.handle = function(e) {
              return typeof x === i || (e && x.event.triggered === e.type)
                ? t
                : x.event.dispatch.apply(f.elem, arguments);
            }),
            (f.elem = e)),
          (n = (n || '').match(T) || ['']),
          (u = n.length);
        while (u--)
          (s = rt.exec(n[u]) || []),
            (g = y = s[1]),
            (m = (s[2] || '').split('.').sort()),
            g &&
              ((p = x.event.special[g] || {}),
              (g = (a ? p.delegateType : p.bindType) || g),
              (p = x.event.special[g] || {}),
              (d = x.extend(
                {
                  type: g,
                  origType: y,
                  data: o,
                  handler: r,
                  guid: r.guid,
                  selector: a,
                  needsContext: a && x.expr.match.needsContext.test(a),
                  namespace: m.join('.'),
                },
                c
              )),
              (h = l[g]) ||
                ((h = l[g] = []),
                (h.delegateCount = 0),
                (p.setup && p.setup.call(e, o, m, f) !== !1) ||
                  (e.addEventListener ? e.addEventListener(g, f, !1) : e.attachEvent && e.attachEvent('on' + g, f))),
              p.add && (p.add.call(e, d), d.handler.guid || (d.handler.guid = r.guid)),
              a ? h.splice(h.delegateCount++, 0, d) : h.push(d),
              (x.event.global[g] = !0));
        e = null;
      }
    },
    remove: function(e, t, n, r, i) {
      var o,
        a,
        s,
        l,
        u,
        c,
        p,
        f,
        d,
        h,
        g,
        m = x.hasData(e) && x._data(e);
      if (m && (c = m.events)) {
        (t = (t || '').match(T) || ['']), (u = t.length);
        while (u--)
          if (((s = rt.exec(t[u]) || []), (d = g = s[1]), (h = (s[2] || '').split('.').sort()), d)) {
            (p = x.event.special[d] || {}),
              (d = (r ? p.delegateType : p.bindType) || d),
              (f = c[d] || []),
              (s = s[2] && RegExp('(^|\\.)' + h.join('\\.(?:.*\\.|)') + '(\\.|$)')),
              (l = o = f.length);
            while (o--)
              (a = f[o]),
                (!i && g !== a.origType) ||
                  (n && n.guid !== a.guid) ||
                  (s && !s.test(a.namespace)) ||
                  (r && r !== a.selector && ('**' !== r || !a.selector)) ||
                  (f.splice(o, 1), a.selector && f.delegateCount--, p.remove && p.remove.call(e, a));
            l &&
              !f.length &&
              ((p.teardown && p.teardown.call(e, h, m.handle) !== !1) || x.removeEvent(e, d, m.handle), delete c[d]);
          } else for (d in c) x.event.remove(e, d + t[u], n, r, !0);
        x.isEmptyObject(c) && (delete m.handle, x._removeData(e, 'events'));
      }
    },
    trigger: function(n, r, i, o) {
      var s,
        l,
        u,
        c,
        p,
        f,
        d,
        h = [i || a],
        g = v.call(n, 'type') ? n.type : n,
        m = v.call(n, 'namespace') ? n.namespace.split('.') : [];
      if (
        ((u = f = i = i || a),
        3 !== i.nodeType &&
          8 !== i.nodeType &&
          !nt.test(g + x.event.triggered) &&
          (g.indexOf('.') >= 0 && ((m = g.split('.')), (g = m.shift()), m.sort()),
          (l = 0 > g.indexOf(':') && 'on' + g),
          (n = n[x.expando] ? n : new x.Event(g, 'object' == typeof n && n)),
          (n.isTrigger = o ? 2 : 3),
          (n.namespace = m.join('.')),
          (n.namespace_re = n.namespace ? RegExp('(^|\\.)' + m.join('\\.(?:.*\\.|)') + '(\\.|$)') : null),
          (n.result = t),
          n.target || (n.target = i),
          (r = null == r ? [n] : x.makeArray(r, [n])),
          (p = x.event.special[g] || {}),
          o || !p.trigger || p.trigger.apply(i, r) !== !1))
      ) {
        if (!o && !p.noBubble && !x.isWindow(i)) {
          for (c = p.delegateType || g, nt.test(c + g) || (u = u.parentNode); u; u = u.parentNode) h.push(u), (f = u);
          f === (i.ownerDocument || a) && h.push(f.defaultView || f.parentWindow || e);
        }
        d = 0;
        while ((u = h[d++]) && !n.isPropagationStopped())
          (n.type = d > 1 ? c : p.bindType || g),
            (s = (x._data(u, 'events') || {})[n.type] && x._data(u, 'handle')),
            s && s.apply(u, r),
            (s = l && u[l]),
            s && x.acceptData(u) && s.apply && s.apply(u, r) === !1 && n.preventDefault();
        if (
          ((n.type = g),
          !o &&
            !n.isDefaultPrevented() &&
            (!p._default || p._default.apply(h.pop(), r) === !1) &&
            x.acceptData(i) &&
            l &&
            i[g] &&
            !x.isWindow(i))
        ) {
          (f = i[l]), f && (i[l] = null), (x.event.triggered = g);
          try {
            i[g]();
          } catch (y) {}
          (x.event.triggered = t), f && (i[l] = f);
        }
        return n.result;
      }
    },
    dispatch: function(e) {
      e = x.event.fix(e);
      var n,
        r,
        i,
        o,
        a,
        s = [],
        l = g.call(arguments),
        u = (x._data(this, 'events') || {})[e.type] || [],
        c = x.event.special[e.type] || {};
      if (((l[0] = e), (e.delegateTarget = this), !c.preDispatch || c.preDispatch.call(this, e) !== !1)) {
        (s = x.event.handlers.call(this, e, u)), (n = 0);
        while ((o = s[n++]) && !e.isPropagationStopped()) {
          (e.currentTarget = o.elem), (a = 0);
          while ((i = o.handlers[a++]) && !e.isImmediatePropagationStopped())
            (!e.namespace_re || e.namespace_re.test(i.namespace)) &&
              ((e.handleObj = i),
              (e.data = i.data),
              (r = ((x.event.special[i.origType] || {}).handle || i.handler).apply(o.elem, l)),
              r !== t && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()));
        }
        return c.postDispatch && c.postDispatch.call(this, e), e.result;
      }
    },
    handlers: function(e, n) {
      var r,
        i,
        o,
        a,
        s = [],
        l = n.delegateCount,
        u = e.target;
      if (l && u.nodeType && (!e.button || 'click' !== e.type))
        for (; u != this; u = u.parentNode || this)
          if (1 === u.nodeType && (u.disabled !== !0 || 'click' !== e.type)) {
            for (o = [], a = 0; l > a; a++)
              (i = n[a]),
                (r = i.selector + ' '),
                o[r] === t && (o[r] = i.needsContext ? x(r, this).index(u) >= 0 : x.find(r, this, null, [u]).length),
                o[r] && o.push(i);
            o.length && s.push({ elem: u, handlers: o });
          }
      return n.length > l && s.push({ elem: this, handlers: n.slice(l) }), s;
    },
    fix: function(e) {
      if (e[x.expando]) return e;
      var t,
        n,
        r,
        i = e.type,
        o = e,
        s = this.fixHooks[i];
      s || (this.fixHooks[i] = s = tt.test(i) ? this.mouseHooks : et.test(i) ? this.keyHooks : {}),
        (r = s.props ? this.props.concat(s.props) : this.props),
        (e = new x.Event(o)),
        (t = r.length);
      while (t--) (n = r[t]), (e[n] = o[n]);
      return (
        e.target || (e.target = o.srcElement || a),
        3 === e.target.nodeType && (e.target = e.target.parentNode),
        (e.metaKey = !!e.metaKey),
        s.filter ? s.filter(e, o) : e
      );
    },
    props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(
      ' '
    ),
    fixHooks: {},
    keyHooks: {
      props: 'char charCode key keyCode'.split(' '),
      filter: function(e, t) {
        return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e;
      },
    },
    mouseHooks: {
      props: 'button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(
        ' '
      ),
      filter: function(e, n) {
        var r,
          i,
          o,
          s = n.button,
          l = n.fromElement;
        return (
          null == e.pageX &&
            null != n.clientX &&
            ((i = e.target.ownerDocument || a),
            (o = i.documentElement),
            (r = i.body),
            (e.pageX =
              n.clientX +
              ((o && o.scrollLeft) || (r && r.scrollLeft) || 0) -
              ((o && o.clientLeft) || (r && r.clientLeft) || 0)),
            (e.pageY =
              n.clientY +
              ((o && o.scrollTop) || (r && r.scrollTop) || 0) -
              ((o && o.clientTop) || (r && r.clientTop) || 0))),
          !e.relatedTarget && l && (e.relatedTarget = l === e.target ? n.toElement : l),
          e.which || s === t || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0),
          e
        );
      },
    },
    special: {
      load: { noBubble: !0 },
      focus: {
        trigger: function() {
          if (this !== at() && this.focus)
            try {
              return this.focus(), !1;
            } catch (e) {}
        },
        delegateType: 'focusin',
      },
      blur: {
        trigger: function() {
          return this === at() && this.blur ? (this.blur(), !1) : t;
        },
        delegateType: 'focusout',
      },
      click: {
        trigger: function() {
          return x.nodeName(this, 'input') && 'checkbox' === this.type && this.click ? (this.click(), !1) : t;
        },
        _default: function(e) {
          return x.nodeName(e.target, 'a');
        },
      },
      beforeunload: {
        postDispatch: function(e) {
          e.result !== t && (e.originalEvent.returnValue = e.result);
        },
      },
    },
    simulate: function(e, t, n, r) {
      var i = x.extend(new x.Event(), n, { type: e, isSimulated: !0, originalEvent: {} });
      r ? x.event.trigger(i, null, t) : x.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault();
    },
  }),
    (x.removeEvent = a.removeEventListener
      ? function(e, t, n) {
          e.removeEventListener && e.removeEventListener(t, n, !1);
        }
      : function(e, t, n) {
          var r = 'on' + t;
          e.detachEvent && (typeof e[r] === i && (e[r] = null), e.detachEvent(r, n));
        }),
    (x.Event = function(e, n) {
      return this instanceof x.Event
        ? (e && e.type
            ? ((this.originalEvent = e),
              (this.type = e.type),
              (this.isDefaultPrevented =
                e.defaultPrevented || e.returnValue === !1 || (e.getPreventDefault && e.getPreventDefault()) ? it : ot))
            : (this.type = e),
          n && x.extend(this, n),
          (this.timeStamp = (e && e.timeStamp) || x.now()),
          (this[x.expando] = !0),
          t)
        : new x.Event(e, n);
    }),
    (x.Event.prototype = {
      isDefaultPrevented: ot,
      isPropagationStopped: ot,
      isImmediatePropagationStopped: ot,
      preventDefault: function() {
        var e = this.originalEvent;
        (this.isDefaultPrevented = it), e && (e.preventDefault ? e.preventDefault() : (e.returnValue = !1));
      },
      stopPropagation: function() {
        var e = this.originalEvent;
        (this.isPropagationStopped = it), e && (e.stopPropagation && e.stopPropagation(), (e.cancelBubble = !0));
      },
      stopImmediatePropagation: function() {
        (this.isImmediatePropagationStopped = it), this.stopPropagation();
      },
    }),
    x.each({ mouseenter: 'mouseover', mouseleave: 'mouseout' }, function(e, t) {
      x.event.special[e] = {
        delegateType: t,
        bindType: t,
        handle: function(e) {
          var n,
            r = this,
            i = e.relatedTarget,
            o = e.handleObj;
          return (
            (!i || (i !== r && !x.contains(r, i))) &&
              ((e.type = o.origType), (n = o.handler.apply(this, arguments)), (e.type = t)),
            n
          );
        },
      };
    }),
    x.support.submitBubbles ||
      (x.event.special.submit = {
        setup: function() {
          return x.nodeName(this, 'form')
            ? !1
            : (x.event.add(this, 'click._submit keypress._submit', function(e) {
                var n = e.target,
                  r = x.nodeName(n, 'input') || x.nodeName(n, 'button') ? n.form : t;
                r &&
                  !x._data(r, 'submitBubbles') &&
                  (x.event.add(r, 'submit._submit', function(e) {
                    e._submit_bubble = !0;
                  }),
                  x._data(r, 'submitBubbles', !0));
              }),
              t);
        },
        postDispatch: function(e) {
          e._submit_bubble &&
            (delete e._submit_bubble,
            this.parentNode && !e.isTrigger && x.event.simulate('submit', this.parentNode, e, !0));
        },
        teardown: function() {
          return x.nodeName(this, 'form') ? !1 : (x.event.remove(this, '._submit'), t);
        },
      }),
    x.support.changeBubbles ||
      (x.event.special.change = {
        setup: function() {
          return Z.test(this.nodeName)
            ? (('checkbox' === this.type || 'radio' === this.type) &&
                (x.event.add(this, 'propertychange._change', function(e) {
                  'checked' === e.originalEvent.propertyName && (this._just_changed = !0);
                }),
                x.event.add(this, 'click._change', function(e) {
                  this._just_changed && !e.isTrigger && (this._just_changed = !1),
                    x.event.simulate('change', this, e, !0);
                })),
              !1)
            : (x.event.add(this, 'beforeactivate._change', function(e) {
                var t = e.target;
                Z.test(t.nodeName) &&
                  !x._data(t, 'changeBubbles') &&
                  (x.event.add(t, 'change._change', function(e) {
                    !this.parentNode ||
                      e.isSimulated ||
                      e.isTrigger ||
                      x.event.simulate('change', this.parentNode, e, !0);
                  }),
                  x._data(t, 'changeBubbles', !0));
              }),
              t);
        },
        handle: function(e) {
          var n = e.target;
          return this !== n || e.isSimulated || e.isTrigger || ('radio' !== n.type && 'checkbox' !== n.type)
            ? e.handleObj.handler.apply(this, arguments)
            : t;
        },
        teardown: function() {
          return x.event.remove(this, '._change'), !Z.test(this.nodeName);
        },
      }),
    x.support.focusinBubbles ||
      x.each({ focus: 'focusin', blur: 'focusout' }, function(e, t) {
        var n = 0,
          r = function(e) {
            x.event.simulate(t, e.target, x.event.fix(e), !0);
          };
        x.event.special[t] = {
          setup: function() {
            0 === n++ && a.addEventListener(e, r, !0);
          },
          teardown: function() {
            0 === --n && a.removeEventListener(e, r, !0);
          },
        };
      }),
    x.fn.extend({
      on: function(e, n, r, i, o) {
        var a, s;
        if ('object' == typeof e) {
          'string' != typeof n && ((r = r || n), (n = t));
          for (a in e) this.on(a, n, r, e[a], o);
          return this;
        }
        if (
          (null == r && null == i
            ? ((i = n), (r = n = t))
            : null == i && ('string' == typeof n ? ((i = r), (r = t)) : ((i = r), (r = n), (n = t))),
          i === !1)
        )
          i = ot;
        else if (!i) return this;
        return (
          1 === o &&
            ((s = i),
            (i = function(e) {
              return x().off(e), s.apply(this, arguments);
            }),
            (i.guid = s.guid || (s.guid = x.guid++))),
          this.each(function() {
            x.event.add(this, e, i, r, n);
          })
        );
      },
      one: function(e, t, n, r) {
        return this.on(e, t, n, r, 1);
      },
      off: function(e, n, r) {
        var i, o;
        if (e && e.preventDefault && e.handleObj)
          return (
            (i = e.handleObj),
            x(e.delegateTarget).off(i.namespace ? i.origType + '.' + i.namespace : i.origType, i.selector, i.handler),
            this
          );
        if ('object' == typeof e) {
          for (o in e) this.off(o, n, e[o]);
          return this;
        }
        return (
          (n === !1 || 'function' == typeof n) && ((r = n), (n = t)),
          r === !1 && (r = ot),
          this.each(function() {
            x.event.remove(this, e, r, n);
          })
        );
      },
      trigger: function(e, t) {
        return this.each(function() {
          x.event.trigger(e, t, this);
        });
      },
      triggerHandler: function(e, n) {
        var r = this[0];
        return r ? x.event.trigger(e, n, r, !0) : t;
      },
    });
  var st = /^.[^:#\[\.,]*$/,
    lt = /^(?:parents|prev(?:Until|All))/,
    ut = x.expr.match.needsContext,
    ct = { children: !0, contents: !0, next: !0, prev: !0 };
  x.fn.extend({
    find: function(e) {
      var t,
        n = [],
        r = this,
        i = r.length;
      if ('string' != typeof e)
        return this.pushStack(
          x(e).filter(function() {
            for (t = 0; i > t; t++) if (x.contains(r[t], this)) return !0;
          })
        );
      for (t = 0; i > t; t++) x.find(e, r[t], n);
      return (
        (n = this.pushStack(i > 1 ? x.unique(n) : n)), (n.selector = this.selector ? this.selector + ' ' + e : e), n
      );
    },
    has: function(e) {
      var t,
        n = x(e, this),
        r = n.length;
      return this.filter(function() {
        for (t = 0; r > t; t++) if (x.contains(this, n[t])) return !0;
      });
    },
    not: function(e) {
      return this.pushStack(ft(this, e || [], !0));
    },
    filter: function(e) {
      return this.pushStack(ft(this, e || [], !1));
    },
    is: function(e) {
      return !!ft(this, 'string' == typeof e && ut.test(e) ? x(e) : e || [], !1).length;
    },
    closest: function(e, t) {
      var n,
        r = 0,
        i = this.length,
        o = [],
        a = ut.test(e) || 'string' != typeof e ? x(e, t || this.context) : 0;
      for (; i > r; r++)
        for (n = this[r]; n && n !== t; n = n.parentNode)
          if (11 > n.nodeType && (a ? a.index(n) > -1 : 1 === n.nodeType && x.find.matchesSelector(n, e))) {
            n = o.push(n);
            break;
          }
      return this.pushStack(o.length > 1 ? x.unique(o) : o);
    },
    index: function(e) {
      return e
        ? 'string' == typeof e
          ? x.inArray(this[0], x(e))
          : x.inArray(e.jquery ? e[0] : e, this)
        : this[0] && this[0].parentNode
        ? this.first().prevAll().length
        : -1;
    },
    add: function(e, t) {
      var n = 'string' == typeof e ? x(e, t) : x.makeArray(e && e.nodeType ? [e] : e),
        r = x.merge(this.get(), n);
      return this.pushStack(x.unique(r));
    },
    addBack: function(e) {
      return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
    },
  });
  function pt(e, t) {
    do e = e[t];
    while (e && 1 !== e.nodeType);
    return e;
  }
  x.each(
    {
      parent: function(e) {
        var t = e.parentNode;
        return t && 11 !== t.nodeType ? t : null;
      },
      parents: function(e) {
        return x.dir(e, 'parentNode');
      },
      parentsUntil: function(e, t, n) {
        return x.dir(e, 'parentNode', n);
      },
      next: function(e) {
        return pt(e, 'nextSibling');
      },
      prev: function(e) {
        return pt(e, 'previousSibling');
      },
      nextAll: function(e) {
        return x.dir(e, 'nextSibling');
      },
      prevAll: function(e) {
        return x.dir(e, 'previousSibling');
      },
      nextUntil: function(e, t, n) {
        return x.dir(e, 'nextSibling', n);
      },
      prevUntil: function(e, t, n) {
        return x.dir(e, 'previousSibling', n);
      },
      siblings: function(e) {
        return x.sibling((e.parentNode || {}).firstChild, e);
      },
      children: function(e) {
        return x.sibling(e.firstChild);
      },
      contents: function(e) {
        return x.nodeName(e, 'iframe') ? e.contentDocument || e.contentWindow.document : x.merge([], e.childNodes);
      },
    },
    function(e, t) {
      x.fn[e] = function(n, r) {
        var i = x.map(this, t, n);
        return (
          'Until' !== e.slice(-5) && (r = n),
          r && 'string' == typeof r && (i = x.filter(r, i)),
          this.length > 1 && (ct[e] || (i = x.unique(i)), lt.test(e) && (i = i.reverse())),
          this.pushStack(i)
        );
      };
    }
  ),
    x.extend({
      filter: function(e, t, n) {
        var r = t[0];
        return (
          n && (e = ':not(' + e + ')'),
          1 === t.length && 1 === r.nodeType
            ? x.find.matchesSelector(r, e)
              ? [r]
              : []
            : x.find.matches(
                e,
                x.grep(t, function(e) {
                  return 1 === e.nodeType;
                })
              )
        );
      },
      dir: function(e, n, r) {
        var i = [],
          o = e[n];
        while (o && 9 !== o.nodeType && (r === t || 1 !== o.nodeType || !x(o).is(r)))
          1 === o.nodeType && i.push(o), (o = o[n]);
        return i;
      },
      sibling: function(e, t) {
        var n = [];
        for (; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
        return n;
      },
    });
  function ft(e, t, n) {
    if (x.isFunction(t))
      return x.grep(e, function(e, r) {
        return !!t.call(e, r, e) !== n;
      });
    if (t.nodeType)
      return x.grep(e, function(e) {
        return (e === t) !== n;
      });
    if ('string' == typeof t) {
      if (st.test(t)) return x.filter(t, e, n);
      t = x.filter(t, e);
    }
    return x.grep(e, function(e) {
      return x.inArray(e, t) >= 0 !== n;
    });
  }
  function dt(e) {
    var t = ht.split('|'),
      n = e.createDocumentFragment();
    if (n.createElement) while (t.length) n.createElement(t.pop());
    return n;
  }
  var ht =
      'abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video',
    gt = / jQuery\d+="(?:null|\d+)"/g,
    mt = RegExp('<(?:' + ht + ')[\\s/>]', 'i'),
    yt = /^\s+/,
    vt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    bt = /<([\w:]+)/,
    xt = /<tbody/i,
    wt = /<|&#?\w+;/,
    Tt = /<(?:script|style|link)/i,
    Ct = /^(?:checkbox|radio)$/i,
    Nt = /checked\s*(?:[^=]|=\s*.checked.)/i,
    kt = /^$|\/(?:java|ecma)script/i,
    Et = /^true\/(.*)/,
    St = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    At = {
      option: [1, "<select multiple='multiple'>", '</select>'],
      legend: [1, '<fieldset>', '</fieldset>'],
      area: [1, '<map>', '</map>'],
      param: [1, '<object>', '</object>'],
      thead: [1, '<table>', '</table>'],
      tr: [2, '<table><tbody>', '</tbody></table>'],
      col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],
      _default: x.support.htmlSerialize ? [0, '', ''] : [1, 'X<div>', '</div>'],
    },
    jt = dt(a),
    Dt = jt.appendChild(a.createElement('div'));
  (At.optgroup = At.option),
    (At.tbody = At.tfoot = At.colgroup = At.caption = At.thead),
    (At.th = At.td),
    x.fn.extend({
      text: function(e) {
        return x.access(
          this,
          function(e) {
            return e === t
              ? x.text(this)
              : this.empty().append(((this[0] && this[0].ownerDocument) || a).createTextNode(e));
          },
          null,
          e,
          arguments.length
        );
      },
      append: function() {
        return this.domManip(arguments, function(e) {
          if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
            var t = Lt(this, e);
            t.appendChild(e);
          }
        });
      },
      prepend: function() {
        return this.domManip(arguments, function(e) {
          if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
            var t = Lt(this, e);
            t.insertBefore(e, t.firstChild);
          }
        });
      },
      before: function() {
        return this.domManip(arguments, function(e) {
          this.parentNode && this.parentNode.insertBefore(e, this);
        });
      },
      after: function() {
        return this.domManip(arguments, function(e) {
          this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
        });
      },
      remove: function(e, t) {
        var n,
          r = e ? x.filter(e, this) : this,
          i = 0;
        for (; null != (n = r[i]); i++)
          t || 1 !== n.nodeType || x.cleanData(Ft(n)),
            n.parentNode && (t && x.contains(n.ownerDocument, n) && _t(Ft(n, 'script')), n.parentNode.removeChild(n));
        return this;
      },
      empty: function() {
        var e,
          t = 0;
        for (; null != (e = this[t]); t++) {
          1 === e.nodeType && x.cleanData(Ft(e, !1));
          while (e.firstChild) e.removeChild(e.firstChild);
          e.options && x.nodeName(e, 'select') && (e.options.length = 0);
        }
        return this;
      },
      clone: function(e, t) {
        return (
          (e = null == e ? !1 : e),
          (t = null == t ? e : t),
          this.map(function() {
            return x.clone(this, e, t);
          })
        );
      },
      html: function(e) {
        return x.access(
          this,
          function(e) {
            var n = this[0] || {},
              r = 0,
              i = this.length;
            if (e === t) return 1 === n.nodeType ? n.innerHTML.replace(gt, '') : t;
            if (
              !(
                'string' != typeof e ||
                Tt.test(e) ||
                (!x.support.htmlSerialize && mt.test(e)) ||
                (!x.support.leadingWhitespace && yt.test(e)) ||
                At[(bt.exec(e) || ['', ''])[1].toLowerCase()]
              )
            ) {
              e = e.replace(vt, '<$1></$2>');
              try {
                for (; i > r; r++) (n = this[r] || {}), 1 === n.nodeType && (x.cleanData(Ft(n, !1)), (n.innerHTML = e));
                n = 0;
              } catch (o) {}
            }
            n && this.empty().append(e);
          },
          null,
          e,
          arguments.length
        );
      },
      replaceWith: function() {
        var e = x.map(this, function(e) {
            return [e.nextSibling, e.parentNode];
          }),
          t = 0;
        return (
          this.domManip(
            arguments,
            function(n) {
              var r = e[t++],
                i = e[t++];
              i && (r && r.parentNode !== i && (r = this.nextSibling), x(this).remove(), i.insertBefore(n, r));
            },
            !0
          ),
          t ? this : this.remove()
        );
      },
      detach: function(e) {
        return this.remove(e, !0);
      },
      domManip: function(e, t, n) {
        e = d.apply([], e);
        var r,
          i,
          o,
          a,
          s,
          l,
          u = 0,
          c = this.length,
          p = this,
          f = c - 1,
          h = e[0],
          g = x.isFunction(h);
        if (g || (!(1 >= c || 'string' != typeof h || x.support.checkClone) && Nt.test(h)))
          return this.each(function(r) {
            var i = p.eq(r);
            g && (e[0] = h.call(this, r, i.html())), i.domManip(e, t, n);
          });
        if (
          c &&
          ((l = x.buildFragment(e, this[0].ownerDocument, !1, !n && this)),
          (r = l.firstChild),
          1 === l.childNodes.length && (l = r),
          r)
        ) {
          for (a = x.map(Ft(l, 'script'), Ht), o = a.length; c > u; u++)
            (i = l), u !== f && ((i = x.clone(i, !0, !0)), o && x.merge(a, Ft(i, 'script'))), t.call(this[u], i, u);
          if (o)
            for (s = a[a.length - 1].ownerDocument, x.map(a, qt), u = 0; o > u; u++)
              (i = a[u]),
                kt.test(i.type || '') &&
                  !x._data(i, 'globalEval') &&
                  x.contains(s, i) &&
                  (i.src
                    ? x._evalUrl(i.src)
                    : x.globalEval((i.text || i.textContent || i.innerHTML || '').replace(St, '')));
          l = r = null;
        }
        return this;
      },
    });
  function Lt(e, t) {
    return x.nodeName(e, 'table') && x.nodeName(1 === t.nodeType ? t : t.firstChild, 'tr')
      ? e.getElementsByTagName('tbody')[0] || e.appendChild(e.ownerDocument.createElement('tbody'))
      : e;
  }
  function Ht(e) {
    return (e.type = (null !== x.find.attr(e, 'type')) + '/' + e.type), e;
  }
  function qt(e) {
    var t = Et.exec(e.type);
    return t ? (e.type = t[1]) : e.removeAttribute('type'), e;
  }
  function _t(e, t) {
    var n,
      r = 0;
    for (; null != (n = e[r]); r++) x._data(n, 'globalEval', !t || x._data(t[r], 'globalEval'));
  }
  function Mt(e, t) {
    if (1 === t.nodeType && x.hasData(e)) {
      var n,
        r,
        i,
        o = x._data(e),
        a = x._data(t, o),
        s = o.events;
      if (s) {
        delete a.handle, (a.events = {});
        for (n in s) for (r = 0, i = s[n].length; i > r; r++) x.event.add(t, n, s[n][r]);
      }
      a.data && (a.data = x.extend({}, a.data));
    }
  }
  function Ot(e, t) {
    var n, r, i;
    if (1 === t.nodeType) {
      if (((n = t.nodeName.toLowerCase()), !x.support.noCloneEvent && t[x.expando])) {
        i = x._data(t);
        for (r in i.events) x.removeEvent(t, r, i.handle);
        t.removeAttribute(x.expando);
      }
      'script' === n && t.text !== e.text
        ? ((Ht(t).text = e.text), qt(t))
        : 'object' === n
        ? (t.parentNode && (t.outerHTML = e.outerHTML),
          x.support.html5Clone && e.innerHTML && !x.trim(t.innerHTML) && (t.innerHTML = e.innerHTML))
        : 'input' === n && Ct.test(e.type)
        ? ((t.defaultChecked = t.checked = e.checked), t.value !== e.value && (t.value = e.value))
        : 'option' === n
        ? (t.defaultSelected = t.selected = e.defaultSelected)
        : ('input' === n || 'textarea' === n) && (t.defaultValue = e.defaultValue);
    }
  }
  x.each(
    {
      appendTo: 'append',
      prependTo: 'prepend',
      insertBefore: 'before',
      insertAfter: 'after',
      replaceAll: 'replaceWith',
    },
    function(e, t) {
      x.fn[e] = function(e) {
        var n,
          r = 0,
          i = [],
          o = x(e),
          a = o.length - 1;
        for (; a >= r; r++) (n = r === a ? this : this.clone(!0)), x(o[r])[t](n), h.apply(i, n.get());
        return this.pushStack(i);
      };
    }
  );
  function Ft(e, n) {
    var r,
      o,
      a = 0,
      s =
        typeof e.getElementsByTagName !== i
          ? e.getElementsByTagName(n || '*')
          : typeof e.querySelectorAll !== i
          ? e.querySelectorAll(n || '*')
          : t;
    if (!s)
      for (s = [], r = e.childNodes || e; null != (o = r[a]); a++)
        !n || x.nodeName(o, n) ? s.push(o) : x.merge(s, Ft(o, n));
    return n === t || (n && x.nodeName(e, n)) ? x.merge([e], s) : s;
  }
  function Bt(e) {
    Ct.test(e.type) && (e.defaultChecked = e.checked);
  }
  x.extend({
    clone: function(e, t, n) {
      var r,
        i,
        o,
        a,
        s,
        l = x.contains(e.ownerDocument, e);
      if (
        (x.support.html5Clone || x.isXMLDoc(e) || !mt.test('<' + e.nodeName + '>')
          ? (o = e.cloneNode(!0))
          : ((Dt.innerHTML = e.outerHTML), Dt.removeChild((o = Dt.firstChild))),
        !(
          (x.support.noCloneEvent && x.support.noCloneChecked) ||
          (1 !== e.nodeType && 11 !== e.nodeType) ||
          x.isXMLDoc(e)
        ))
      )
        for (r = Ft(o), s = Ft(e), a = 0; null != (i = s[a]); ++a) r[a] && Ot(i, r[a]);
      if (t)
        if (n) for (s = s || Ft(e), r = r || Ft(o), a = 0; null != (i = s[a]); a++) Mt(i, r[a]);
        else Mt(e, o);
      return (r = Ft(o, 'script')), r.length > 0 && _t(r, !l && Ft(e, 'script')), (r = s = i = null), o;
    },
    buildFragment: function(e, t, n, r) {
      var i,
        o,
        a,
        s,
        l,
        u,
        c,
        p = e.length,
        f = dt(t),
        d = [],
        h = 0;
      for (; p > h; h++)
        if (((o = e[h]), o || 0 === o))
          if ('object' === x.type(o)) x.merge(d, o.nodeType ? [o] : o);
          else if (wt.test(o)) {
            (s = s || f.appendChild(t.createElement('div'))),
              (l = (bt.exec(o) || ['', ''])[1].toLowerCase()),
              (c = At[l] || At._default),
              (s.innerHTML = c[1] + o.replace(vt, '<$1></$2>') + c[2]),
              (i = c[0]);
            while (i--) s = s.lastChild;
            if (
              (!x.support.leadingWhitespace && yt.test(o) && d.push(t.createTextNode(yt.exec(o)[0])), !x.support.tbody)
            ) {
              (o = 'table' !== l || xt.test(o) ? ('<table>' !== c[1] || xt.test(o) ? 0 : s) : s.firstChild),
                (i = o && o.childNodes.length);
              while (i--) x.nodeName((u = o.childNodes[i]), 'tbody') && !u.childNodes.length && o.removeChild(u);
            }
            x.merge(d, s.childNodes), (s.textContent = '');
            while (s.firstChild) s.removeChild(s.firstChild);
            s = f.lastChild;
          } else d.push(t.createTextNode(o));
      s && f.removeChild(s), x.support.appendChecked || x.grep(Ft(d, 'input'), Bt), (h = 0);
      while ((o = d[h++]))
        if (
          (!r || -1 === x.inArray(o, r)) &&
          ((a = x.contains(o.ownerDocument, o)), (s = Ft(f.appendChild(o), 'script')), a && _t(s), n)
        ) {
          i = 0;
          while ((o = s[i++])) kt.test(o.type || '') && n.push(o);
        }
      return (s = null), f;
    },
    cleanData: function(e, t) {
      var n,
        r,
        o,
        a,
        s = 0,
        l = x.expando,
        u = x.cache,
        c = x.support.deleteExpando,
        f = x.event.special;
      for (; null != (n = e[s]); s++)
        if ((t || x.acceptData(n)) && ((o = n[l]), (a = o && u[o]))) {
          if (a.events) for (r in a.events) f[r] ? x.event.remove(n, r) : x.removeEvent(n, r, a.handle);
          u[o] &&
            (delete u[o],
            c ? delete n[l] : typeof n.removeAttribute !== i ? n.removeAttribute(l) : (n[l] = null),
            p.push(o));
        }
    },
    _evalUrl: function(e) {
      return x.ajax({ url: e, type: 'GET', dataType: 'script', async: !1, global: !1, throws: !0 });
    },
  }),
    x.fn.extend({
      wrapAll: function(e) {
        if (x.isFunction(e))
          return this.each(function(t) {
            x(this).wrapAll(e.call(this, t));
          });
        if (this[0]) {
          var t = x(e, this[0].ownerDocument)
            .eq(0)
            .clone(!0);
          this[0].parentNode && t.insertBefore(this[0]),
            t
              .map(function() {
                var e = this;
                while (e.firstChild && 1 === e.firstChild.nodeType) e = e.firstChild;
                return e;
              })
              .append(this);
        }
        return this;
      },
      wrapInner: function(e) {
        return x.isFunction(e)
          ? this.each(function(t) {
              x(this).wrapInner(e.call(this, t));
            })
          : this.each(function() {
              var t = x(this),
                n = t.contents();
              n.length ? n.wrapAll(e) : t.append(e);
            });
      },
      wrap: function(e) {
        var t = x.isFunction(e);
        return this.each(function(n) {
          x(this).wrapAll(t ? e.call(this, n) : e);
        });
      },
      unwrap: function() {
        return this.parent()
          .each(function() {
            x.nodeName(this, 'body') || x(this).replaceWith(this.childNodes);
          })
          .end();
      },
    });
  var Pt,
    Rt,
    Wt,
    $t = /alpha\([^)]*\)/i,
    It = /opacity\s*=\s*([^)]*)/,
    zt = /^(top|right|bottom|left)$/,
    Xt = /^(none|table(?!-c[ea]).+)/,
    Ut = /^margin/,
    Vt = RegExp('^(' + w + ')(.*)$', 'i'),
    Yt = RegExp('^(' + w + ')(?!px)[a-z%]+$', 'i'),
    Jt = RegExp('^([+-])=(' + w + ')', 'i'),
    Gt = { BODY: 'block' },
    Qt = { position: 'absolute', visibility: 'hidden', display: 'block' },
    Kt = { letterSpacing: 0, fontWeight: 400 },
    Zt = ['Top', 'Right', 'Bottom', 'Left'],
    en = ['Webkit', 'O', 'Moz', 'ms'];
  function tn(e, t) {
    if (t in e) return t;
    var n = t.charAt(0).toUpperCase() + t.slice(1),
      r = t,
      i = en.length;
    while (i--) if (((t = en[i] + n), t in e)) return t;
    return r;
  }
  function nn(e, t) {
    return (e = t || e), 'none' === x.css(e, 'display') || !x.contains(e.ownerDocument, e);
  }
  function rn(e, t) {
    var n,
      r,
      i,
      o = [],
      a = 0,
      s = e.length;
    for (; s > a; a++)
      (r = e[a]),
        r.style &&
          ((o[a] = x._data(r, 'olddisplay')),
          (n = r.style.display),
          t
            ? (o[a] || 'none' !== n || (r.style.display = ''),
              '' === r.style.display && nn(r) && (o[a] = x._data(r, 'olddisplay', ln(r.nodeName))))
            : o[a] ||
              ((i = nn(r)), ((n && 'none' !== n) || !i) && x._data(r, 'olddisplay', i ? n : x.css(r, 'display'))));
    for (a = 0; s > a; a++)
      (r = e[a]),
        r.style &&
          ((t && 'none' !== r.style.display && '' !== r.style.display) || (r.style.display = t ? o[a] || '' : 'none'));
    return e;
  }
  x.fn.extend({
    css: function(e, n) {
      return x.access(
        this,
        function(e, n, r) {
          var i,
            o,
            a = {},
            s = 0;
          if (x.isArray(n)) {
            for (o = Rt(e), i = n.length; i > s; s++) a[n[s]] = x.css(e, n[s], !1, o);
            return a;
          }
          return r !== t ? x.style(e, n, r) : x.css(e, n);
        },
        e,
        n,
        arguments.length > 1
      );
    },
    show: function() {
      return rn(this, !0);
    },
    hide: function() {
      return rn(this);
    },
    toggle: function(e) {
      var t = 'boolean' == typeof e;
      return this.each(function() {
        (t ? e : nn(this)) ? x(this).show() : x(this).hide();
      });
    },
  }),
    x.extend({
      cssHooks: {
        opacity: {
          get: function(e, t) {
            if (t) {
              var n = Wt(e, 'opacity');
              return '' === n ? '1' : n;
            }
          },
        },
      },
      cssNumber: {
        columnCount: !0,
        fillOpacity: !0,
        fontWeight: !0,
        lineHeight: !0,
        opacity: !0,
        orphans: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
      },
      cssProps: { float: x.support.cssFloat ? 'cssFloat' : 'styleFloat' },
      style: function(e, n, r, i) {
        if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
          var o,
            a,
            s,
            l = x.camelCase(n),
            u = e.style;
          if (((n = x.cssProps[l] || (x.cssProps[l] = tn(u, l))), (s = x.cssHooks[n] || x.cssHooks[l]), r === t))
            return s && 'get' in s && (o = s.get(e, !1, i)) !== t ? o : u[n];
          if (
            ((a = typeof r),
            'string' === a && (o = Jt.exec(r)) && ((r = (o[1] + 1) * o[2] + parseFloat(x.css(e, n))), (a = 'number')),
            !(
              null == r ||
              ('number' === a && isNaN(r)) ||
              ('number' !== a || x.cssNumber[l] || (r += 'px'),
              x.support.clearCloneStyle || '' !== r || 0 !== n.indexOf('background') || (u[n] = 'inherit'),
              s && 'set' in s && (r = s.set(e, r, i)) === t)
            ))
          )
            try {
              u[n] = r;
            } catch (c) {}
        }
      },
      css: function(e, n, r, i) {
        var o,
          a,
          s,
          l = x.camelCase(n);
        return (
          (n = x.cssProps[l] || (x.cssProps[l] = tn(e.style, l))),
          (s = x.cssHooks[n] || x.cssHooks[l]),
          s && 'get' in s && (a = s.get(e, !0, r)),
          a === t && (a = Wt(e, n, i)),
          'normal' === a && n in Kt && (a = Kt[n]),
          '' === r || r ? ((o = parseFloat(a)), r === !0 || x.isNumeric(o) ? o || 0 : a) : a
        );
      },
    }),
    e.getComputedStyle
      ? ((Rt = function(t) {
          return e.getComputedStyle(t, null);
        }),
        (Wt = function(e, n, r) {
          var i,
            o,
            a,
            s = r || Rt(e),
            l = s ? s.getPropertyValue(n) || s[n] : t,
            u = e.style;
          return (
            s &&
              ('' !== l || x.contains(e.ownerDocument, e) || (l = x.style(e, n)),
              Yt.test(l) &&
                Ut.test(n) &&
                ((i = u.width),
                (o = u.minWidth),
                (a = u.maxWidth),
                (u.minWidth = u.maxWidth = u.width = l),
                (l = s.width),
                (u.width = i),
                (u.minWidth = o),
                (u.maxWidth = a))),
            l
          );
        }))
      : a.documentElement.currentStyle &&
        ((Rt = function(e) {
          return e.currentStyle;
        }),
        (Wt = function(e, n, r) {
          var i,
            o,
            a,
            s = r || Rt(e),
            l = s ? s[n] : t,
            u = e.style;
          return (
            null == l && u && u[n] && (l = u[n]),
            Yt.test(l) &&
              !zt.test(n) &&
              ((i = u.left),
              (o = e.runtimeStyle),
              (a = o && o.left),
              a && (o.left = e.currentStyle.left),
              (u.left = 'fontSize' === n ? '1em' : l),
              (l = u.pixelLeft + 'px'),
              (u.left = i),
              a && (o.left = a)),
            '' === l ? 'auto' : l
          );
        }));
  function on(e, t, n) {
    var r = Vt.exec(t);
    return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || 'px') : t;
  }
  function an(e, t, n, r, i) {
    var o = n === (r ? 'border' : 'content') ? 4 : 'width' === t ? 1 : 0,
      a = 0;
    for (; 4 > o; o += 2)
      'margin' === n && (a += x.css(e, n + Zt[o], !0, i)),
        r
          ? ('content' === n && (a -= x.css(e, 'padding' + Zt[o], !0, i)),
            'margin' !== n && (a -= x.css(e, 'border' + Zt[o] + 'Width', !0, i)))
          : ((a += x.css(e, 'padding' + Zt[o], !0, i)),
            'padding' !== n && (a += x.css(e, 'border' + Zt[o] + 'Width', !0, i)));
    return a;
  }
  function sn(e, t, n) {
    var r = !0,
      i = 'width' === t ? e.offsetWidth : e.offsetHeight,
      o = Rt(e),
      a = x.support.boxSizing && 'border-box' === x.css(e, 'boxSizing', !1, o);
    if (0 >= i || null == i) {
      if (((i = Wt(e, t, o)), (0 > i || null == i) && (i = e.style[t]), Yt.test(i))) return i;
      (r = a && (x.support.boxSizingReliable || i === e.style[t])), (i = parseFloat(i) || 0);
    }
    return i + an(e, t, n || (a ? 'border' : 'content'), r, o) + 'px';
  }
  function ln(e) {
    var t = a,
      n = Gt[e];
    return (
      n ||
        ((n = un(e, t)),
        ('none' !== n && n) ||
          ((Pt = (
            Pt || x("<iframe frameborder='0' width='0' height='0'/>").css('cssText', 'display:block !important')
          ).appendTo(t.documentElement)),
          (t = (Pt[0].contentWindow || Pt[0].contentDocument).document),
          t.write('<!doctype html><html><body>'),
          t.close(),
          (n = un(e, t)),
          Pt.detach()),
        (Gt[e] = n)),
      n
    );
  }
  function un(e, t) {
    var n = x(t.createElement(e)).appendTo(t.body),
      r = x.css(n[0], 'display');
    return n.remove(), r;
  }
  x.each(['height', 'width'], function(e, n) {
    x.cssHooks[n] = {
      get: function(e, r, i) {
        return r
          ? 0 === e.offsetWidth && Xt.test(x.css(e, 'display'))
            ? x.swap(e, Qt, function() {
                return sn(e, n, i);
              })
            : sn(e, n, i)
          : t;
      },
      set: function(e, t, r) {
        var i = r && Rt(e);
        return on(e, t, r ? an(e, n, r, x.support.boxSizing && 'border-box' === x.css(e, 'boxSizing', !1, i), i) : 0);
      },
    };
  }),
    x.support.opacity ||
      (x.cssHooks.opacity = {
        get: function(e, t) {
          return It.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || '')
            ? 0.01 * parseFloat(RegExp.$1) + ''
            : t
            ? '1'
            : '';
        },
        set: function(e, t) {
          var n = e.style,
            r = e.currentStyle,
            i = x.isNumeric(t) ? 'alpha(opacity=' + 100 * t + ')' : '',
            o = (r && r.filter) || n.filter || '';
          (n.zoom = 1),
            ((t >= 1 || '' === t) &&
              '' === x.trim(o.replace($t, '')) &&
              n.removeAttribute &&
              (n.removeAttribute('filter'), '' === t || (r && !r.filter))) ||
              (n.filter = $t.test(o) ? o.replace($t, i) : o + ' ' + i);
        },
      }),
    x(function() {
      x.support.reliableMarginRight ||
        (x.cssHooks.marginRight = {
          get: function(e, n) {
            return n ? x.swap(e, { display: 'inline-block' }, Wt, [e, 'marginRight']) : t;
          },
        }),
        !x.support.pixelPosition &&
          x.fn.position &&
          x.each(['top', 'left'], function(e, n) {
            x.cssHooks[n] = {
              get: function(e, r) {
                return r ? ((r = Wt(e, n)), Yt.test(r) ? x(e).position()[n] + 'px' : r) : t;
              },
            };
          });
    }),
    x.expr &&
      x.expr.filters &&
      ((x.expr.filters.hidden = function(e) {
        return (
          (0 >= e.offsetWidth && 0 >= e.offsetHeight) ||
          (!x.support.reliableHiddenOffsets && 'none' === ((e.style && e.style.display) || x.css(e, 'display')))
        );
      }),
      (x.expr.filters.visible = function(e) {
        return !x.expr.filters.hidden(e);
      })),
    x.each({ margin: '', padding: '', border: 'Width' }, function(e, t) {
      (x.cssHooks[e + t] = {
        expand: function(n) {
          var r = 0,
            i = {},
            o = 'string' == typeof n ? n.split(' ') : [n];
          for (; 4 > r; r++) i[e + Zt[r] + t] = o[r] || o[r - 2] || o[0];
          return i;
        },
      }),
        Ut.test(e) || (x.cssHooks[e + t].set = on);
    });
  var cn = /%20/g,
    pn = /\[\]$/,
    fn = /\r?\n/g,
    dn = /^(?:submit|button|image|reset|file)$/i,
    hn = /^(?:input|select|textarea|keygen)/i;
  x.fn.extend({
    serialize: function() {
      return x.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var e = x.prop(this, 'elements');
        return e ? x.makeArray(e) : this;
      })
        .filter(function() {
          var e = this.type;
          return (
            this.name &&
            !x(this).is(':disabled') &&
            hn.test(this.nodeName) &&
            !dn.test(e) &&
            (this.checked || !Ct.test(e))
          );
        })
        .map(function(e, t) {
          var n = x(this).val();
          return null == n
            ? null
            : x.isArray(n)
            ? x.map(n, function(e) {
                return { name: t.name, value: e.replace(fn, '\r\n') };
              })
            : { name: t.name, value: n.replace(fn, '\r\n') };
        })
        .get();
    },
  }),
    (x.param = function(e, n) {
      var r,
        i = [],
        o = function(e, t) {
          (t = x.isFunction(t) ? t() : null == t ? '' : t),
            (i[i.length] = encodeURIComponent(e) + '=' + encodeURIComponent(t));
        };
      if (
        (n === t && (n = x.ajaxSettings && x.ajaxSettings.traditional),
        x.isArray(e) || (e.jquery && !x.isPlainObject(e)))
      )
        x.each(e, function() {
          o(this.name, this.value);
        });
      else for (r in e) gn(r, e[r], n, o);
      return i.join('&').replace(cn, '+');
    });
  function gn(e, t, n, r) {
    var i;
    if (x.isArray(t))
      x.each(t, function(t, i) {
        n || pn.test(e) ? r(e, i) : gn(e + '[' + ('object' == typeof i ? t : '') + ']', i, n, r);
      });
    else if (n || 'object' !== x.type(t)) r(e, t);
    else for (i in t) gn(e + '[' + i + ']', t[i], n, r);
  }
  x.each(
    'blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu'.split(
      ' '
    ),
    function(e, t) {
      x.fn[t] = function(e, n) {
        return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t);
      };
    }
  ),
    x.fn.extend({
      hover: function(e, t) {
        return this.mouseenter(e).mouseleave(t || e);
      },
      bind: function(e, t, n) {
        return this.on(e, null, t, n);
      },
      unbind: function(e, t) {
        return this.off(e, null, t);
      },
      delegate: function(e, t, n, r) {
        return this.on(t, e, n, r);
      },
      undelegate: function(e, t, n) {
        return 1 === arguments.length ? this.off(e, '**') : this.off(t, e || '**', n);
      },
    });
  var mn,
    yn,
    vn = x.now(),
    bn = /\?/,
    xn = /#.*$/,
    wn = /([?&])_=[^&]*/,
    Tn = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
    Cn = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    Nn = /^(?:GET|HEAD)$/,
    kn = /^\/\//,
    En = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
    Sn = x.fn.load,
    An = {},
    jn = {},
    Dn = '*/'.concat('*');
  try {
    yn = o.href;
  } catch (Ln) {
    (yn = a.createElement('a')), (yn.href = ''), (yn = yn.href);
  }
  mn = En.exec(yn.toLowerCase()) || [];
  function Hn(e) {
    return function(t, n) {
      'string' != typeof t && ((n = t), (t = '*'));
      var r,
        i = 0,
        o = t.toLowerCase().match(T) || [];
      if (x.isFunction(n))
        while ((r = o[i++]))
          '+' === r[0] ? ((r = r.slice(1) || '*'), (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n);
    };
  }
  function qn(e, n, r, i) {
    var o = {},
      a = e === jn;
    function s(l) {
      var u;
      return (
        (o[l] = !0),
        x.each(e[l] || [], function(e, l) {
          var c = l(n, r, i);
          return 'string' != typeof c || a || o[c] ? (a ? !(u = c) : t) : (n.dataTypes.unshift(c), s(c), !1);
        }),
        u
      );
    }
    return s(n.dataTypes[0]) || (!o['*'] && s('*'));
  }
  function _n(e, n) {
    var r,
      i,
      o = x.ajaxSettings.flatOptions || {};
    for (i in n) n[i] !== t && ((o[i] ? e : r || (r = {}))[i] = n[i]);
    return r && x.extend(!0, e, r), e;
  }
  (x.fn.load = function(e, n, r) {
    if ('string' != typeof e && Sn) return Sn.apply(this, arguments);
    var i,
      o,
      a,
      s = this,
      l = e.indexOf(' ');
    return (
      l >= 0 && ((i = e.slice(l, e.length)), (e = e.slice(0, l))),
      x.isFunction(n) ? ((r = n), (n = t)) : n && 'object' == typeof n && (a = 'POST'),
      s.length > 0 &&
        x
          .ajax({ url: e, type: a, dataType: 'html', data: n })
          .done(function(e) {
            (o = arguments),
              s.html(
                i
                  ? x('<div>')
                      .append(x.parseHTML(e))
                      .find(i)
                  : e
              );
          })
          .complete(
            r &&
              function(e, t) {
                s.each(r, o || [e.responseText, t, e]);
              }
          ),
      this
    );
  }),
    x.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function(e, t) {
      x.fn[t] = function(e) {
        return this.on(t, e);
      };
    }),
    x.extend({
      active: 0,
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: yn,
        type: 'GET',
        isLocal: Cn.test(mn[1]),
        global: !0,
        processData: !0,
        async: !0,
        contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
        accepts: {
          '*': Dn,
          text: 'text/plain',
          html: 'text/html',
          xml: 'application/xml, text/xml',
          json: 'application/json, text/javascript',
        },
        contents: { xml: /xml/, html: /html/, json: /json/ },
        responseFields: { xml: 'responseXML', text: 'responseText', json: 'responseJSON' },
        converters: { '* text': String, 'text html': !0, 'text json': x.parseJSON, 'text xml': x.parseXML },
        flatOptions: { url: !0, context: !0 },
      },
      ajaxSetup: function(e, t) {
        return t ? _n(_n(e, x.ajaxSettings), t) : _n(x.ajaxSettings, e);
      },
      ajaxPrefilter: Hn(An),
      ajaxTransport: Hn(jn),
      ajax: function(e, n) {
        'object' == typeof e && ((n = e), (e = t)), (n = n || {});
        var r,
          i,
          o,
          a,
          s,
          l,
          u,
          c,
          p = x.ajaxSetup({}, n),
          f = p.context || p,
          d = p.context && (f.nodeType || f.jquery) ? x(f) : x.event,
          h = x.Deferred(),
          g = x.Callbacks('once memory'),
          m = p.statusCode || {},
          y = {},
          v = {},
          b = 0,
          w = 'canceled',
          C = {
            readyState: 0,
            getResponseHeader: function(e) {
              var t;
              if (2 === b) {
                if (!c) {
                  c = {};
                  while ((t = Tn.exec(a))) c[t[1].toLowerCase()] = t[2];
                }
                t = c[e.toLowerCase()];
              }
              return null == t ? null : t;
            },
            getAllResponseHeaders: function() {
              return 2 === b ? a : null;
            },
            setRequestHeader: function(e, t) {
              var n = e.toLowerCase();
              return b || ((e = v[n] = v[n] || e), (y[e] = t)), this;
            },
            overrideMimeType: function(e) {
              return b || (p.mimeType = e), this;
            },
            statusCode: function(e) {
              var t;
              if (e)
                if (2 > b) for (t in e) m[t] = [m[t], e[t]];
                else C.always(e[C.status]);
              return this;
            },
            abort: function(e) {
              var t = e || w;
              return u && u.abort(t), k(0, t), this;
            },
          };
        if (
          ((h.promise(C).complete = g.add),
          (C.success = C.done),
          (C.error = C.fail),
          (p.url = ((e || p.url || yn) + '').replace(xn, '').replace(kn, mn[1] + '//')),
          (p.type = n.method || n.type || p.method || p.type),
          (p.dataTypes = x
            .trim(p.dataType || '*')
            .toLowerCase()
            .match(T) || ['']),
          null == p.crossDomain &&
            ((r = En.exec(p.url.toLowerCase())),
            (p.crossDomain = !(
              !r ||
              (r[1] === mn[1] &&
                r[2] === mn[2] &&
                (r[3] || ('http:' === r[1] ? '80' : '443')) === (mn[3] || ('http:' === mn[1] ? '80' : '443')))
            ))),
          p.data && p.processData && 'string' != typeof p.data && (p.data = x.param(p.data, p.traditional)),
          qn(An, p, n, C),
          2 === b)
        )
          return C;
        (l = p.global),
          l && 0 === x.active++ && x.event.trigger('ajaxStart'),
          (p.type = p.type.toUpperCase()),
          (p.hasContent = !Nn.test(p.type)),
          (o = p.url),
          p.hasContent ||
            (p.data && ((o = p.url += (bn.test(o) ? '&' : '?') + p.data), delete p.data),
            p.cache === !1 &&
              (p.url = wn.test(o) ? o.replace(wn, '$1_=' + vn++) : o + (bn.test(o) ? '&' : '?') + '_=' + vn++)),
          p.ifModified &&
            (x.lastModified[o] && C.setRequestHeader('If-Modified-Since', x.lastModified[o]),
            x.etag[o] && C.setRequestHeader('If-None-Match', x.etag[o])),
          ((p.data && p.hasContent && p.contentType !== !1) || n.contentType) &&
            C.setRequestHeader('Content-Type', p.contentType),
          C.setRequestHeader(
            'Accept',
            p.dataTypes[0] && p.accepts[p.dataTypes[0]]
              ? p.accepts[p.dataTypes[0]] + ('*' !== p.dataTypes[0] ? ', ' + Dn + '; q=0.01' : '')
              : p.accepts['*']
          );
        for (i in p.headers) C.setRequestHeader(i, p.headers[i]);
        if (p.beforeSend && (p.beforeSend.call(f, C, p) === !1 || 2 === b)) return C.abort();
        w = 'abort';
        for (i in { success: 1, error: 1, complete: 1 }) C[i](p[i]);
        if ((u = qn(jn, p, n, C))) {
          (C.readyState = 1),
            l && d.trigger('ajaxSend', [C, p]),
            p.async &&
              p.timeout > 0 &&
              (s = setTimeout(function() {
                C.abort('timeout');
              }, p.timeout));
          try {
            (b = 1), u.send(y, k);
          } catch (N) {
            if (!(2 > b)) throw N;
            k(-1, N);
          }
        } else k(-1, 'No Transport');
        function k(e, n, r, i) {
          var c,
            y,
            v,
            w,
            T,
            N = n;
          2 !== b &&
            ((b = 2),
            s && clearTimeout(s),
            (u = t),
            (a = i || ''),
            (C.readyState = e > 0 ? 4 : 0),
            (c = (e >= 200 && 300 > e) || 304 === e),
            r && (w = Mn(p, C, r)),
            (w = On(p, w, C, c)),
            c
              ? (p.ifModified &&
                  ((T = C.getResponseHeader('Last-Modified')),
                  T && (x.lastModified[o] = T),
                  (T = C.getResponseHeader('etag')),
                  T && (x.etag[o] = T)),
                204 === e || 'HEAD' === p.type
                  ? (N = 'nocontent')
                  : 304 === e
                  ? (N = 'notmodified')
                  : ((N = w.state), (y = w.data), (v = w.error), (c = !v)))
              : ((v = N), (e || !N) && ((N = 'error'), 0 > e && (e = 0))),
            (C.status = e),
            (C.statusText = (n || N) + ''),
            c ? h.resolveWith(f, [y, N, C]) : h.rejectWith(f, [C, N, v]),
            C.statusCode(m),
            (m = t),
            l && d.trigger(c ? 'ajaxSuccess' : 'ajaxError', [C, p, c ? y : v]),
            g.fireWith(f, [C, N]),
            l && (d.trigger('ajaxComplete', [C, p]), --x.active || x.event.trigger('ajaxStop')));
        }
        return C;
      },
      getJSON: function(e, t, n) {
        return x.get(e, t, n, 'json');
      },
      getScript: function(e, n) {
        return x.get(e, t, n, 'script');
      },
    }),
    x.each(['get', 'post'], function(e, n) {
      x[n] = function(e, r, i, o) {
        return (
          x.isFunction(r) && ((o = o || i), (i = r), (r = t)),
          x.ajax({ url: e, type: n, dataType: o, data: r, success: i })
        );
      };
    });
  function Mn(e, n, r) {
    var i,
      o,
      a,
      s,
      l = e.contents,
      u = e.dataTypes;
    while ('*' === u[0]) u.shift(), o === t && (o = e.mimeType || n.getResponseHeader('Content-Type'));
    if (o)
      for (s in l)
        if (l[s] && l[s].test(o)) {
          u.unshift(s);
          break;
        }
    if (u[0] in r) a = u[0];
    else {
      for (s in r) {
        if (!u[0] || e.converters[s + ' ' + u[0]]) {
          a = s;
          break;
        }
        i || (i = s);
      }
      a = a || i;
    }
    return a ? (a !== u[0] && u.unshift(a), r[a]) : t;
  }
  function On(e, t, n, r) {
    var i,
      o,
      a,
      s,
      l,
      u = {},
      c = e.dataTypes.slice();
    if (c[1]) for (a in e.converters) u[a.toLowerCase()] = e.converters[a];
    o = c.shift();
    while (o)
      if (
        (e.responseFields[o] && (n[e.responseFields[o]] = t),
        !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)),
        (l = o),
        (o = c.shift()))
      )
        if ('*' === o) o = l;
        else if ('*' !== l && l !== o) {
          if (((a = u[l + ' ' + o] || u['* ' + o]), !a))
            for (i in u)
              if (((s = i.split(' ')), s[1] === o && (a = u[l + ' ' + s[0]] || u['* ' + s[0]]))) {
                a === !0 ? (a = u[i]) : u[i] !== !0 && ((o = s[0]), c.unshift(s[1]));
                break;
              }
          if (a !== !0)
            if (a && e['throws']) t = a(t);
            else
              try {
                t = a(t);
              } catch (p) {
                return { state: 'parsererror', error: a ? p : 'No conversion from ' + l + ' to ' + o };
              }
        }
    return { state: 'success', data: t };
  }
  x.ajaxSetup({
    accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
    contents: { script: /(?:java|ecma)script/ },
    converters: {
      'text script': function(e) {
        return x.globalEval(e), e;
      },
    },
  }),
    x.ajaxPrefilter('script', function(e) {
      e.cache === t && (e.cache = !1), e.crossDomain && ((e.type = 'GET'), (e.global = !1));
    }),
    x.ajaxTransport('script', function(e) {
      if (e.crossDomain) {
        var n,
          r = a.head || x('head')[0] || a.documentElement;
        return {
          send: function(t, i) {
            (n = a.createElement('script')),
              (n.async = !0),
              e.scriptCharset && (n.charset = e.scriptCharset),
              (n.src = e.url),
              (n.onload = n.onreadystatechange = function(e, t) {
                (t || !n.readyState || /loaded|complete/.test(n.readyState)) &&
                  ((n.onload = n.onreadystatechange = null),
                  n.parentNode && n.parentNode.removeChild(n),
                  (n = null),
                  t || i(200, 'success'));
              }),
              r.insertBefore(n, r.firstChild);
          },
          abort: function() {
            n && n.onload(t, !0);
          },
        };
      }
    });
  var Fn = [],
    Bn = /(=)\?(?=&|$)|\?\?/;
  x.ajaxSetup({
    jsonp: 'callback',
    jsonpCallback: function() {
      var e = Fn.pop() || x.expando + '_' + vn++;
      return (this[e] = !0), e;
    },
  }),
    x.ajaxPrefilter('json jsonp', function(n, r, i) {
      var o,
        a,
        s,
        l =
          n.jsonp !== !1 &&
          (Bn.test(n.url)
            ? 'url'
            : 'string' == typeof n.data &&
              !(n.contentType || '').indexOf('application/x-www-form-urlencoded') &&
              Bn.test(n.data) &&
              'data');
      return l || 'jsonp' === n.dataTypes[0]
        ? ((o = n.jsonpCallback = x.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback),
          l
            ? (n[l] = n[l].replace(Bn, '$1' + o))
            : n.jsonp !== !1 && (n.url += (bn.test(n.url) ? '&' : '?') + n.jsonp + '=' + o),
          (n.converters['script json'] = function() {
            return s || x.error(o + ' was not called'), s[0];
          }),
          (n.dataTypes[0] = 'json'),
          (a = e[o]),
          (e[o] = function() {
            s = arguments;
          }),
          i.always(function() {
            (e[o] = a),
              n[o] && ((n.jsonpCallback = r.jsonpCallback), Fn.push(o)),
              s && x.isFunction(a) && a(s[0]),
              (s = a = t);
          }),
          'script')
        : t;
    });
  var Pn,
    Rn,
    Wn = 0,
    $n =
      e.ActiveXObject &&
      function() {
        var e;
        for (e in Pn) Pn[e](t, !0);
      };
  function In() {
    try {
      return new e.XMLHttpRequest();
    } catch (t) {}
  }
  function zn() {
    try {
      return new e.ActiveXObject('Microsoft.XMLHTTP');
    } catch (t) {}
  }
  (x.ajaxSettings.xhr = e.ActiveXObject
    ? function() {
        return (!this.isLocal && In()) || zn();
      }
    : In),
    (Rn = x.ajaxSettings.xhr()),
    (x.support.cors = !!Rn && 'withCredentials' in Rn),
    (Rn = x.support.ajax = !!Rn),
    Rn &&
      x.ajaxTransport(function(n) {
        if (!n.crossDomain || x.support.cors) {
          var r;
          return {
            send: function(i, o) {
              var a,
                s,
                l = n.xhr();
              if (
                (n.username ? l.open(n.type, n.url, n.async, n.username, n.password) : l.open(n.type, n.url, n.async),
                n.xhrFields)
              )
                for (s in n.xhrFields) l[s] = n.xhrFields[s];
              n.mimeType && l.overrideMimeType && l.overrideMimeType(n.mimeType),
                n.crossDomain || i['X-Requested-With'] || (i['X-Requested-With'] = 'XMLHttpRequest');
              try {
                for (s in i) l.setRequestHeader(s, i[s]);
              } catch (u) {}
              l.send((n.hasContent && n.data) || null),
                (r = function(e, i) {
                  var s, u, c, p;
                  try {
                    if (r && (i || 4 === l.readyState))
                      if (((r = t), a && ((l.onreadystatechange = x.noop), $n && delete Pn[a]), i))
                        4 !== l.readyState && l.abort();
                      else {
                        (p = {}),
                          (s = l.status),
                          (u = l.getAllResponseHeaders()),
                          'string' == typeof l.responseText && (p.text = l.responseText);
                        try {
                          c = l.statusText;
                        } catch (f) {
                          c = '';
                        }
                        s || !n.isLocal || n.crossDomain ? 1223 === s && (s = 204) : (s = p.text ? 200 : 404);
                      }
                  } catch (d) {
                    i || o(-1, d);
                  }
                  p && o(s, c, p, u);
                }),
                n.async
                  ? 4 === l.readyState
                    ? setTimeout(r)
                    : ((a = ++Wn), $n && (Pn || ((Pn = {}), x(e).unload($n)), (Pn[a] = r)), (l.onreadystatechange = r))
                  : r();
            },
            abort: function() {
              r && r(t, !0);
            },
          };
        }
      });
  var Xn,
    Un,
    Vn = /^(?:toggle|show|hide)$/,
    Yn = RegExp('^(?:([+-])=|)(' + w + ')([a-z%]*)$', 'i'),
    Jn = /queueHooks$/,
    Gn = [nr],
    Qn = {
      '*': [
        function(e, t) {
          var n = this.createTween(e, t),
            r = n.cur(),
            i = Yn.exec(t),
            o = (i && i[3]) || (x.cssNumber[e] ? '' : 'px'),
            a = (x.cssNumber[e] || ('px' !== o && +r)) && Yn.exec(x.css(n.elem, e)),
            s = 1,
            l = 20;
          if (a && a[3] !== o) {
            (o = o || a[3]), (i = i || []), (a = +r || 1);
            do (s = s || '.5'), (a /= s), x.style(n.elem, e, a + o);
            while (s !== (s = n.cur() / r) && 1 !== s && --l);
          }
          return i && ((a = n.start = +a || +r || 0), (n.unit = o), (n.end = i[1] ? a + (i[1] + 1) * i[2] : +i[2])), n;
        },
      ],
    };
  function Kn() {
    return (
      setTimeout(function() {
        Xn = t;
      }),
      (Xn = x.now())
    );
  }
  function Zn(e, t, n) {
    var r,
      i = (Qn[t] || []).concat(Qn['*']),
      o = 0,
      a = i.length;
    for (; a > o; o++) if ((r = i[o].call(n, t, e))) return r;
  }
  function er(e, t, n) {
    var r,
      i,
      o = 0,
      a = Gn.length,
      s = x.Deferred().always(function() {
        delete l.elem;
      }),
      l = function() {
        if (i) return !1;
        var t = Xn || Kn(),
          n = Math.max(0, u.startTime + u.duration - t),
          r = n / u.duration || 0,
          o = 1 - r,
          a = 0,
          l = u.tweens.length;
        for (; l > a; a++) u.tweens[a].run(o);
        return s.notifyWith(e, [u, o, n]), 1 > o && l ? n : (s.resolveWith(e, [u]), !1);
      },
      u = s.promise({
        elem: e,
        props: x.extend({}, t),
        opts: x.extend(!0, { specialEasing: {} }, n),
        originalProperties: t,
        originalOptions: n,
        startTime: Xn || Kn(),
        duration: n.duration,
        tweens: [],
        createTween: function(t, n) {
          var r = x.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);
          return u.tweens.push(r), r;
        },
        stop: function(t) {
          var n = 0,
            r = t ? u.tweens.length : 0;
          if (i) return this;
          for (i = !0; r > n; n++) u.tweens[n].run(1);
          return t ? s.resolveWith(e, [u, t]) : s.rejectWith(e, [u, t]), this;
        },
      }),
      c = u.props;
    for (tr(c, u.opts.specialEasing); a > o; o++) if ((r = Gn[o].call(u, e, c, u.opts))) return r;
    return (
      x.map(c, Zn, u),
      x.isFunction(u.opts.start) && u.opts.start.call(e, u),
      x.fx.timer(x.extend(l, { elem: e, anim: u, queue: u.opts.queue })),
      u
        .progress(u.opts.progress)
        .done(u.opts.done, u.opts.complete)
        .fail(u.opts.fail)
        .always(u.opts.always)
    );
  }
  function tr(e, t) {
    var n, r, i, o, a;
    for (n in e)
      if (
        ((r = x.camelCase(n)),
        (i = t[r]),
        (o = e[n]),
        x.isArray(o) && ((i = o[1]), (o = e[n] = o[0])),
        n !== r && ((e[r] = o), delete e[n]),
        (a = x.cssHooks[r]),
        a && 'expand' in a)
      ) {
        (o = a.expand(o)), delete e[r];
        for (n in o) n in e || ((e[n] = o[n]), (t[n] = i));
      } else t[r] = i;
  }
  x.Animation = x.extend(er, {
    tweener: function(e, t) {
      x.isFunction(e) ? ((t = e), (e = ['*'])) : (e = e.split(' '));
      var n,
        r = 0,
        i = e.length;
      for (; i > r; r++) (n = e[r]), (Qn[n] = Qn[n] || []), Qn[n].unshift(t);
    },
    prefilter: function(e, t) {
      t ? Gn.unshift(e) : Gn.push(e);
    },
  });
  function nr(e, t, n) {
    var r,
      i,
      o,
      a,
      s,
      l,
      u = this,
      c = {},
      p = e.style,
      f = e.nodeType && nn(e),
      d = x._data(e, 'fxshow');
    n.queue ||
      ((s = x._queueHooks(e, 'fx')),
      null == s.unqueued &&
        ((s.unqueued = 0),
        (l = s.empty.fire),
        (s.empty.fire = function() {
          s.unqueued || l();
        })),
      s.unqueued++,
      u.always(function() {
        u.always(function() {
          s.unqueued--, x.queue(e, 'fx').length || s.empty.fire();
        });
      })),
      1 === e.nodeType &&
        ('height' in t || 'width' in t) &&
        ((n.overflow = [p.overflow, p.overflowX, p.overflowY]),
        'inline' === x.css(e, 'display') &&
          'none' === x.css(e, 'float') &&
          (x.support.inlineBlockNeedsLayout && 'inline' !== ln(e.nodeName)
            ? (p.zoom = 1)
            : (p.display = 'inline-block'))),
      n.overflow &&
        ((p.overflow = 'hidden'),
        x.support.shrinkWrapBlocks ||
          u.always(function() {
            (p.overflow = n.overflow[0]), (p.overflowX = n.overflow[1]), (p.overflowY = n.overflow[2]);
          }));
    for (r in t)
      if (((i = t[r]), Vn.exec(i))) {
        if ((delete t[r], (o = o || 'toggle' === i), i === (f ? 'hide' : 'show'))) continue;
        c[r] = (d && d[r]) || x.style(e, r);
      }
    if (!x.isEmptyObject(c)) {
      d ? 'hidden' in d && (f = d.hidden) : (d = x._data(e, 'fxshow', {})),
        o && (d.hidden = !f),
        f
          ? x(e).show()
          : u.done(function() {
              x(e).hide();
            }),
        u.done(function() {
          var t;
          x._removeData(e, 'fxshow');
          for (t in c) x.style(e, t, c[t]);
        });
      for (r in c)
        (a = Zn(f ? d[r] : 0, r, u)),
          r in d || ((d[r] = a.start), f && ((a.end = a.start), (a.start = 'width' === r || 'height' === r ? 1 : 0)));
    }
  }
  function rr(e, t, n, r, i) {
    return new rr.prototype.init(e, t, n, r, i);
  }
  (x.Tween = rr),
    (rr.prototype = {
      constructor: rr,
      init: function(e, t, n, r, i, o) {
        (this.elem = e),
          (this.prop = n),
          (this.easing = i || 'swing'),
          (this.options = t),
          (this.start = this.now = this.cur()),
          (this.end = r),
          (this.unit = o || (x.cssNumber[n] ? '' : 'px'));
      },
      cur: function() {
        var e = rr.propHooks[this.prop];
        return e && e.get ? e.get(this) : rr.propHooks._default.get(this);
      },
      run: function(e) {
        var t,
          n = rr.propHooks[this.prop];
        return (
          (this.pos = t = this.options.duration
            ? x.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration)
            : e),
          (this.now = (this.end - this.start) * t + this.start),
          this.options.step && this.options.step.call(this.elem, this.now, this),
          n && n.set ? n.set(this) : rr.propHooks._default.set(this),
          this
        );
      },
    }),
    (rr.prototype.init.prototype = rr.prototype),
    (rr.propHooks = {
      _default: {
        get: function(e) {
          var t;
          return null == e.elem[e.prop] || (e.elem.style && null != e.elem.style[e.prop])
            ? ((t = x.css(e.elem, e.prop, '')), t && 'auto' !== t ? t : 0)
            : e.elem[e.prop];
        },
        set: function(e) {
          x.fx.step[e.prop]
            ? x.fx.step[e.prop](e)
            : e.elem.style && (null != e.elem.style[x.cssProps[e.prop]] || x.cssHooks[e.prop])
            ? x.style(e.elem, e.prop, e.now + e.unit)
            : (e.elem[e.prop] = e.now);
        },
      },
    }),
    (rr.propHooks.scrollTop = rr.propHooks.scrollLeft = {
      set: function(e) {
        e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
      },
    }),
    x.each(['toggle', 'show', 'hide'], function(e, t) {
      var n = x.fn[t];
      x.fn[t] = function(e, r, i) {
        return null == e || 'boolean' == typeof e ? n.apply(this, arguments) : this.animate(ir(t, !0), e, r, i);
      };
    }),
    x.fn.extend({
      fadeTo: function(e, t, n, r) {
        return this.filter(nn)
          .css('opacity', 0)
          .show()
          .end()
          .animate({ opacity: t }, e, n, r);
      },
      animate: function(e, t, n, r) {
        var i = x.isEmptyObject(e),
          o = x.speed(t, n, r),
          a = function() {
            var t = er(this, x.extend({}, e), o);
            (i || x._data(this, 'finish')) && t.stop(!0);
          };
        return (a.finish = a), i || o.queue === !1 ? this.each(a) : this.queue(o.queue, a);
      },
      stop: function(e, n, r) {
        var i = function(e) {
          var t = e.stop;
          delete e.stop, t(r);
        };
        return (
          'string' != typeof e && ((r = n), (n = e), (e = t)),
          n && e !== !1 && this.queue(e || 'fx', []),
          this.each(function() {
            var t = !0,
              n = null != e && e + 'queueHooks',
              o = x.timers,
              a = x._data(this);
            if (n) a[n] && a[n].stop && i(a[n]);
            else for (n in a) a[n] && a[n].stop && Jn.test(n) && i(a[n]);
            for (n = o.length; n--; )
              o[n].elem !== this || (null != e && o[n].queue !== e) || (o[n].anim.stop(r), (t = !1), o.splice(n, 1));
            (t || !r) && x.dequeue(this, e);
          })
        );
      },
      finish: function(e) {
        return (
          e !== !1 && (e = e || 'fx'),
          this.each(function() {
            var t,
              n = x._data(this),
              r = n[e + 'queue'],
              i = n[e + 'queueHooks'],
              o = x.timers,
              a = r ? r.length : 0;
            for (n.finish = !0, x.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--; )
              o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
            for (t = 0; a > t; t++) r[t] && r[t].finish && r[t].finish.call(this);
            delete n.finish;
          })
        );
      },
    });
  function ir(e, t) {
    var n,
      r = { height: e },
      i = 0;
    for (t = t ? 1 : 0; 4 > i; i += 2 - t) (n = Zt[i]), (r['margin' + n] = r['padding' + n] = e);
    return t && (r.opacity = r.width = e), r;
  }
  x.each(
    {
      slideDown: ir('show'),
      slideUp: ir('hide'),
      slideToggle: ir('toggle'),
      fadeIn: { opacity: 'show' },
      fadeOut: { opacity: 'hide' },
      fadeToggle: { opacity: 'toggle' },
    },
    function(e, t) {
      x.fn[e] = function(e, n, r) {
        return this.animate(t, e, n, r);
      };
    }
  ),
    (x.speed = function(e, t, n) {
      var r =
        e && 'object' == typeof e
          ? x.extend({}, e)
          : {
              complete: n || (!n && t) || (x.isFunction(e) && e),
              duration: e,
              easing: (n && t) || (t && !x.isFunction(t) && t),
            };
      return (
        (r.duration = x.fx.off
          ? 0
          : 'number' == typeof r.duration
          ? r.duration
          : r.duration in x.fx.speeds
          ? x.fx.speeds[r.duration]
          : x.fx.speeds._default),
        (null == r.queue || r.queue === !0) && (r.queue = 'fx'),
        (r.old = r.complete),
        (r.complete = function() {
          x.isFunction(r.old) && r.old.call(this), r.queue && x.dequeue(this, r.queue);
        }),
        r
      );
    }),
    (x.easing = {
      linear: function(e) {
        return e;
      },
      swing: function(e) {
        return 0.5 - Math.cos(e * Math.PI) / 2;
      },
    }),
    (x.timers = []),
    (x.fx = rr.prototype.init),
    (x.fx.tick = function() {
      var e,
        n = x.timers,
        r = 0;
      for (Xn = x.now(); n.length > r; r++) (e = n[r]), e() || n[r] !== e || n.splice(r--, 1);
      n.length || x.fx.stop(), (Xn = t);
    }),
    (x.fx.timer = function(e) {
      e() && x.timers.push(e) && x.fx.start();
    }),
    (x.fx.interval = 13),
    (x.fx.start = function() {
      Un || (Un = setInterval(x.fx.tick, x.fx.interval));
    }),
    (x.fx.stop = function() {
      clearInterval(Un), (Un = null);
    }),
    (x.fx.speeds = { slow: 600, fast: 200, _default: 400 }),
    (x.fx.step = {}),
    x.expr &&
      x.expr.filters &&
      (x.expr.filters.animated = function(e) {
        return x.grep(x.timers, function(t) {
          return e === t.elem;
        }).length;
      }),
    (x.fn.offset = function(e) {
      if (arguments.length)
        return e === t
          ? this
          : this.each(function(t) {
              x.offset.setOffset(this, e, t);
            });
      var n,
        r,
        o = { top: 0, left: 0 },
        a = this[0],
        s = a && a.ownerDocument;
      if (s)
        return (
          (n = s.documentElement),
          x.contains(n, a)
            ? (typeof a.getBoundingClientRect !== i && (o = a.getBoundingClientRect()),
              (r = or(s)),
              {
                top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0),
                left: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0),
              })
            : o
        );
    }),
    (x.offset = {
      setOffset: function(e, t, n) {
        var r = x.css(e, 'position');
        'static' === r && (e.style.position = 'relative');
        var i = x(e),
          o = i.offset(),
          a = x.css(e, 'top'),
          s = x.css(e, 'left'),
          l = ('absolute' === r || 'fixed' === r) && x.inArray('auto', [a, s]) > -1,
          u = {},
          c = {},
          p,
          f;
        l ? ((c = i.position()), (p = c.top), (f = c.left)) : ((p = parseFloat(a) || 0), (f = parseFloat(s) || 0)),
          x.isFunction(t) && (t = t.call(e, n, o)),
          null != t.top && (u.top = t.top - o.top + p),
          null != t.left && (u.left = t.left - o.left + f),
          'using' in t ? t.using.call(e, u) : i.css(u);
      },
    }),
    x.fn.extend({
      position: function() {
        if (this[0]) {
          var e,
            t,
            n = { top: 0, left: 0 },
            r = this[0];
          return (
            'fixed' === x.css(r, 'position')
              ? (t = r.getBoundingClientRect())
              : ((e = this.offsetParent()),
                (t = this.offset()),
                x.nodeName(e[0], 'html') || (n = e.offset()),
                (n.top += x.css(e[0], 'borderTopWidth', !0)),
                (n.left += x.css(e[0], 'borderLeftWidth', !0))),
            { top: t.top - n.top - x.css(r, 'marginTop', !0), left: t.left - n.left - x.css(r, 'marginLeft', !0) }
          );
        }
      },
      offsetParent: function() {
        return this.map(function() {
          var e = this.offsetParent || s;
          while (e && !x.nodeName(e, 'html') && 'static' === x.css(e, 'position')) e = e.offsetParent;
          return e || s;
        });
      },
    }),
    x.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, function(e, n) {
      var r = /Y/.test(n);
      x.fn[e] = function(i) {
        return x.access(
          this,
          function(e, i, o) {
            var a = or(e);
            return o === t
              ? a
                ? n in a
                  ? a[n]
                  : a.document.documentElement[i]
                : e[i]
              : (a ? a.scrollTo(r ? x(a).scrollLeft() : o, r ? o : x(a).scrollTop()) : (e[i] = o), t);
          },
          e,
          i,
          arguments.length,
          null
        );
      };
    });
  function or(e) {
    return x.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1;
  }
  x.each({ Height: 'height', Width: 'width' }, function(e, n) {
    x.each({ padding: 'inner' + e, content: n, '': 'outer' + e }, function(r, i) {
      x.fn[i] = function(i, o) {
        var a = arguments.length && (r || 'boolean' != typeof i),
          s = r || (i === !0 || o === !0 ? 'margin' : 'border');
        return x.access(
          this,
          function(n, r, i) {
            var o;
            return x.isWindow(n)
              ? n.document.documentElement['client' + e]
              : 9 === n.nodeType
              ? ((o = n.documentElement),
                Math.max(n.body['scroll' + e], o['scroll' + e], n.body['offset' + e], o['offset' + e], o['client' + e]))
              : i === t
              ? x.css(n, r, s)
              : x.style(n, r, i, s);
          },
          n,
          a ? i : t,
          a,
          null
        );
      };
    });
  }),
    (x.fn.size = function() {
      return this.length;
    }),
    (x.fn.andSelf = x.fn.addBack),
    'object' == typeof module && module && 'object' == typeof module.exports
      ? (module.exports = x)
      : ((e.jQuery = e.$ = x),
        'function' == typeof define &&
          define.amd &&
          define('jquery', [], function() {
            return x;
          }));
})(window);

/*! jQuery UI - v1.10.3 - 2013-05-03
 * http://jqueryui.com
 * Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
 * Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */
(function($, undefined) {
  var uuid = 0,
    runiqueId = /^ui-id-\d+$/;

  // $.ui might exist from components with no dependencies, e.g., $.ui.position
  $.ui = $.ui || {};

  $.extend($.ui, {
    version: '1.10.3',

    keyCode: {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      NUMPAD_ADD: 107,
      NUMPAD_DECIMAL: 110,
      NUMPAD_DIVIDE: 111,
      NUMPAD_ENTER: 108,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_SUBTRACT: 109,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38,
    },
  });

  // plugins
  $.fn.extend({
    focus: (function(orig) {
      return function(delay, fn) {
        return typeof delay === 'number'
          ? this.each(function() {
              var elem = this;
              setTimeout(function() {
                $(elem).focus();
                if (fn) {
                  fn.call(elem);
                }
              }, delay);
            })
          : orig.apply(this, arguments);
      };
    })($.fn.focus),

    scrollParent: function() {
      var scrollParent;
      if (($.ui.ie && /(static|relative)/.test(this.css('position'))) || /absolute/.test(this.css('position'))) {
        scrollParent = this.parents()
          .filter(function() {
            return (
              /(relative|absolute|fixed)/.test($.css(this, 'position')) &&
              /(auto|scroll)/.test($.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x'))
            );
          })
          .eq(0);
      } else {
        scrollParent = this.parents()
          .filter(function() {
            return /(auto|scroll)/.test(
              $.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x')
            );
          })
          .eq(0);
      }

      return /fixed/.test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
    },

    zIndex: function(zIndex) {
      if (zIndex !== undefined) {
        return this.css('zIndex', zIndex);
      }

      if (this.length) {
        var elem = $(this[0]),
          position,
          value;
        while (elem.length && elem[0] !== document) {
          // Ignore z-index if position is set to a value where z-index is ignored by the browser
          // This makes behavior of this function consistent across browsers
          // WebKit always returns auto if the element is positioned
          position = elem.css('position');
          if (position === 'absolute' || position === 'relative' || position === 'fixed') {
            // IE returns 0 when zIndex is not specified
            // other browsers return a string
            // we ignore the case of nested elements with an explicit value of 0
            // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
            value = parseInt(elem.css('zIndex'), 10);
            if (!isNaN(value) && value !== 0) {
              return value;
            }
          }
          elem = elem.parent();
        }
      }

      return 0;
    },

    uniqueId: function() {
      return this.each(function() {
        if (!this.id) {
          this.id = 'ui-id-' + ++uuid;
        }
      });
    },

    removeUniqueId: function() {
      return this.each(function() {
        if (runiqueId.test(this.id)) {
          $(this).removeAttr('id');
        }
      });
    },
  });

  // selectors
  function focusable(element, isTabIndexNotNaN) {
    var map,
      mapName,
      img,
      nodeName = element.nodeName.toLowerCase();
    if ('area' === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }
      img = $('img[usemap=#' + mapName + ']')[0];
      return !!img && visible(img);
    }
    return (
      (/input|select|textarea|button|object/.test(nodeName)
        ? !element.disabled
        : 'a' === nodeName
        ? element.href || isTabIndexNotNaN
        : isTabIndexNotNaN) &&
      // the element and all of its ancestors must be visible
      visible(element)
    );
  }

  function visible(element) {
    return (
      $.expr.filters.visible(element) &&
      !$(element)
        .parents()
        .addBack()
        .filter(function() {
          return $.css(this, 'visibility') === 'hidden';
        }).length
    );
  }

  $.extend($.expr[':'], {
    data: $.expr.createPseudo
      ? $.expr.createPseudo(function(dataName) {
          return function(elem) {
            return !!$.data(elem, dataName);
          };
        })
      : // support: jQuery <1.8
        function(elem, i, match) {
          return !!$.data(elem, match[3]);
        },

    focusable: function(element) {
      return focusable(element, !isNaN($.attr(element, 'tabindex')));
    },

    tabbable: function(element) {
      var tabIndex = $.attr(element, 'tabindex'),
        isTabIndexNaN = isNaN(tabIndex);
      return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
    },
  });

  // support: jQuery <1.8
  if (!$('<a>').outerWidth(1).jquery) {
    $.each(['Width', 'Height'], function(i, name) {
      var side = name === 'Width' ? ['Left', 'Right'] : ['Top', 'Bottom'],
        type = name.toLowerCase(),
        orig = {
          innerWidth: $.fn.innerWidth,
          innerHeight: $.fn.innerHeight,
          outerWidth: $.fn.outerWidth,
          outerHeight: $.fn.outerHeight,
        };

      function reduce(elem, size, border, margin) {
        $.each(side, function() {
          size -= parseFloat($.css(elem, 'padding' + this)) || 0;
          if (border) {
            size -= parseFloat($.css(elem, 'border' + this + 'Width')) || 0;
          }
          if (margin) {
            size -= parseFloat($.css(elem, 'margin' + this)) || 0;
          }
        });
        return size;
      }

      $.fn['inner' + name] = function(size) {
        if (size === undefined) {
          return orig['inner' + name].call(this);
        }

        return this.each(function() {
          $(this).css(type, reduce(this, size) + 'px');
        });
      };

      $.fn['outer' + name] = function(size, margin) {
        if (typeof size !== 'number') {
          return orig['outer' + name].call(this, size);
        }

        return this.each(function() {
          $(this).css(type, reduce(this, size, true, margin) + 'px');
        });
      };
    });
  }

  // support: jQuery <1.8
  if (!$.fn.addBack) {
    $.fn.addBack = function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    };
  }

  // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
  if (
    $('<a>')
      .data('a-b', 'a')
      .removeData('a-b')
      .data('a-b')
  ) {
    $.fn.removeData = (function(removeData) {
      return function(key) {
        if (arguments.length) {
          return removeData.call(this, $.camelCase(key));
        } else {
          return removeData.call(this);
        }
      };
    })($.fn.removeData);
  }

  // deprecated
  $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

  $.support.selectstart = 'onselectstart' in document.createElement('div');
  $.fn.extend({
    disableSelection: function() {
      return this.bind(($.support.selectstart ? 'selectstart' : 'mousedown') + '.ui-disableSelection', function(event) {
        event.preventDefault();
      });
    },

    enableSelection: function() {
      return this.unbind('.ui-disableSelection');
    },
  });

  $.extend($.ui, {
    // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    plugin: {
      add: function(module, option, set) {
        var i,
          proto = $.ui[module].prototype;
        for (i in set) {
          proto.plugins[i] = proto.plugins[i] || [];
          proto.plugins[i].push([option, set[i]]);
        }
      },
      call: function(instance, name, args) {
        var i,
          set = instance.plugins[name];
        if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
          return;
        }

        for (i = 0; i < set.length; i++) {
          if (instance.options[set[i][0]]) {
            set[i][1].apply(instance.element, args);
          }
        }
      },
    },

    // only used by resizable
    hasScroll: function(el, a) {
      //If overflow is hidden, the element might have extra content, but the user wants to hide it
      if ($(el).css('overflow') === 'hidden') {
        return false;
      }

      var scroll = a && a === 'left' ? 'scrollLeft' : 'scrollTop',
        has = false;

      if (el[scroll] > 0) {
        return true;
      }

      // TODO: determine which cases actually cause this to happen
      // if the element doesn't have the scroll set, see if it's possible to
      // set the scroll
      el[scroll] = 1;
      has = el[scroll] > 0;
      el[scroll] = 0;
      return has;
    },
  });
})(jQuery);

(function($, undefined) {
  var uuid = 0,
    slice = Array.prototype.slice,
    _cleanData = $.cleanData;
  $.cleanData = function(elems) {
    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
      try {
        $(elem).triggerHandler('remove');
        // http://bugs.jquery.com/ticket/8235
      } catch (e) {}
    }
    _cleanData(elems);
  };

  $.widget = function(name, base, prototype) {
    var fullName,
      existingConstructor,
      constructor,
      basePrototype,
      // proxiedPrototype allows the provided prototype to remain unmodified
      // so that it can be used as a mixin for multiple widgets (#8876)
      proxiedPrototype = {},
      namespace = name.split('.')[0];

    name = name.split('.')[1];
    fullName = namespace + '-' + name;

    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }

    // create selector for plugin
    $.expr[':'][fullName.toLowerCase()] = function(elem) {
      return !!$.data(elem, fullName);
    };

    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function(options, element) {
      // allow instantiation without "new" keyword
      if (!this._createWidget) {
        return new constructor(options, element);
      }

      // allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };
    // extend with the existing constructor to carry over any static properties
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      // copy the object used to create the prototype in case we need to
      // redefine the widget later
      _proto: $.extend({}, prototype),
      // track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: [],
    });

    basePrototype = new base();
    // we need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function(prop, value) {
      if (!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = (function() {
        var _super = function() {
            return base.prototype[prop].apply(this, arguments);
          },
          _superApply = function(args) {
            return base.prototype[prop].apply(this, args);
          };
        return function() {
          var __super = this._super,
            __superApply = this._superApply,
            returnValue;

          this._super = _super;
          this._superApply = _superApply;

          returnValue = value.apply(this, arguments);

          this._super = __super;
          this._superApply = __superApply;

          return returnValue;
        };
      })();
    });
    constructor.prototype = $.widget.extend(
      basePrototype,
      {
        // TODO: remove support for widgetEventPrefix
        // always use the name + a colon as the prefix, e.g., draggable:start
        // don't prefix for widgets that aren't DOM-based
        widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name,
      },
      proxiedPrototype,
      {
        constructor: constructor,
        namespace: namespace,
        widgetName: name,
        widgetFullName: fullName,
      }
    );

    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function(i, child) {
        var childPrototype = child.prototype;

        // redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(childPrototype.namespace + '.' + childPrototype.widgetName, constructor, child._proto);
      });
      // remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }

    $.widget.bridge(name, constructor);
  };

  $.widget.extend = function(target) {
    var input = slice.call(arguments, 1),
      inputIndex = 0,
      inputLength = input.length,
      key,
      value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
          // Clone objects
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key])
              ? $.widget.extend({}, target[key], value)
              : // Don't extend strings, arrays, etc. with objects
                $.widget.extend({}, value);
            // Copy everything else by reference
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };

  $.widget.bridge = function(name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function(options) {
      var isMethodCall = typeof options === 'string',
        args = slice.call(arguments, 1),
        returnValue = this;

      // allow multiple hashes to be passed on init
      options = !isMethodCall && args.length ? $.widget.extend.apply(null, [options].concat(args)) : options;

      if (isMethodCall) {
        this.each(function() {
          var methodValue,
            instance = $.data(this, fullName);
          if (!instance) {
            return $.error(
              'cannot call methods on ' +
                name +
                ' prior to initialization; ' +
                "attempted to call method '" +
                options +
                "'"
            );
          }
          if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
            return $.error("no such method '" + options + "' for " + name + ' widget instance');
          }
          methodValue = instance[options].apply(instance, args);
          if (methodValue !== instance && methodValue !== undefined) {
            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
            return false;
          }
        });
      } else {
        this.each(function() {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {})._init();
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }

      return returnValue;
    };
  };

  $.Widget = function(/* options, element */) {};
  $.Widget._childConstructors = [];

  $.Widget.prototype = {
    widgetName: 'widget',
    widgetEventPrefix: '',
    defaultElement: '<div>',
    options: {
      disabled: false,

      // callbacks
      create: null,
    },
    _createWidget: function(options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = uuid++;
      this.eventNamespace = '.' + this.widgetName + this.uuid;
      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);

      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();

      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function(event) {
            if (event.target === element) {
              this.destroy();
            }
          },
        });
        this.document = $(
          element.style
            ? // element within the document
              element.ownerDocument
            : // element is window or document
              element.document || element
        );
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }

      this._create();
      this._trigger('create', null, this._getCreateEventData());
      this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,

    destroy: function() {
      this._destroy();
      // we can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element
        .unbind(this.eventNamespace)
        // 1.9 BC for #7810
        // TODO remove dual storage
        .removeData(this.widgetName)
        .removeData(this.widgetFullName)
        // support: jquery <1.6.3
        // http://bugs.jquery.com/ticket/9413
        .removeData($.camelCase(this.widgetFullName));
      this.widget()
        .unbind(this.eventNamespace)
        .removeAttr('aria-disabled')
        .removeClass(this.widgetFullName + '-disabled ' + 'ui-state-disabled');

      // clean up events and states
      this.bindings.unbind(this.eventNamespace);
      this.hoverable.removeClass('ui-state-hover');
      this.focusable.removeClass('ui-state-focus');
    },
    _destroy: $.noop,

    widget: function() {
      return this.element;
    },

    option: function(key, value) {
      var options = key,
        parts,
        curOption,
        i;

      if (arguments.length === 0) {
        // don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }

      if (typeof key === 'string') {
        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split('.');
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (value === undefined) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (value === undefined) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }

      this._setOptions(options);

      return this;
    },
    _setOptions: function(options) {
      var key;

      for (key in options) {
        this._setOption(key, options[key]);
      }

      return this;
    },
    _setOption: function(key, value) {
      this.options[key] = value;

      if (key === 'disabled') {
        this.widget()
          .toggleClass(this.widgetFullName + '-disabled ui-state-disabled', !!value)
          .attr('aria-disabled', value);
        this.hoverable.removeClass('ui-state-hover');
        this.focusable.removeClass('ui-state-focus');
      }

      return this;
    },

    enable: function() {
      return this._setOption('disabled', false);
    },
    disable: function() {
      return this._setOption('disabled', true);
    },

    _on: function(suppressDisabledCheck, element, handlers) {
      var delegateElement,
        instance = this;

      // no suppressDisabledCheck flag, shuffle arguments
      if (typeof suppressDisabledCheck !== 'boolean') {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }

      // no element argument, shuffle and use this.element
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        // accept selectors, DOM elements
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }

      $.each(handlers, function(event, handler) {
        function handlerProxy() {
          // allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass('ui-state-disabled'))) {
            return;
          }
          return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
        }

        // copy the guid so direct unbinding works
        if (typeof handler !== 'string') {
          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
        }

        var match = event.match(/^(\w+)\s*(.*)$/),
          eventName = match[1] + instance.eventNamespace,
          selector = match[2];
        if (selector) {
          delegateElement.delegate(selector, eventName, handlerProxy);
        } else {
          element.bind(eventName, handlerProxy);
        }
      });
    },

    _off: function(element, eventName) {
      eventName = (eventName || '').split(' ').join(this.eventNamespace + ' ') + this.eventNamespace;
      element.unbind(eventName).undelegate(eventName);
    },

    _delay: function(handler, delay) {
      function handlerProxy() {
        return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },

    _hoverable: function(element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function(event) {
          $(event.currentTarget).addClass('ui-state-hover');
        },
        mouseleave: function(event) {
          $(event.currentTarget).removeClass('ui-state-hover');
        },
      });
    },

    _focusable: function(element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function(event) {
          $(event.currentTarget).addClass('ui-state-focus');
        },
        focusout: function(event) {
          $(event.currentTarget).removeClass('ui-state-focus');
        },
      });
    },

    _trigger: function(type, event, data) {
      var prop,
        orig,
        callback = this.options[type];

      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
      // the original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[0];

      // copy original event properties over to the new event
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }

      this.element.trigger(event, data);
      return !(
        ($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false) ||
        event.isDefaultPrevented()
      );
    },
  };

  $.each({ show: 'fadeIn', hide: 'fadeOut' }, function(method, defaultEffect) {
    $.Widget.prototype['_' + method] = function(element, options, callback) {
      if (typeof options === 'string') {
        options = { effect: options };
      }
      var hasOptions,
        effectName = !options
          ? method
          : options === true || typeof options === 'number'
          ? defaultEffect
          : options.effect || defaultEffect;
      options = options || {};
      if (typeof options === 'number') {
        options = { duration: options };
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function(next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });
})(jQuery);

(function($, undefined) {
  var mouseHandled = false;
  $(document).mouseup(function() {
    mouseHandled = false;
  });

  $.widget('ui.mouse', {
    version: '1.10.3',
    options: {
      cancel: 'input,textarea,button,select,option',
      distance: 1,
      delay: 0,
    },
    _mouseInit: function() {
      var that = this;

      this.element
        .bind('mousedown.' + this.widgetName, function(event) {
          return that._mouseDown(event);
        })
        .bind('click.' + this.widgetName, function(event) {
          if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
            $.removeData(event.target, that.widgetName + '.preventClickEvent');
            event.stopImmediatePropagation();
            return false;
          }
        });

      this.started = false;
    },

    // TODO: make sure destroying one instance of mouse doesn't mess with
    // other instances of mouse
    _mouseDestroy: function() {
      this.element.unbind('.' + this.widgetName);
      if (this._mouseMoveDelegate) {
        $(document)
          .unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate)
          .unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);
      }
    },

    _mouseDown: function(event) {
      // don't let more than one widget handle mouseStart
      if (mouseHandled) {
        return;
      }

      // we may have missed mouseup (out of window)
      this._mouseStarted && this._mouseUp(event);

      this._mouseDownEvent = event;

      var that = this,
        btnIsLeft = event.which === 1,
        // event.target.nodeName works around a bug in IE 8 with
        // disabled inputs (#7620)
        elIsCancel =
          typeof this.options.cancel === 'string' && event.target.nodeName
            ? $(event.target).closest(this.options.cancel).length
            : false;
      if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
        return true;
      }

      this.mouseDelayMet = !this.options.delay;
      if (!this.mouseDelayMet) {
        this._mouseDelayTimer = setTimeout(function() {
          that.mouseDelayMet = true;
        }, this.options.delay);
      }

      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = this._mouseStart(event) !== false;
        if (!this._mouseStarted) {
          event.preventDefault();
          return true;
        }
      }

      // Click event may never have fired (Gecko & Opera)
      if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
        $.removeData(event.target, this.widgetName + '.preventClickEvent');
      }

      // these delegates are required to keep context
      this._mouseMoveDelegate = function(event) {
        return that._mouseMove(event);
      };
      this._mouseUpDelegate = function(event) {
        return that._mouseUp(event);
      };
      $(document)
        .bind('mousemove.' + this.widgetName, this._mouseMoveDelegate)
        .bind('mouseup.' + this.widgetName, this._mouseUpDelegate);

      event.preventDefault();

      mouseHandled = true;
      return true;
    },

    _mouseMove: function(event) {
      // IE mouseup check - mouseup happened when mouse was out of window
      if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
        return this._mouseUp(event);
      }

      if (this._mouseStarted) {
        this._mouseDrag(event);
        return event.preventDefault();
      }

      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
        this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
      }

      return !this._mouseStarted;
    },

    _mouseUp: function(event) {
      $(document)
        .unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate)
        .unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);

      if (this._mouseStarted) {
        this._mouseStarted = false;

        if (event.target === this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + '.preventClickEvent', true);
        }

        this._mouseStop(event);
      }

      return false;
    },

    _mouseDistanceMet: function(event) {
      return (
        Math.max(
          Math.abs(this._mouseDownEvent.pageX - event.pageX),
          Math.abs(this._mouseDownEvent.pageY - event.pageY)
        ) >= this.options.distance
      );
    },

    _mouseDelayMet: function(/* event */) {
      return this.mouseDelayMet;
    },

    // These are placeholder methods, to be overriden by extending plugin
    _mouseStart: function(/* event */) {},
    _mouseDrag: function(/* event */) {},
    _mouseStop: function(/* event */) {},
    _mouseCapture: function(/* event */) {
      return true;
    },
  });
})(jQuery);

(function($, undefined) {
  $.widget('ui.draggable', $.ui.mouse, {
    version: '1.10.3',
    widgetEventPrefix: 'drag',
    options: {
      addClasses: true,
      appendTo: 'parent',
      axis: false,
      connectToSortable: false,
      containment: false,
      cursor: 'auto',
      cursorAt: false,
      grid: false,
      handle: false,
      helper: 'original',
      iframeFix: false,
      opacity: false,
      refreshPositions: false,
      revert: false,
      revertDuration: 500,
      scope: 'default',
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      snap: false,
      snapMode: 'both',
      snapTolerance: 20,
      stack: false,
      zIndex: false,

      // callbacks
      drag: null,
      start: null,
      stop: null,
    },
    _create: function() {
      if (this.options.helper === 'original' && !/^(?:r|a|f)/.test(this.element.css('position'))) {
        this.element[0].style.position = 'relative';
      }
      if (this.options.addClasses) {
        this.element.addClass('ui-draggable');
      }
      if (this.options.disabled) {
        this.element.addClass('ui-draggable-disabled');
      }

      this._mouseInit();
    },

    _destroy: function() {
      this.element.removeClass('ui-draggable ui-draggable-dragging ui-draggable-disabled');
      this._mouseDestroy();
    },

    _mouseCapture: function(event) {
      var o = this.options;

      // among others, prevent a drag on a resizable-handle
      if (this.helper || o.disabled || $(event.target).closest('.ui-resizable-handle').length > 0) {
        return false;
      }

      //Quit if we're not on a valid handle
      this.handle = this._getHandle(event);
      if (!this.handle) {
        return false;
      }

      $(o.iframeFix === true ? 'iframe' : o.iframeFix).each(function() {
        $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
          .css({
            width: this.offsetWidth + 'px',
            height: this.offsetHeight + 'px',
            position: 'absolute',
            opacity: '0.001',
            zIndex: 1000,
          })
          .css($(this).offset())
          .appendTo('body');
      });

      return true;
    },

    _mouseStart: function(event) {
      var o = this.options;

      //Create and append the visible helper
      this.helper = this._createHelper(event);

      this.helper.addClass('ui-draggable-dragging');

      //Cache the helper size
      this._cacheHelperProportions();

      //If ddmanager is used for droppables, set the global draggable
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }

      /*
       * - Position generation -
       * This block generates everything position related - it's the core of draggables.
       */

      //Cache the margins of the original element
      this._cacheMargins();

      //Store the helper's css position
      this.cssPosition = this.helper.css('position');
      this.scrollParent = this.helper.scrollParent();
      this.offsetParent = this.helper.offsetParent();
      this.offsetParentCssPosition = this.offsetParent.css('position');

      //The element's absolute position on the page minus margins
      this.offset = this.positionAbs = this.element.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left,
      };

      //Reset scroll cache
      this.offset.scroll = false;

      $.extend(this.offset, {
        click: {
          //Where the click happened, relative to the element
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top,
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset(), //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
      });

      //Generate the original position
      this.originalPosition = this.position = this._generatePosition(event);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;

      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);

      //Set a containment if given in the options
      this._setContainment();

      //Trigger event + callbacks
      if (this._trigger('start', event) === false) {
        this._clear();
        return false;
      }

      //Recache the helper size
      this._cacheHelperProportions();

      //Prepare the droppable offsets
      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }

      this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

      //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStart(this, event);
      }

      return true;
    },

    _mouseDrag: function(event, noPropagation) {
      // reset any necessary cached properties (see #5009)
      if (this.offsetParentCssPosition === 'fixed') {
        this.offset.parent = this._getParentOffset();
      }

      //Compute the helpers position
      this.position = this._generatePosition(event);
      this.positionAbs = this._convertPositionTo('absolute');

      //Call plugins and callbacks and use the resulting position if something is returned
      if (!noPropagation) {
        var ui = this._uiHash();
        if (this._trigger('drag', event, ui) === false) {
          this._mouseUp({});
          return false;
        }
        this.position = ui.position;
      }

      if (!this.options.axis || this.options.axis !== 'y') {
        this.helper[0].style.left = this.position.left + 'px';
      }
      if (!this.options.axis || this.options.axis !== 'x') {
        this.helper[0].style.top = this.position.top + 'px';
      }
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }

      return false;
    },

    _mouseStop: function(event) {
      //If we are using droppables, inform the manager about the drop
      var that = this,
        dropped = false;
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        dropped = $.ui.ddmanager.drop(this, event);
      }

      //if a drop comes from outside (a sortable)
      if (this.dropped) {
        dropped = this.dropped;
        this.dropped = false;
      }

      //if the original element is no longer in the DOM don't bother to continue (see #8269)
      if (this.options.helper === 'original' && !$.contains(this.element[0].ownerDocument, this.element[0])) {
        return false;
      }

      if (
        (this.options.revert === 'invalid' && !dropped) ||
        (this.options.revert === 'valid' && dropped) ||
        this.options.revert === true ||
        ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))
      ) {
        $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
          if (that._trigger('stop', event) !== false) {
            that._clear();
          }
        });
      } else {
        if (this._trigger('stop', event) !== false) {
          this._clear();
        }
      }

      return false;
    },

    _mouseUp: function(event) {
      //Remove frame helpers
      $('div.ui-draggable-iframeFix').each(function() {
        this.parentNode.removeChild(this);
      });

      //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStop(this, event);
      }

      return $.ui.mouse.prototype._mouseUp.call(this, event);
    },

    cancel: function() {
      if (this.helper.is('.ui-draggable-dragging')) {
        this._mouseUp({});
      } else {
        this._clear();
      }

      return this;
    },

    _getHandle: function(event) {
      return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
    },

    _createHelper: function(event) {
      var o = this.options,
        helper = $.isFunction(o.helper)
          ? $(o.helper.apply(this.element[0], [event]))
          : o.helper === 'clone'
          ? this.element.clone().removeAttr('id')
          : this.element;

      if (!helper.parents('body').length) {
        helper.appendTo(o.appendTo === 'parent' ? this.element[0].parentNode : o.appendTo);
      }

      if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css('position'))) {
        helper.css('position', 'absolute');
      }

      return helper;
    },

    _adjustOffsetFromHelper: function(obj) {
      if (typeof obj === 'string') {
        obj = obj.split(' ');
      }
      if ($.isArray(obj)) {
        obj = { left: +obj[0], top: +obj[1] || 0 };
      }
      if ('left' in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ('right' in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ('top' in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ('bottom' in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },

    _getParentOffset: function() {
      //Get the offsetParent and cache its position
      var po = this.offsetParent.offset();

      // This is a special case where we need to modify a offset calculated on start, since the following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
      if (
        this.cssPosition === 'absolute' &&
        this.scrollParent[0] !== document &&
        $.contains(this.scrollParent[0], this.offsetParent[0])
      ) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }

      //This needs to be actually done for all browsers, since pageX/pageY includes this information
      //Ugly IE fix
      if (
        this.offsetParent[0] === document.body ||
        (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === 'html' && $.ui.ie)
      ) {
        po = { top: 0, left: 0 };
      }

      return {
        top: po.top + (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0),
      };
    },

    _getRelativeOffset: function() {
      if (this.cssPosition === 'relative') {
        var p = this.element.position();
        return {
          top: p.top - (parseInt(this.helper.css('top'), 10) || 0) + this.scrollParent.scrollTop(),
          left: p.left - (parseInt(this.helper.css('left'), 10) || 0) + this.scrollParent.scrollLeft(),
        };
      } else {
        return { top: 0, left: 0 };
      }
    },

    _cacheMargins: function() {
      this.margins = {
        left: parseInt(this.element.css('marginLeft'), 10) || 0,
        top: parseInt(this.element.css('marginTop'), 10) || 0,
        right: parseInt(this.element.css('marginRight'), 10) || 0,
        bottom: parseInt(this.element.css('marginBottom'), 10) || 0,
      };
    },

    _cacheHelperProportions: function() {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight(),
      };
    },

    _setContainment: function() {
      var over,
        c,
        ce,
        o = this.options;

      if (!o.containment) {
        this.containment = null;
        return;
      }

      if (o.containment === 'window') {
        this.containment = [
          $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
          $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
          $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left,
          $(window).scrollTop() +
            ($(window).height() || document.body.parentNode.scrollHeight) -
            this.helperProportions.height -
            this.margins.top,
        ];
        return;
      }

      if (o.containment === 'document') {
        this.containment = [
          0,
          0,
          $(document).width() - this.helperProportions.width - this.margins.left,
          ($(document).height() || document.body.parentNode.scrollHeight) -
            this.helperProportions.height -
            this.margins.top,
        ];
        return;
      }

      if (o.containment.constructor === Array) {
        this.containment = o.containment;
        return;
      }

      if (o.containment === 'parent') {
        o.containment = this.helper[0].parentNode;
      }

      c = $(o.containment);
      ce = c[0];

      if (!ce) {
        return;
      }

      over = c.css('overflow') !== 'hidden';

      this.containment = [
        (parseInt(c.css('borderLeftWidth'), 10) || 0) + (parseInt(c.css('paddingLeft'), 10) || 0),
        (parseInt(c.css('borderTopWidth'), 10) || 0) + (parseInt(c.css('paddingTop'), 10) || 0),
        (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) -
          (parseInt(c.css('borderRightWidth'), 10) || 0) -
          (parseInt(c.css('paddingRight'), 10) || 0) -
          this.helperProportions.width -
          this.margins.left -
          this.margins.right,
        (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) -
          (parseInt(c.css('borderBottomWidth'), 10) || 0) -
          (parseInt(c.css('paddingBottom'), 10) || 0) -
          this.helperProportions.height -
          this.margins.top -
          this.margins.bottom,
      ];
      this.relative_container = c;
    },

    _convertPositionTo: function(d, pos) {
      if (!pos) {
        pos = this.position;
      }

      var mod = d === 'absolute' ? 1 : -1,
        scroll =
          this.cssPosition === 'absolute' &&
          !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]))
            ? this.offsetParent
            : this.scrollParent;

      //Cache the scroll
      if (!this.offset.scroll) {
        this.offset.scroll = { top: scroll.scrollTop(), left: scroll.scrollLeft() };
      }

      return {
        top:
          pos.top + // The absolute mouse position
          this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
          (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : this.offset.scroll.top) * mod,
        left:
          pos.left + // The absolute mouse position
          this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
          (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : this.offset.scroll.left) * mod,
      };
    },

    _generatePosition: function(event) {
      var containment,
        co,
        top,
        left,
        o = this.options,
        scroll =
          this.cssPosition === 'absolute' &&
          !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]))
            ? this.offsetParent
            : this.scrollParent,
        pageX = event.pageX,
        pageY = event.pageY;

      //Cache the scroll
      if (!this.offset.scroll) {
        this.offset.scroll = { top: scroll.scrollTop(), left: scroll.scrollLeft() };
      }

      /*
       * - Position constraining -
       * Constrain the position to a mix of grid, containment.
       */

      // If we are not dragging yet, we won't check for options
      if (this.originalPosition) {
        if (this.containment) {
          if (this.relative_container) {
            co = this.relative_container.offset();
            containment = [
              this.containment[0] + co.left,
              this.containment[1] + co.top,
              this.containment[2] + co.left,
              this.containment[3] + co.top,
            ];
          } else {
            containment = this.containment;
          }

          if (event.pageX - this.offset.click.left < containment[0]) {
            pageX = containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < containment[1]) {
            pageY = containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > containment[2]) {
            pageX = containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > containment[3]) {
            pageY = containment[3] + this.offset.click.top;
          }
        }

        if (o.grid) {
          //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
          top = o.grid[1]
            ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1]
            : this.originalPageY;
          pageY = containment
            ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]
              ? top
              : top - this.offset.click.top >= containment[1]
              ? top - o.grid[1]
              : top + o.grid[1]
            : top;

          left = o.grid[0]
            ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0]
            : this.originalPageX;
          pageX = containment
            ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]
              ? left
              : left - this.offset.click.left >= containment[0]
              ? left - o.grid[0]
              : left + o.grid[0]
            : left;
        }
      }

      return {
        top:
          pageY - // The absolute mouse position
          this.offset.click.top - // Click offset (relative to the element)
          this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.top + // The offsetParent's offset without borders (offset + border)
          (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : this.offset.scroll.top),
        left:
          pageX - // The absolute mouse position
          this.offset.click.left - // Click offset (relative to the element)
          this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.left + // The offsetParent's offset without borders (offset + border)
          (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : this.offset.scroll.left),
      };
    },

    _clear: function() {
      this.helper.removeClass('ui-draggable-dragging');
      if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
        this.helper.remove();
      }
      this.helper = null;
      this.cancelHelperRemoval = false;
    },

    // From now on bulk stuff - mainly helpers

    _trigger: function(type, event, ui) {
      ui = ui || this._uiHash();
      $.ui.plugin.call(this, type, [event, ui]);
      //The absolute position has to be recalculated after plugins
      if (type === 'drag') {
        this.positionAbs = this._convertPositionTo('absolute');
      }
      return $.Widget.prototype._trigger.call(this, type, event, ui);
    },

    plugins: {},

    _uiHash: function() {
      return {
        helper: this.helper,
        position: this.position,
        originalPosition: this.originalPosition,
        offset: this.positionAbs,
      };
    },
  });

  $.ui.plugin.add('draggable', 'connectToSortable', {
    start: function(event, ui) {
      var inst = $(this).data('ui-draggable'),
        o = inst.options,
        uiSortable = $.extend({}, ui, { item: inst.element });
      inst.sortables = [];
      $(o.connectToSortable).each(function() {
        var sortable = $.data(this, 'ui-sortable');
        if (sortable && !sortable.options.disabled) {
          inst.sortables.push({
            instance: sortable,
            shouldRevert: sortable.options.revert,
          });
          sortable.refreshPositions(); // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
          sortable._trigger('activate', event, uiSortable);
        }
      });
    },
    stop: function(event, ui) {
      //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
      var inst = $(this).data('ui-draggable'),
        uiSortable = $.extend({}, ui, { item: inst.element });

      $.each(inst.sortables, function() {
        if (this.instance.isOver) {
          this.instance.isOver = 0;

          inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
          this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

          //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
          if (this.shouldRevert) {
            this.instance.options.revert = this.shouldRevert;
          }

          //Trigger the stop of the sortable
          this.instance._mouseStop(event);

          this.instance.options.helper = this.instance.options._helper;

          //If the helper has been the original item, restore properties in the sortable
          if (inst.options.helper === 'original') {
            this.instance.currentItem.css({ top: 'auto', left: 'auto' });
          }
        } else {
          this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
          this.instance._trigger('deactivate', event, uiSortable);
        }
      });
    },
    drag: function(event, ui) {
      var inst = $(this).data('ui-draggable'),
        that = this;

      $.each(inst.sortables, function() {
        var innermostIntersecting = false,
          thisSortable = this;

        //Copy over some variables to allow calling the sortable's native _intersectsWith
        this.instance.positionAbs = inst.positionAbs;
        this.instance.helperProportions = inst.helperProportions;
        this.instance.offset.click = inst.offset.click;

        if (this.instance._intersectsWith(this.instance.containerCache)) {
          innermostIntersecting = true;
          $.each(inst.sortables, function() {
            this.instance.positionAbs = inst.positionAbs;
            this.instance.helperProportions = inst.helperProportions;
            this.instance.offset.click = inst.offset.click;
            if (
              this !== thisSortable &&
              this.instance._intersectsWith(this.instance.containerCache) &&
              $.contains(thisSortable.instance.element[0], this.instance.element[0])
            ) {
              innermostIntersecting = false;
            }
            return innermostIntersecting;
          });
        }

        if (innermostIntersecting) {
          //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
          if (!this.instance.isOver) {
            this.instance.isOver = 1;
            //Now we fake the start of dragging for the sortable instance,
            //by cloning the list group item, appending it to the sortable and using it as inst.currentItem
            //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
            this.instance.currentItem = $(that)
              .clone()
              .removeAttr('id')
              .appendTo(this.instance.element)
              .data('ui-sortable-item', true);
            this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
            this.instance.options.helper = function() {
              return ui.helper[0];
            };

            event.target = this.instance.currentItem[0];
            this.instance._mouseCapture(event, true);
            this.instance._mouseStart(event, true, true);

            //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
            this.instance.offset.click.top = inst.offset.click.top;
            this.instance.offset.click.left = inst.offset.click.left;
            this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
            this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

            inst._trigger('toSortable', event);
            inst.dropped = this.instance.element; //draggable revert needs that
            //hack so receive/update callbacks work (mostly)
            inst.currentItem = inst.element;
            this.instance.fromOutside = inst;
          }

          //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
          if (this.instance.currentItem) {
            this.instance._mouseDrag(event);
          }
        } else {
          //If it doesn't intersect with the sortable, and it intersected before,
          //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
          if (this.instance.isOver) {
            this.instance.isOver = 0;
            this.instance.cancelHelperRemoval = true;

            //Prevent reverting on this forced stop
            this.instance.options.revert = false;

            // The out event needs to be triggered independently
            this.instance._trigger('out', event, this.instance._uiHash(this.instance));

            this.instance._mouseStop(event, true);
            this.instance.options.helper = this.instance.options._helper;

            //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
            this.instance.currentItem.remove();
            if (this.instance.placeholder) {
              this.instance.placeholder.remove();
            }

            inst._trigger('fromSortable', event);
            inst.dropped = false; //draggable revert needs that
          }
        }
      });
    },
  });

  $.ui.plugin.add('draggable', 'cursor', {
    start: function() {
      var t = $('body'),
        o = $(this).data('ui-draggable').options;
      if (t.css('cursor')) {
        o._cursor = t.css('cursor');
      }
      t.css('cursor', o.cursor);
    },
    stop: function() {
      var o = $(this).data('ui-draggable').options;
      if (o._cursor) {
        $('body').css('cursor', o._cursor);
      }
    },
  });

  $.ui.plugin.add('draggable', 'opacity', {
    start: function(event, ui) {
      var t = $(ui.helper),
        o = $(this).data('ui-draggable').options;
      if (t.css('opacity')) {
        o._opacity = t.css('opacity');
      }
      t.css('opacity', o.opacity);
    },
    stop: function(event, ui) {
      var o = $(this).data('ui-draggable').options;
      if (o._opacity) {
        $(ui.helper).css('opacity', o._opacity);
      }
    },
  });

  $.ui.plugin.add('draggable', 'scroll', {
    start: function() {
      var i = $(this).data('ui-draggable');
      if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== 'HTML') {
        i.overflowOffset = i.scrollParent.offset();
      }
    },
    drag: function(event) {
      var i = $(this).data('ui-draggable'),
        o = i.options,
        scrolled = false;

      if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== 'HTML') {
        if (!o.axis || o.axis !== 'x') {
          if (i.overflowOffset.top + i.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
          } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
          }
        }

        if (!o.axis || o.axis !== 'y') {
          if (i.overflowOffset.left + i.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
          } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
          }
        }
      } else {
        if (!o.axis || o.axis !== 'x') {
          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
          }
        }

        if (!o.axis || o.axis !== 'y') {
          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
          }
        }
      }

      if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(i, event);
      }
    },
  });

  $.ui.plugin.add('draggable', 'snap', {
    start: function() {
      var i = $(this).data('ui-draggable'),
        o = i.options;

      i.snapElements = [];

      $(o.snap.constructor !== String ? o.snap.items || ':data(ui-draggable)' : o.snap).each(function() {
        var $t = $(this),
          $o = $t.offset();
        if (this !== i.element[0]) {
          i.snapElements.push({
            item: this,
            width: $t.outerWidth(),
            height: $t.outerHeight(),
            top: $o.top,
            left: $o.left,
          });
        }
      });
    },
    drag: function(event, ui) {
      var ts,
        bs,
        ls,
        rs,
        l,
        r,
        t,
        b,
        i,
        first,
        inst = $(this).data('ui-draggable'),
        o = inst.options,
        d = o.snapTolerance,
        x1 = ui.offset.left,
        x2 = x1 + inst.helperProportions.width,
        y1 = ui.offset.top,
        y2 = y1 + inst.helperProportions.height;

      for (i = inst.snapElements.length - 1; i >= 0; i--) {
        l = inst.snapElements[i].left;
        r = l + inst.snapElements[i].width;
        t = inst.snapElements[i].top;
        b = t + inst.snapElements[i].height;

        if (
          x2 < l - d ||
          x1 > r + d ||
          y2 < t - d ||
          y1 > b + d ||
          !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)
        ) {
          if (inst.snapElements[i].snapping) {
            inst.options.snap.release &&
              inst.options.snap.release.call(
                inst.element,
                event,
                $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })
              );
          }
          inst.snapElements[i].snapping = false;
          continue;
        }

        if (o.snapMode !== 'inner') {
          ts = Math.abs(t - y2) <= d;
          bs = Math.abs(b - y1) <= d;
          ls = Math.abs(l - x2) <= d;
          rs = Math.abs(r - x1) <= d;
          if (ts) {
            ui.position.top =
              inst._convertPositionTo('relative', { top: t - inst.helperProportions.height, left: 0 }).top -
              inst.margins.top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo('relative', { top: b, left: 0 }).top - inst.margins.top;
          }
          if (ls) {
            ui.position.left =
              inst._convertPositionTo('relative', { top: 0, left: l - inst.helperProportions.width }).left -
              inst.margins.left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo('relative', { top: 0, left: r }).left - inst.margins.left;
          }
        }

        first = ts || bs || ls || rs;

        if (o.snapMode !== 'outer') {
          ts = Math.abs(t - y1) <= d;
          bs = Math.abs(b - y2) <= d;
          ls = Math.abs(l - x1) <= d;
          rs = Math.abs(r - x2) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo('relative', { top: t, left: 0 }).top - inst.margins.top;
          }
          if (bs) {
            ui.position.top =
              inst._convertPositionTo('relative', { top: b - inst.helperProportions.height, left: 0 }).top -
              inst.margins.top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo('relative', { top: 0, left: l }).left - inst.margins.left;
          }
          if (rs) {
            ui.position.left =
              inst._convertPositionTo('relative', { top: 0, left: r - inst.helperProportions.width }).left -
              inst.margins.left;
          }
        }

        if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
          inst.options.snap.snap &&
            inst.options.snap.snap.call(
              inst.element,
              event,
              $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })
            );
        }
        inst.snapElements[i].snapping = ts || bs || ls || rs || first;
      }
    },
  });

  $.ui.plugin.add('draggable', 'stack', {
    start: function() {
      var min,
        o = this.data('ui-draggable').options,
        group = $.makeArray($(o.stack)).sort(function(a, b) {
          return (parseInt($(a).css('zIndex'), 10) || 0) - (parseInt($(b).css('zIndex'), 10) || 0);
        });

      if (!group.length) {
        return;
      }

      min = parseInt($(group[0]).css('zIndex'), 10) || 0;
      $(group).each(function(i) {
        $(this).css('zIndex', min + i);
      });
      this.css('zIndex', min + group.length);
    },
  });

  $.ui.plugin.add('draggable', 'zIndex', {
    start: function(event, ui) {
      var t = $(ui.helper),
        o = $(this).data('ui-draggable').options;
      if (t.css('zIndex')) {
        o._zIndex = t.css('zIndex');
      }
      t.css('zIndex', o.zIndex);
    },
    stop: function(event, ui) {
      var o = $(this).data('ui-draggable').options;
      if (o._zIndex) {
        $(ui.helper).css('zIndex', o._zIndex);
      }
    },
  });
})(jQuery);

(function($, undefined) {
  function isOverAxis(x, reference, size) {
    return x > reference && x < reference + size;
  }

  $.widget('ui.droppable', {
    version: '1.10.3',
    widgetEventPrefix: 'drop',
    options: {
      accept: '*',
      activeClass: false,
      addClasses: true,
      greedy: false,
      hoverClass: false,
      scope: 'default',
      tolerance: 'intersect',

      // callbacks
      activate: null,
      deactivate: null,
      drop: null,
      out: null,
      over: null,
    },
    _create: function() {
      var o = this.options,
        accept = o.accept;

      this.isover = false;
      this.isout = true;

      this.accept = $.isFunction(accept)
        ? accept
        : function(d) {
            return d.is(accept);
          };

      //Store the droppable's proportions
      this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

      // Add the reference and positions to the manager
      $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
      $.ui.ddmanager.droppables[o.scope].push(this);

      o.addClasses && this.element.addClass('ui-droppable');
    },

    _destroy: function() {
      var i = 0,
        drop = $.ui.ddmanager.droppables[this.options.scope];

      for (; i < drop.length; i++) {
        if (drop[i] === this) {
          drop.splice(i, 1);
        }
      }

      this.element.removeClass('ui-droppable ui-droppable-disabled');
    },

    _setOption: function(key, value) {
      if (key === 'accept') {
        this.accept = $.isFunction(value)
          ? value
          : function(d) {
              return d.is(value);
            };
      }
      $.Widget.prototype._setOption.apply(this, arguments);
    },

    _activate: function(event) {
      var draggable = $.ui.ddmanager.current;
      if (this.options.activeClass) {
        this.element.addClass(this.options.activeClass);
      }
      if (draggable) {
        this._trigger('activate', event, this.ui(draggable));
      }
    },

    _deactivate: function(event) {
      var draggable = $.ui.ddmanager.current;
      if (this.options.activeClass) {
        this.element.removeClass(this.options.activeClass);
      }
      if (draggable) {
        this._trigger('deactivate', event, this.ui(draggable));
      }
    },

    _over: function(event) {
      var draggable = $.ui.ddmanager.current;

      // Bail if draggable and droppable are same element
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return;
      }

      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.hoverClass) {
          this.element.addClass(this.options.hoverClass);
        }
        this._trigger('over', event, this.ui(draggable));
      }
    },

    _out: function(event) {
      var draggable = $.ui.ddmanager.current;

      // Bail if draggable and droppable are same element
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return;
      }

      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.hoverClass) {
          this.element.removeClass(this.options.hoverClass);
        }
        this._trigger('out', event, this.ui(draggable));
      }
    },

    _drop: function(event, custom) {
      var draggable = custom || $.ui.ddmanager.current,
        childrenIntersection = false;

      // Bail if draggable and droppable are same element
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return false;
      }

      this.element
        .find(':data(ui-droppable)')
        .not('.ui-draggable-dragging')
        .each(function() {
          var inst = $.data(this, 'ui-droppable');
          if (
            inst.options.greedy &&
            !inst.options.disabled &&
            inst.options.scope === draggable.options.scope &&
            inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) &&
            $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
          ) {
            childrenIntersection = true;
            return false;
          }
        });
      if (childrenIntersection) {
        return false;
      }

      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.activeClass) {
          this.element.removeClass(this.options.activeClass);
        }
        if (this.options.hoverClass) {
          this.element.removeClass(this.options.hoverClass);
        }
        this._trigger('drop', event, this.ui(draggable));
        return this.element;
      }

      return false;
    },

    ui: function(c) {
      return {
        draggable: c.currentItem || c.element,
        helper: c.helper,
        position: c.position,
        offset: c.positionAbs,
      };
    },
  });

  $.ui.intersect = function(draggable, droppable, toleranceMode) {
    if (!droppable.offset) {
      return false;
    }

    var draggableLeft,
      draggableTop,
      x1 = (draggable.positionAbs || draggable.position.absolute).left,
      x2 = x1 + draggable.helperProportions.width,
      y1 = (draggable.positionAbs || draggable.position.absolute).top,
      y2 = y1 + draggable.helperProportions.height,
      l = droppable.offset.left,
      r = l + droppable.proportions.width,
      t = droppable.offset.top,
      b = t + droppable.proportions.height;

    switch (toleranceMode) {
      case 'fit':
        return l <= x1 && x2 <= r && t <= y1 && y2 <= b;
      case 'intersect':
        return (
          l < x1 + draggable.helperProportions.width / 2 && // Right Half
          x2 - draggable.helperProportions.width / 2 < r && // Left Half
          t < y1 + draggable.helperProportions.height / 2 && // Bottom Half
          y2 - draggable.helperProportions.height / 2 < b
        ); // Top Half
      case 'pointer':
        draggableLeft =
          (draggable.positionAbs || draggable.position.absolute).left +
          (draggable.clickOffset || draggable.offset.click).left;
        draggableTop =
          (draggable.positionAbs || draggable.position.absolute).top +
          (draggable.clickOffset || draggable.offset.click).top;
        return (
          isOverAxis(draggableTop, t, droppable.proportions.height) &&
          isOverAxis(draggableLeft, l, droppable.proportions.width)
        );
      case 'touch':
        return (
          ((y1 >= t && y1 <= b) || // Top edge touching
          (y2 >= t && y2 <= b) || // Bottom edge touching
            (y1 < t && y2 > b)) && // Surrounded vertically
          ((x1 >= l && x1 <= r) || // Left edge touching
          (x2 >= l && x2 <= r) || // Right edge touching
            (x1 < l && x2 > r)) // Surrounded horizontally
        );
      default:
        return false;
    }
  };

  /*
	This manager tracks offsets of draggables and droppables
*/
  $.ui.ddmanager = {
    current: null,
    droppables: { default: [] },
    prepareOffsets: function(t, event) {
      var i,
        j,
        m = $.ui.ddmanager.droppables[t.options.scope] || [],
        type = event ? event.type : null, // workaround for #2317
        list = (t.currentItem || t.element).find(':data(ui-droppable)').addBack();

      droppablesLoop: for (i = 0; i < m.length; i++) {
        //No disabled and non-accepted
        if (m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element))) {
          continue;
        }

        // Filter out elements in the current dragged item
        for (j = 0; j < list.length; j++) {
          if (list[j] === m[i].element[0]) {
            m[i].proportions.height = 0;
            continue droppablesLoop;
          }
        }

        m[i].visible = m[i].element.css('display') !== 'none';
        if (!m[i].visible) {
          continue;
        }

        //Activate the droppable if used directly from draggables
        if (type === 'mousedown') {
          m[i]._activate.call(m[i], event);
        }

        m[i].offset = m[i].element.offset();
        m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };
      }
    },
    drop: function(draggable, event) {
      var dropped = false;
      // Create a copy of the droppables in case the list changes during the drop (#9116)
      $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
        if (!this.options) {
          return;
        }
        if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
          dropped = this._drop.call(this, event) || dropped;
        }

        if (
          !this.options.disabled &&
          this.visible &&
          this.accept.call(this.element[0], draggable.currentItem || draggable.element)
        ) {
          this.isout = true;
          this.isover = false;
          this._deactivate.call(this, event);
        }
      });
      return dropped;
    },
    dragStart: function(draggable, event) {
      //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
      draggable.element.parentsUntil('body').bind('scroll.droppable', function() {
        if (!draggable.options.refreshPositions) {
          $.ui.ddmanager.prepareOffsets(draggable, event);
        }
      });
    },
    drag: function(draggable, event) {
      //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
      if (draggable.options.refreshPositions) {
        $.ui.ddmanager.prepareOffsets(draggable, event);
      }

      //Run through all droppables and check their positions based on specific tolerance options
      $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
        if (this.options.disabled || this.greedyChild || !this.visible) {
          return;
        }

        var parentInstance,
          scope,
          parent,
          intersects = $.ui.intersect(draggable, this, this.options.tolerance),
          c = !intersects && this.isover ? 'isout' : intersects && !this.isover ? 'isover' : null;
        if (!c) {
          return;
        }

        if (this.options.greedy) {
          // find droppable parents with same scope
          scope = this.options.scope;
          parent = this.element.parents(':data(ui-droppable)').filter(function() {
            return $.data(this, 'ui-droppable').options.scope === scope;
          });

          if (parent.length) {
            parentInstance = $.data(parent[0], 'ui-droppable');
            parentInstance.greedyChild = c === 'isover';
          }
        }

        // we just moved into a greedy child
        if (parentInstance && c === 'isover') {
          parentInstance.isover = false;
          parentInstance.isout = true;
          parentInstance._out.call(parentInstance, event);
        }

        this[c] = true;
        this[c === 'isout' ? 'isover' : 'isout'] = false;
        this[c === 'isover' ? '_over' : '_out'].call(this, event);

        // we just moved out of a greedy child
        if (parentInstance && c === 'isout') {
          parentInstance.isout = false;
          parentInstance.isover = true;
          parentInstance._over.call(parentInstance, event);
        }
      });
    },
    dragStop: function(draggable, event) {
      draggable.element.parentsUntil('body').unbind('scroll.droppable');
      //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
      if (!draggable.options.refreshPositions) {
        $.ui.ddmanager.prepareOffsets(draggable, event);
      }
    },
  };
})(jQuery);

(function($, undefined) {
  function num(v) {
    return parseInt(v, 10) || 0;
  }

  function isNumber(value) {
    return !isNaN(parseInt(value, 10));
  }

  $.widget('ui.resizable', $.ui.mouse, {
    version: '1.10.3',
    widgetEventPrefix: 'resize',
    options: {
      alsoResize: false,
      animate: false,
      animateDuration: 'slow',
      animateEasing: 'swing',
      aspectRatio: false,
      autoHide: false,
      containment: false,
      ghost: false,
      grid: false,
      handles: 'e,s,se',
      helper: false,
      maxHeight: null,
      maxWidth: null,
      minHeight: 10,
      minWidth: 10,
      // See #7960
      zIndex: 90,

      // callbacks
      resize: null,
      start: null,
      stop: null,
    },
    _create: function() {
      var n,
        i,
        handle,
        axis,
        hname,
        that = this,
        o = this.options;
      this.element.addClass('ui-resizable');

      $.extend(this, {
        _aspectRatio: !!o.aspectRatio,
        aspectRatio: o.aspectRatio,
        originalElement: this.element,
        _proportionallyResizeElements: [],
        _helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null,
      });

      //Wrap the element if it cannot hold child nodes
      if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {
        //Create a wrapper element and set the wrapper to the new current internal element
        this.element.wrap(
          $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
            position: this.element.css('position'),
            width: this.element.outerWidth(),
            height: this.element.outerHeight(),
            top: this.element.css('top'),
            left: this.element.css('left'),
          })
        );

        //Overwrite the original this.element
        this.element = this.element.parent().data('ui-resizable', this.element.data('ui-resizable'));

        this.elementIsWrapper = true;

        //Move margins to the wrapper
        this.element.css({
          marginLeft: this.originalElement.css('marginLeft'),
          marginTop: this.originalElement.css('marginTop'),
          marginRight: this.originalElement.css('marginRight'),
          marginBottom: this.originalElement.css('marginBottom'),
        });
        this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0 });

        //Prevent Safari textarea resize
        this.originalResizeStyle = this.originalElement.css('resize');
        this.originalElement.css('resize', 'none');

        //Push the actual element to our proportionallyResize internal array
        this._proportionallyResizeElements.push(
          this.originalElement.css({ position: 'static', zoom: 1, display: 'block' })
        );

        // avoid IE jump (hard set the margin)
        this.originalElement.css({ margin: this.originalElement.css('margin') });

        // fix handlers offset
        this._proportionallyResize();
      }

      this.handles =
        o.handles ||
        (!$('.ui-resizable-handle', this.element).length
          ? 'e,s,se'
          : {
              n: '.ui-resizable-n',
              e: '.ui-resizable-e',
              s: '.ui-resizable-s',
              w: '.ui-resizable-w',
              se: '.ui-resizable-se',
              sw: '.ui-resizable-sw',
              ne: '.ui-resizable-ne',
              nw: '.ui-resizable-nw',
            });
      if (this.handles.constructor === String) {
        if (this.handles === 'all') {
          this.handles = 'n,e,s,w,se,sw,ne,nw';
        }

        n = this.handles.split(',');
        this.handles = {};

        for (i = 0; i < n.length; i++) {
          handle = $.trim(n[i]);
          hname = 'ui-resizable-' + handle;
          axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

          // Apply zIndex to all handles - see #7960
          axis.css({ zIndex: o.zIndex });

          //TODO : What's going on here?
          if ('se' === handle) {
            axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
          }

          //Insert into internal handles object and append to element
          this.handles[handle] = '.ui-resizable-' + handle;
          this.element.append(axis);
        }
      }

      this._renderAxis = function(target) {
        var i, axis, padPos, padWrapper;

        target = target || this.element;

        for (i in this.handles) {
          if (this.handles[i].constructor === String) {
            this.handles[i] = $(this.handles[i], this.element).show();
          }

          //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
          if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
            axis = $(this.handles[i], this.element);

            //Checking the correct pad and border
            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

            //The padding type i have to apply...
            padPos = [
              'padding',
              /ne|nw|n/.test(i) ? 'Top' : /se|sw|s/.test(i) ? 'Bottom' : /^e$/.test(i) ? 'Right' : 'Left',
            ].join('');

            target.css(padPos, padWrapper);

            this._proportionallyResize();
          }

          //TODO: What's that good for? There's not anything to be executed left
          if (!$(this.handles[i]).length) {
            continue;
          }
        }
      };

      //TODO: make renderAxis a prototype function
      this._renderAxis(this.element);

      this._handles = $('.ui-resizable-handle', this.element).disableSelection();

      //Matching axis name
      this._handles.mouseover(function() {
        if (!that.resizing) {
          if (this.className) {
            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
          }
          //Axis, default = se
          that.axis = axis && axis[1] ? axis[1] : 'se';
        }
      });

      //If we want to auto hide the elements
      if (o.autoHide) {
        this._handles.hide();
        $(this.element)
          .addClass('ui-resizable-autohide')
          .mouseenter(function() {
            if (o.disabled) {
              return;
            }
            $(this).removeClass('ui-resizable-autohide');
            that._handles.show();
          })
          .mouseleave(function() {
            if (o.disabled) {
              return;
            }
            if (!that.resizing) {
              $(this).addClass('ui-resizable-autohide');
              that._handles.hide();
            }
          });
      }

      //Initialize the mouse interaction
      this._mouseInit();
    },

    _destroy: function() {
      this._mouseDestroy();

      var wrapper,
        _destroy = function(exp) {
          $(exp)
            .removeClass('ui-resizable ui-resizable-disabled ui-resizable-resizing')
            .removeData('resizable')
            .removeData('ui-resizable')
            .unbind('.resizable')
            .find('.ui-resizable-handle')
            .remove();
        };

      //TODO: Unwrap at same DOM position
      if (this.elementIsWrapper) {
        _destroy(this.element);
        wrapper = this.element;
        this.originalElement
          .css({
            position: wrapper.css('position'),
            width: wrapper.outerWidth(),
            height: wrapper.outerHeight(),
            top: wrapper.css('top'),
            left: wrapper.css('left'),
          })
          .insertAfter(wrapper);
        wrapper.remove();
      }

      this.originalElement.css('resize', this.originalResizeStyle);
      _destroy(this.originalElement);

      return this;
    },

    _mouseCapture: function(event) {
      var i,
        handle,
        capture = false;

      for (i in this.handles) {
        handle = $(this.handles[i])[0];
        if (handle === event.target || $.contains(handle, event.target)) {
          capture = true;
        }
      }

      return !this.options.disabled && capture;
    },

    _mouseStart: function(event) {
      var curleft,
        curtop,
        cursor,
        o = this.options,
        iniPos = this.element.position(),
        el = this.element;

      this.resizing = true;

      // bugfix for http://dev.jquery.com/ticket/1749
      if (/absolute/.test(el.css('position'))) {
        el.css({ position: 'absolute', top: el.css('top'), left: el.css('left') });
      } else if (el.is('.ui-draggable')) {
        el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
      }

      this._renderProxy();

      curleft = num(this.helper.css('left'));
      curtop = num(this.helper.css('top'));

      if (o.containment) {
        curleft += $(o.containment).scrollLeft() || 0;
        curtop += $(o.containment).scrollTop() || 0;
      }

      //Store needed variables
      this.offset = this.helper.offset();
      this.position = { left: curleft, top: curtop };
      this.size = this._helper
        ? { width: el.outerWidth(), height: el.outerHeight() }
        : { width: el.width(), height: el.height() };
      this.originalSize = this._helper
        ? { width: el.outerWidth(), height: el.outerHeight() }
        : { width: el.width(), height: el.height() };
      this.originalPosition = { left: curleft, top: curtop };
      this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
      this.originalMousePosition = { left: event.pageX, top: event.pageY };

      //Aspect Ratio
      this.aspectRatio =
        typeof o.aspectRatio === 'number' ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;

      cursor = $('.ui-resizable-' + this.axis).css('cursor');
      $('body').css('cursor', cursor === 'auto' ? this.axis + '-resize' : cursor);

      el.addClass('ui-resizable-resizing');
      this._propagate('start', event);
      return true;
    },

    _mouseDrag: function(event) {
      //Increase performance, avoid regex
      var data,
        el = this.helper,
        props = {},
        smp = this.originalMousePosition,
        a = this.axis,
        prevTop = this.position.top,
        prevLeft = this.position.left,
        prevWidth = this.size.width,
        prevHeight = this.size.height,
        dx = event.pageX - smp.left || 0,
        dy = event.pageY - smp.top || 0,
        trigger = this._change[a];

      if (!trigger) {
        return false;
      }

      // Calculate the attrs that will be change
      data = trigger.apply(this, [event, dx, dy]);

      // Put this in the mouseDrag handler since the user can start pressing shift while resizing
      this._updateVirtualBoundaries(event.shiftKey);
      if (this._aspectRatio || event.shiftKey) {
        data = this._updateRatio(data, event);
      }

      data = this._respectSize(data, event);

      this._updateCache(data);

      // plugins callbacks need to be called first
      this._propagate('resize', event);

      if (this.position.top !== prevTop) {
        props.top = this.position.top + 'px';
      }
      if (this.position.left !== prevLeft) {
        props.left = this.position.left + 'px';
      }
      if (this.size.width !== prevWidth) {
        props.width = this.size.width + 'px';
      }
      if (this.size.height !== prevHeight) {
        props.height = this.size.height + 'px';
      }
      el.css(props);

      if (!this._helper && this._proportionallyResizeElements.length) {
        this._proportionallyResize();
      }

      // Call the user callback if the element was resized
      if (!$.isEmptyObject(props)) {
        this._trigger('resize', event, this.ui());
      }

      return false;
    },

    _mouseStop: function(event) {
      this.resizing = false;
      var pr,
        ista,
        soffseth,
        soffsetw,
        s,
        left,
        top,
        o = this.options,
        that = this;

      if (this._helper) {
        pr = this._proportionallyResizeElements;
        ista = pr.length && /textarea/i.test(pr[0].nodeName);
        soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : that.sizeDiff.height;
        soffsetw = ista ? 0 : that.sizeDiff.width;

        s = { width: that.helper.width() - soffsetw, height: that.helper.height() - soffseth };
        left = parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left) || null;
        top = parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top) || null;

        if (!o.animate) {
          this.element.css($.extend(s, { top: top, left: left }));
        }

        that.helper.height(that.size.height);
        that.helper.width(that.size.width);

        if (this._helper && !o.animate) {
          this._proportionallyResize();
        }
      }

      $('body').css('cursor', 'auto');

      this.element.removeClass('ui-resizable-resizing');

      this._propagate('stop', event);

      if (this._helper) {
        this.helper.remove();
      }

      return false;
    },

    _updateVirtualBoundaries: function(forceAspectRatio) {
      var pMinWidth,
        pMaxWidth,
        pMinHeight,
        pMaxHeight,
        b,
        o = this.options;

      b = {
        minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
        maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
        minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
        maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity,
      };

      if (this._aspectRatio || forceAspectRatio) {
        // We want to create an enclosing box whose aspect ration is the requested one
        // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
        pMinWidth = b.minHeight * this.aspectRatio;
        pMinHeight = b.minWidth / this.aspectRatio;
        pMaxWidth = b.maxHeight * this.aspectRatio;
        pMaxHeight = b.maxWidth / this.aspectRatio;

        if (pMinWidth > b.minWidth) {
          b.minWidth = pMinWidth;
        }
        if (pMinHeight > b.minHeight) {
          b.minHeight = pMinHeight;
        }
        if (pMaxWidth < b.maxWidth) {
          b.maxWidth = pMaxWidth;
        }
        if (pMaxHeight < b.maxHeight) {
          b.maxHeight = pMaxHeight;
        }
      }
      this._vBoundaries = b;
    },

    _updateCache: function(data) {
      this.offset = this.helper.offset();
      if (isNumber(data.left)) {
        this.position.left = data.left;
      }
      if (isNumber(data.top)) {
        this.position.top = data.top;
      }
      if (isNumber(data.height)) {
        this.size.height = data.height;
      }
      if (isNumber(data.width)) {
        this.size.width = data.width;
      }
    },

    _updateRatio: function(data) {
      var cpos = this.position,
        csize = this.size,
        a = this.axis;

      if (isNumber(data.height)) {
        data.width = data.height * this.aspectRatio;
      } else if (isNumber(data.width)) {
        data.height = data.width / this.aspectRatio;
      }

      if (a === 'sw') {
        data.left = cpos.left + (csize.width - data.width);
        data.top = null;
      }
      if (a === 'nw') {
        data.top = cpos.top + (csize.height - data.height);
        data.left = cpos.left + (csize.width - data.width);
      }

      return data;
    },

    _respectSize: function(data) {
      var o = this._vBoundaries,
        a = this.axis,
        ismaxw = isNumber(data.width) && o.maxWidth && o.maxWidth < data.width,
        ismaxh = isNumber(data.height) && o.maxHeight && o.maxHeight < data.height,
        isminw = isNumber(data.width) && o.minWidth && o.minWidth > data.width,
        isminh = isNumber(data.height) && o.minHeight && o.minHeight > data.height,
        dw = this.originalPosition.left + this.originalSize.width,
        dh = this.position.top + this.size.height,
        cw = /sw|nw|w/.test(a),
        ch = /nw|ne|n/.test(a);
      if (isminw) {
        data.width = o.minWidth;
      }
      if (isminh) {
        data.height = o.minHeight;
      }
      if (ismaxw) {
        data.width = o.maxWidth;
      }
      if (ismaxh) {
        data.height = o.maxHeight;
      }

      if (isminw && cw) {
        data.left = dw - o.minWidth;
      }
      if (ismaxw && cw) {
        data.left = dw - o.maxWidth;
      }
      if (isminh && ch) {
        data.top = dh - o.minHeight;
      }
      if (ismaxh && ch) {
        data.top = dh - o.maxHeight;
      }

      // fixing jump error on top/left - bug #2330
      if (!data.width && !data.height && !data.left && data.top) {
        data.top = null;
      } else if (!data.width && !data.height && !data.top && data.left) {
        data.left = null;
      }

      return data;
    },

    _proportionallyResize: function() {
      if (!this._proportionallyResizeElements.length) {
        return;
      }

      var i,
        j,
        borders,
        paddings,
        prel,
        element = this.helper || this.element;

      for (i = 0; i < this._proportionallyResizeElements.length; i++) {
        prel = this._proportionallyResizeElements[i];

        if (!this.borderDif) {
          this.borderDif = [];
          borders = [
            prel.css('borderTopWidth'),
            prel.css('borderRightWidth'),
            prel.css('borderBottomWidth'),
            prel.css('borderLeftWidth'),
          ];
          paddings = [
            prel.css('paddingTop'),
            prel.css('paddingRight'),
            prel.css('paddingBottom'),
            prel.css('paddingLeft'),
          ];

          for (j = 0; j < borders.length; j++) {
            this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
          }
        }

        prel.css({
          height: element.height() - this.borderDif[0] - this.borderDif[2] || 0,
          width: element.width() - this.borderDif[1] - this.borderDif[3] || 0,
        });
      }
    },

    _renderProxy: function() {
      var el = this.element,
        o = this.options;
      this.elementOffset = el.offset();

      if (this._helper) {
        this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

        this.helper.addClass(this._helper).css({
          width: this.element.outerWidth() - 1,
          height: this.element.outerHeight() - 1,
          position: 'absolute',
          left: this.elementOffset.left + 'px',
          top: this.elementOffset.top + 'px',
          zIndex: ++o.zIndex, //TODO: Don't modify option
        });

        this.helper.appendTo('body').disableSelection();
      } else {
        this.helper = this.element;
      }
    },

    _change: {
      e: function(event, dx) {
        return { width: this.originalSize.width + dx };
      },
      w: function(event, dx) {
        var cs = this.originalSize,
          sp = this.originalPosition;
        return { left: sp.left + dx, width: cs.width - dx };
      },
      n: function(event, dx, dy) {
        var cs = this.originalSize,
          sp = this.originalPosition;
        return { top: sp.top + dy, height: cs.height - dy };
      },
      s: function(event, dx, dy) {
        return { height: this.originalSize.height + dy };
      },
      se: function(event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
      },
      sw: function(event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
      },
      ne: function(event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
      },
      nw: function(event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
      },
    },

    _propagate: function(n, event) {
      $.ui.plugin.call(this, n, [event, this.ui()]);
      n !== 'resize' && this._trigger(n, event, this.ui());
    },

    plugins: {},

    ui: function() {
      return {
        originalElement: this.originalElement,
        element: this.element,
        helper: this.helper,
        position: this.position,
        size: this.size,
        originalSize: this.originalSize,
        originalPosition: this.originalPosition,
      };
    },
  });

  /*
   * Resizable Extensions
   */

  $.ui.plugin.add('resizable', 'animate', {
    stop: function(event) {
      var that = $(this).data('ui-resizable'),
        o = that.options,
        pr = that._proportionallyResizeElements,
        ista = pr.length && /textarea/i.test(pr[0].nodeName),
        soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : that.sizeDiff.height,
        soffsetw = ista ? 0 : that.sizeDiff.width,
        style = { width: that.size.width - soffsetw, height: that.size.height - soffseth },
        left = parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left) || null,
        top = parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top) || null;

      that.element.animate($.extend(style, top && left ? { top: top, left: left } : {}), {
        duration: o.animateDuration,
        easing: o.animateEasing,
        step: function() {
          var data = {
            width: parseInt(that.element.css('width'), 10),
            height: parseInt(that.element.css('height'), 10),
            top: parseInt(that.element.css('top'), 10),
            left: parseInt(that.element.css('left'), 10),
          };

          if (pr && pr.length) {
            $(pr[0]).css({ width: data.width, height: data.height });
          }

          // propagating resize, and updating values for each animation step
          that._updateCache(data);
          that._propagate('resize', event);
        },
      });
    },
  });

  $.ui.plugin.add('resizable', 'containment', {
    start: function() {
      var element,
        p,
        co,
        ch,
        cw,
        width,
        height,
        that = $(this).data('ui-resizable'),
        o = that.options,
        el = that.element,
        oc = o.containment,
        ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;

      if (!ce) {
        return;
      }

      that.containerElement = $(ce);

      if (/document/.test(oc) || oc === document) {
        that.containerOffset = { left: 0, top: 0 };
        that.containerPosition = { left: 0, top: 0 };

        that.parentData = {
          element: $(document),
          left: 0,
          top: 0,
          width: $(document).width(),
          height: $(document).height() || document.body.parentNode.scrollHeight,
        };
      }

      // i'm a node, so compute top, left, right, bottom
      else {
        element = $(ce);
        p = [];
        $(['Top', 'Right', 'Left', 'Bottom']).each(function(i, name) {
          p[i] = num(element.css('padding' + name));
        });

        that.containerOffset = element.offset();
        that.containerPosition = element.position();
        that.containerSize = { height: element.innerHeight() - p[3], width: element.innerWidth() - p[1] };

        co = that.containerOffset;
        ch = that.containerSize.height;
        cw = that.containerSize.width;
        width = $.ui.hasScroll(ce, 'left') ? ce.scrollWidth : cw;
        height = $.ui.hasScroll(ce) ? ce.scrollHeight : ch;

        that.parentData = {
          element: ce,
          left: co.left,
          top: co.top,
          width: width,
          height: height,
        };
      }
    },

    resize: function(event) {
      var woset,
        hoset,
        isParent,
        isOffsetRelative,
        that = $(this).data('ui-resizable'),
        o = that.options,
        co = that.containerOffset,
        cp = that.position,
        pRatio = that._aspectRatio || event.shiftKey,
        cop = { top: 0, left: 0 },
        ce = that.containerElement;

      if (ce[0] !== document && /static/.test(ce.css('position'))) {
        cop = co;
      }

      if (cp.left < (that._helper ? co.left : 0)) {
        that.size.width =
          that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
        }
        that.position.left = o.helper ? co.left : 0;
      }

      if (cp.top < (that._helper ? co.top : 0)) {
        that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
        }
        that.position.top = that._helper ? co.top : 0;
      }

      that.offset.left = that.parentData.left + that.position.left;
      that.offset.top = that.parentData.top + that.position.top;

      woset = Math.abs(
        (that._helper ? that.offset.left - cop.left : that.offset.left - cop.left) + that.sizeDiff.width
      );
      hoset = Math.abs((that._helper ? that.offset.top - cop.top : that.offset.top - co.top) + that.sizeDiff.height);

      isParent = that.containerElement.get(0) === that.element.parent().get(0);
      isOffsetRelative = /relative|absolute/.test(that.containerElement.css('position'));

      if (isParent && isOffsetRelative) {
        woset -= that.parentData.left;
      }

      if (woset + that.size.width >= that.parentData.width) {
        that.size.width = that.parentData.width - woset;
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
        }
      }

      if (hoset + that.size.height >= that.parentData.height) {
        that.size.height = that.parentData.height - hoset;
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
        }
      }
    },

    stop: function() {
      var that = $(this).data('ui-resizable'),
        o = that.options,
        co = that.containerOffset,
        cop = that.containerPosition,
        ce = that.containerElement,
        helper = $(that.helper),
        ho = helper.offset(),
        w = helper.outerWidth() - that.sizeDiff.width,
        h = helper.outerHeight() - that.sizeDiff.height;

      if (that._helper && !o.animate && /relative/.test(ce.css('position'))) {
        $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
      }

      if (that._helper && !o.animate && /static/.test(ce.css('position'))) {
        $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
      }
    },
  });

  $.ui.plugin.add('resizable', 'alsoResize', {
    start: function() {
      var that = $(this).data('ui-resizable'),
        o = that.options,
        _store = function(exp) {
          $(exp).each(function() {
            var el = $(this);
            el.data('ui-resizable-alsoresize', {
              width: parseInt(el.width(), 10),
              height: parseInt(el.height(), 10),
              left: parseInt(el.css('left'), 10),
              top: parseInt(el.css('top'), 10),
            });
          });
        };

      if (typeof o.alsoResize === 'object' && !o.alsoResize.parentNode) {
        if (o.alsoResize.length) {
          o.alsoResize = o.alsoResize[0];
          _store(o.alsoResize);
        } else {
          $.each(o.alsoResize, function(exp) {
            _store(exp);
          });
        }
      } else {
        _store(o.alsoResize);
      }
    },

    resize: function(event, ui) {
      var that = $(this).data('ui-resizable'),
        o = that.options,
        os = that.originalSize,
        op = that.originalPosition,
        delta = {
          height: that.size.height - os.height || 0,
          width: that.size.width - os.width || 0,
          top: that.position.top - op.top || 0,
          left: that.position.left - op.left || 0,
        },
        _alsoResize = function(exp, c) {
          $(exp).each(function() {
            var el = $(this),
              start = $(this).data('ui-resizable-alsoresize'),
              style = {},
              css =
                c && c.length
                  ? c
                  : el.parents(ui.originalElement[0]).length
                  ? ['width', 'height']
                  : ['width', 'height', 'top', 'left'];

            $.each(css, function(i, prop) {
              var sum = (start[prop] || 0) + (delta[prop] || 0);
              if (sum && sum >= 0) {
                style[prop] = sum || null;
              }
            });

            el.css(style);
          });
        };

      if (typeof o.alsoResize === 'object' && !o.alsoResize.nodeType) {
        $.each(o.alsoResize, function(exp, c) {
          _alsoResize(exp, c);
        });
      } else {
        _alsoResize(o.alsoResize);
      }
    },

    stop: function() {
      $(this).removeData('resizable-alsoresize');
    },
  });

  $.ui.plugin.add('resizable', 'ghost', {
    start: function() {
      var that = $(this).data('ui-resizable'),
        o = that.options,
        cs = that.size;

      that.ghost = that.originalElement.clone();
      that.ghost
        .css({
          opacity: 0.25,
          display: 'block',
          position: 'relative',
          height: cs.height,
          width: cs.width,
          margin: 0,
          left: 0,
          top: 0,
        })
        .addClass('ui-resizable-ghost')
        .addClass(typeof o.ghost === 'string' ? o.ghost : '');

      that.ghost.appendTo(that.helper);
    },

    resize: function() {
      var that = $(this).data('ui-resizable');
      if (that.ghost) {
        that.ghost.css({ position: 'relative', height: that.size.height, width: that.size.width });
      }
    },

    stop: function() {
      var that = $(this).data('ui-resizable');
      if (that.ghost && that.helper) {
        that.helper.get(0).removeChild(that.ghost.get(0));
      }
    },
  });

  $.ui.plugin.add('resizable', 'grid', {
    resize: function() {
      var that = $(this).data('ui-resizable'),
        o = that.options,
        cs = that.size,
        os = that.originalSize,
        op = that.originalPosition,
        a = that.axis,
        grid = typeof o.grid === 'number' ? [o.grid, o.grid] : o.grid,
        gridX = grid[0] || 1,
        gridY = grid[1] || 1,
        ox = Math.round((cs.width - os.width) / gridX) * gridX,
        oy = Math.round((cs.height - os.height) / gridY) * gridY,
        newWidth = os.width + ox,
        newHeight = os.height + oy,
        isMaxWidth = o.maxWidth && o.maxWidth < newWidth,
        isMaxHeight = o.maxHeight && o.maxHeight < newHeight,
        isMinWidth = o.minWidth && o.minWidth > newWidth,
        isMinHeight = o.minHeight && o.minHeight > newHeight;

      o.grid = grid;

      if (isMinWidth) {
        newWidth = newWidth + gridX;
      }
      if (isMinHeight) {
        newHeight = newHeight + gridY;
      }
      if (isMaxWidth) {
        newWidth = newWidth - gridX;
      }
      if (isMaxHeight) {
        newHeight = newHeight - gridY;
      }

      if (/^(se|s|e)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
      } else if (/^(ne)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.top = op.top - oy;
      } else if (/^(sw)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.left = op.left - ox;
      } else {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.top = op.top - oy;
        that.position.left = op.left - ox;
      }
    },
  });
})(jQuery);

(function($, undefined) {
  $.widget('ui.selectable', $.ui.mouse, {
    version: '1.10.3',
    options: {
      appendTo: 'body',
      autoRefresh: true,
      distance: 0,
      filter: '*',
      tolerance: 'touch',

      // callbacks
      selected: null,
      selecting: null,
      start: null,
      stop: null,
      unselected: null,
      unselecting: null,
    },
    _create: function() {
      var selectees,
        that = this;

      this.element.addClass('ui-selectable');

      this.dragged = false;

      // cache selectee children based on filter
      this.refresh = function() {
        selectees = $(that.options.filter, that.element[0]);
        selectees.addClass('ui-selectee');
        selectees.each(function() {
          var $this = $(this),
            pos = $this.offset();
          $.data(this, 'selectable-item', {
            element: this,
            $element: $this,
            left: pos.left,
            top: pos.top,
            right: pos.left + $this.outerWidth(),
            bottom: pos.top + $this.outerHeight(),
            startselected: false,
            selected: $this.hasClass('ui-selected'),
            selecting: $this.hasClass('ui-selecting'),
            unselecting: $this.hasClass('ui-unselecting'),
          });
        });
      };
      this.refresh();

      this.selectees = selectees.addClass('ui-selectee');

      this._mouseInit();

      this.helper = $("<div class='ui-selectable-helper'></div>");
    },

    _destroy: function() {
      this.selectees.removeClass('ui-selectee').removeData('selectable-item');
      this.element.removeClass('ui-selectable ui-selectable-disabled');
      this._mouseDestroy();
    },

    _mouseStart: function(event) {
      var that = this,
        options = this.options;

      this.opos = [event.pageX, event.pageY];

      if (this.options.disabled) {
        return;
      }

      this.selectees = $(options.filter, this.element[0]);

      this._trigger('start', event);

      $(options.appendTo).append(this.helper);
      // position helper (lasso)
      this.helper.css({
        left: event.pageX,
        top: event.pageY,
        width: 0,
        height: 0,
      });

      if (options.autoRefresh) {
        this.refresh();
      }

      this.selectees.filter('.ui-selected').each(function() {
        var selectee = $.data(this, 'selectable-item');
        selectee.startselected = true;
        if (!event.metaKey && !event.ctrlKey) {
          selectee.$element.removeClass('ui-selected');
          selectee.selected = false;
          selectee.$element.addClass('ui-unselecting');
          selectee.unselecting = true;
          // selectable UNSELECTING callback
          that._trigger('unselecting', event, {
            unselecting: selectee.element,
          });
        }
      });

      $(event.target)
        .parents()
        .addBack()
        .each(function() {
          var doSelect,
            selectee = $.data(this, 'selectable-item');
          if (selectee) {
            doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass('ui-selected');
            selectee.$element
              .removeClass(doSelect ? 'ui-unselecting' : 'ui-selected')
              .addClass(doSelect ? 'ui-selecting' : 'ui-unselecting');
            selectee.unselecting = !doSelect;
            selectee.selecting = doSelect;
            selectee.selected = doSelect;
            // selectable (UN)SELECTING callback
            if (doSelect) {
              that._trigger('selecting', event, {
                selecting: selectee.element,
              });
            } else {
              that._trigger('unselecting', event, {
                unselecting: selectee.element,
              });
            }
            return false;
          }
        });
    },

    _mouseDrag: function(event) {
      this.dragged = true;

      if (this.options.disabled) {
        return;
      }

      var tmp,
        that = this,
        options = this.options,
        x1 = this.opos[0],
        y1 = this.opos[1],
        x2 = event.pageX,
        y2 = event.pageY;

      if (x1 > x2) {
        tmp = x2;
        x2 = x1;
        x1 = tmp;
      }
      if (y1 > y2) {
        tmp = y2;
        y2 = y1;
        y1 = tmp;
      }
      this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });

      this.selectees.each(function() {
        var selectee = $.data(this, 'selectable-item'),
          hit = false;

        //prevent helper from being selected if appendTo: selectable
        if (!selectee || selectee.element === that.element[0]) {
          return;
        }

        if (options.tolerance === 'touch') {
          hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1);
        } else if (options.tolerance === 'fit') {
          hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2;
        }

        if (hit) {
          // SELECT
          if (selectee.selected) {
            selectee.$element.removeClass('ui-selected');
            selectee.selected = false;
          }
          if (selectee.unselecting) {
            selectee.$element.removeClass('ui-unselecting');
            selectee.unselecting = false;
          }
          if (!selectee.selecting) {
            selectee.$element.addClass('ui-selecting');
            selectee.selecting = true;
            // selectable SELECTING callback
            that._trigger('selecting', event, {
              selecting: selectee.element,
            });
          }
        } else {
          // UNSELECT
          if (selectee.selecting) {
            if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
              selectee.$element.removeClass('ui-selecting');
              selectee.selecting = false;
              selectee.$element.addClass('ui-selected');
              selectee.selected = true;
            } else {
              selectee.$element.removeClass('ui-selecting');
              selectee.selecting = false;
              if (selectee.startselected) {
                selectee.$element.addClass('ui-unselecting');
                selectee.unselecting = true;
              }
              // selectable UNSELECTING callback
              that._trigger('unselecting', event, {
                unselecting: selectee.element,
              });
            }
          }
          if (selectee.selected) {
            if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
              selectee.$element.removeClass('ui-selected');
              selectee.selected = false;

              selectee.$element.addClass('ui-unselecting');
              selectee.unselecting = true;
              // selectable UNSELECTING callback
              that._trigger('unselecting', event, {
                unselecting: selectee.element,
              });
            }
          }
        }
      });

      return false;
    },

    _mouseStop: function(event) {
      var that = this;

      this.dragged = false;

      $('.ui-unselecting', this.element[0]).each(function() {
        var selectee = $.data(this, 'selectable-item');
        selectee.$element.removeClass('ui-unselecting');
        selectee.unselecting = false;
        selectee.startselected = false;
        that._trigger('unselected', event, {
          unselected: selectee.element,
        });
      });
      $('.ui-selecting', this.element[0]).each(function() {
        var selectee = $.data(this, 'selectable-item');
        selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
        selectee.selecting = false;
        selectee.selected = true;
        selectee.startselected = true;
        that._trigger('selected', event, {
          selected: selectee.element,
        });
      });
      this._trigger('stop', event);

      this.helper.remove();

      return false;
    },
  });
})(jQuery);

(function($, undefined) {
  /*jshint loopfunc: true */

  function isOverAxis(x, reference, size) {
    return x > reference && x < reference + size;
  }

  function isFloating(item) {
    return /left|right/.test(item.css('float')) || /inline|table-cell/.test(item.css('display'));
  }

  $.widget('ui.sortable', $.ui.mouse, {
    version: '1.10.3',
    widgetEventPrefix: 'sort',
    ready: false,
    options: {
      appendTo: 'parent',
      axis: false,
      connectWith: false,
      containment: false,
      cursor: 'auto',
      cursorAt: false,
      dropOnEmpty: true,
      forcePlaceholderSize: false,
      forceHelperSize: false,
      grid: false,
      handle: false,
      helper: 'original',
      items: '> *',
      opacity: false,
      placeholder: false,
      revert: false,
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      scope: 'default',
      tolerance: 'intersect',
      zIndex: 1000,

      // callbacks
      activate: null,
      beforeStop: null,
      change: null,
      deactivate: null,
      out: null,
      over: null,
      receive: null,
      remove: null,
      sort: null,
      start: null,
      stop: null,
      update: null,
    },
    _create: function() {
      var o = this.options;
      this.containerCache = {};
      this.element.addClass('ui-sortable');

      //Get the items
      this.refresh();

      //Let's determine if the items are being displayed horizontally
      this.floating = this.items.length ? o.axis === 'x' || isFloating(this.items[0].item) : false;

      //Let's determine the parent's offset
      this.offset = this.element.offset();

      //Initialize mouse events for interaction
      this._mouseInit();

      //We're ready to go
      this.ready = true;
    },

    _destroy: function() {
      this.element.removeClass('ui-sortable ui-sortable-disabled');
      this._mouseDestroy();

      for (var i = this.items.length - 1; i >= 0; i--) {
        this.items[i].item.removeData(this.widgetName + '-item');
      }

      return this;
    },

    _setOption: function(key, value) {
      if (key === 'disabled') {
        this.options[key] = value;

        this.widget().toggleClass('ui-sortable-disabled', !!value);
      } else {
        // Don't call widget base _setOption for disable as it adds ui-state-disabled class
        $.Widget.prototype._setOption.apply(this, arguments);
      }
    },

    _mouseCapture: function(event, overrideHandle) {
      var currentItem = null,
        validHandle = false,
        that = this;

      if (this.reverting) {
        return false;
      }

      if (this.options.disabled || this.options.type === 'static') {
        return false;
      }

      //We have to refresh the items data once first
      this._refreshItems(event);

      //Find out if the clicked node (or one of its parents) is a actual item in this.items
      $(event.target)
        .parents()
        .each(function() {
          if ($.data(this, that.widgetName + '-item') === that) {
            currentItem = $(this);
            return false;
          }
        });
      if ($.data(event.target, that.widgetName + '-item') === that) {
        currentItem = $(event.target);
      }

      if (!currentItem) {
        return false;
      }
      if (this.options.handle && !overrideHandle) {
        $(this.options.handle, currentItem)
          .find('*')
          .addBack()
          .each(function() {
            if (this === event.target) {
              validHandle = true;
            }
          });
        if (!validHandle) {
          return false;
        }
      }

      this.currentItem = currentItem;
      this._removeCurrentsFromItems();
      return true;
    },

    _mouseStart: function(event, overrideHandle, noActivation) {
      var i,
        body,
        o = this.options;

      this.currentContainer = this;

      //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
      this.refreshPositions();

      //Create and append the visible helper
      this.helper = this._createHelper(event);

      //Cache the helper size
      this._cacheHelperProportions();

      /*
       * - Position generation -
       * This block generates everything position related - it's the core of draggables.
       */

      //Cache the margins of the original element
      this._cacheMargins();

      //Get the next scrolling parent
      this.scrollParent = this.helper.scrollParent();

      //The element's absolute position on the page minus margins
      this.offset = this.currentItem.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left,
      };

      $.extend(this.offset, {
        click: {
          //Where the click happened, relative to the element
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top,
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset(), //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
      });

      // Only after we got the offset, we can change the helper's position to absolute
      // TODO: Still need to figure out a way to make relative sorting possible
      this.helper.css('position', 'absolute');
      this.cssPosition = this.helper.css('position');

      //Generate the original position
      this.originalPosition = this._generatePosition(event);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;

      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);

      //Cache the former DOM position
      this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

      //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
      if (this.helper[0] !== this.currentItem[0]) {
        this.currentItem.hide();
      }

      //Create the placeholder
      this._createPlaceholder();

      //Set a containment if given in the options
      if (o.containment) {
        this._setContainment();
      }

      if (o.cursor && o.cursor !== 'auto') {
        // cursor option
        body = this.document.find('body');

        // support: IE
        this.storedCursor = body.css('cursor');
        body.css('cursor', o.cursor);

        this.storedStylesheet = $('<style>*{ cursor: ' + o.cursor + ' !important; }</style>').appendTo(body);
      }

      if (o.opacity) {
        // opacity option
        if (this.helper.css('opacity')) {
          this._storedOpacity = this.helper.css('opacity');
        }
        this.helper.css('opacity', o.opacity);
      }

      if (o.zIndex) {
        // zIndex option
        if (this.helper.css('zIndex')) {
          this._storedZIndex = this.helper.css('zIndex');
        }
        this.helper.css('zIndex', o.zIndex);
      }

      //Prepare scrolling
      if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== 'HTML') {
        this.overflowOffset = this.scrollParent.offset();
      }

      //Call callbacks
      this._trigger('start', event, this._uiHash());

      //Recache the helper size
      if (!this._preserveHelperProportions) {
        this._cacheHelperProportions();
      }

      //Post "activate" events to possible containers
      if (!noActivation) {
        for (i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger('activate', event, this._uiHash(this));
        }
      }

      //Prepare possible droppables
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }

      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }

      this.dragging = true;

      this.helper.addClass('ui-sortable-helper');
      this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
      return true;
    },

    _mouseDrag: function(event) {
      var i,
        item,
        itemElement,
        intersection,
        o = this.options,
        scrolled = false;

      //Compute the helpers position
      this.position = this._generatePosition(event);
      this.positionAbs = this._convertPositionTo('absolute');

      if (!this.lastPositionAbs) {
        this.lastPositionAbs = this.positionAbs;
      }

      //Do scrolling
      if (this.options.scroll) {
        if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== 'HTML') {
          if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
          } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
          }

          if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
          } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
          }
        } else {
          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
          }

          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
          }
        }

        if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
          $.ui.ddmanager.prepareOffsets(this, event);
        }
      }

      //Regenerate the absolute position used for position checks
      this.positionAbs = this._convertPositionTo('absolute');

      //Set the helper position
      if (!this.options.axis || this.options.axis !== 'y') {
        this.helper[0].style.left = this.position.left + 'px';
      }
      if (!this.options.axis || this.options.axis !== 'x') {
        this.helper[0].style.top = this.position.top + 'px';
      }

      //Rearrange
      for (i = this.items.length - 1; i >= 0; i--) {
        //Cache variables and intersection, continue if no intersection
        item = this.items[i];
        itemElement = item.item[0];
        intersection = this._intersectsWithPointer(item);
        if (!intersection) {
          continue;
        }

        // Only put the placeholder inside the current Container, skip all
        // items form other containers. This works because when moving
        // an item from one container to another the
        // currentContainer is switched before the placeholder is moved.
        //
        // Without this moving items in "sub-sortables" can cause the placeholder to jitter
        // beetween the outer and inner container.
        if (item.instance !== this.currentContainer) {
          continue;
        }

        // cannot intersect with itself
        // no useless actions that have been done before
        // no action if the item moved is the parent of the item checked
        if (
          itemElement !== this.currentItem[0] &&
          this.placeholder[intersection === 1 ? 'next' : 'prev']()[0] !== itemElement &&
          !$.contains(this.placeholder[0], itemElement) &&
          (this.options.type === 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)
        ) {
          this.direction = intersection === 1 ? 'down' : 'up';

          if (this.options.tolerance === 'pointer' || this._intersectsWithSides(item)) {
            this._rearrange(event, item);
          } else {
            break;
          }

          this._trigger('change', event, this._uiHash());
          break;
        }
      }

      //Post events to containers
      this._contactContainers(event);

      //Interconnect with droppables
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }

      //Call callbacks
      this._trigger('sort', event, this._uiHash());

      this.lastPositionAbs = this.positionAbs;
      return false;
    },

    _mouseStop: function(event, noPropagation) {
      if (!event) {
        return;
      }

      //If we are using droppables, inform the manager about the drop
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        $.ui.ddmanager.drop(this, event);
      }

      if (this.options.revert) {
        var that = this,
          cur = this.placeholder.offset(),
          axis = this.options.axis,
          animation = {};

        if (!axis || axis === 'x') {
          animation.left =
            cur.left -
            this.offset.parent.left -
            this.margins.left +
            (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
        }
        if (!axis || axis === 'y') {
          animation.top =
            cur.top -
            this.offset.parent.top -
            this.margins.top +
            (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
        }
        this.reverting = true;
        $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
          that._clear(event);
        });
      } else {
        this._clear(event, noPropagation);
      }

      return false;
    },

    cancel: function() {
      if (this.dragging) {
        this._mouseUp({ target: null });

        if (this.options.helper === 'original') {
          this.currentItem.css(this._storedCSS).removeClass('ui-sortable-helper');
        } else {
          this.currentItem.show();
        }

        //Post deactivating events to containers
        for (var i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger('deactivate', null, this._uiHash(this));
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger('out', null, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
      }

      if (this.placeholder) {
        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
        if (this.placeholder[0].parentNode) {
          this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
        }
        if (this.options.helper !== 'original' && this.helper && this.helper[0].parentNode) {
          this.helper.remove();
        }

        $.extend(this, {
          helper: null,
          dragging: false,
          reverting: false,
          _noFinalSort: null,
        });

        if (this.domPosition.prev) {
          $(this.domPosition.prev).after(this.currentItem);
        } else {
          $(this.domPosition.parent).prepend(this.currentItem);
        }
      }

      return this;
    },

    serialize: function(o) {
      var items = this._getItemsAsjQuery(o && o.connected),
        str = [];
      o = o || {};

      $(items).each(function() {
        var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || /(.+)[\-=_](.+)/);
        if (res) {
          str.push((o.key || res[1] + '[]') + '=' + (o.key && o.expression ? res[1] : res[2]));
        }
      });

      if (!str.length && o.key) {
        str.push(o.key + '=');
      }

      return str.join('&');
    },

    toArray: function(o) {
      var items = this._getItemsAsjQuery(o && o.connected),
        ret = [];

      o = o || {};

      items.each(function() {
        ret.push($(o.item || this).attr(o.attribute || 'id') || '');
      });
      return ret;
    },

    /* Be careful with the following core functions */
    _intersectsWith: function(item) {
      var x1 = this.positionAbs.left,
        x2 = x1 + this.helperProportions.width,
        y1 = this.positionAbs.top,
        y2 = y1 + this.helperProportions.height,
        l = item.left,
        r = l + item.width,
        t = item.top,
        b = t + item.height,
        dyClick = this.offset.click.top,
        dxClick = this.offset.click.left,
        isOverElementHeight = this.options.axis === 'x' || (y1 + dyClick > t && y1 + dyClick < b),
        isOverElementWidth = this.options.axis === 'y' || (x1 + dxClick > l && x1 + dxClick < r),
        isOverElement = isOverElementHeight && isOverElementWidth;

      if (
        this.options.tolerance === 'pointer' ||
        this.options.forcePointerForContainers ||
        (this.options.tolerance !== 'pointer' &&
          this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
      ) {
        return isOverElement;
      } else {
        return (
          l < x1 + this.helperProportions.width / 2 && // Right Half
          x2 - this.helperProportions.width / 2 < r && // Left Half
          t < y1 + this.helperProportions.height / 2 && // Bottom Half
          y2 - this.helperProportions.height / 2 < b
        ); // Top Half
      }
    },

    _intersectsWithPointer: function(item) {
      var isOverElementHeight =
          this.options.axis === 'x' || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
        isOverElementWidth =
          this.options.axis === 'y' ||
          isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
        isOverElement = isOverElementHeight && isOverElementWidth,
        verticalDirection = this._getDragVerticalDirection(),
        horizontalDirection = this._getDragHorizontalDirection();

      if (!isOverElement) {
        return false;
      }

      return this.floating
        ? (horizontalDirection && horizontalDirection === 'right') || verticalDirection === 'down'
          ? 2
          : 1
        : verticalDirection && (verticalDirection === 'down' ? 2 : 1);
    },

    _intersectsWithSides: function(item) {
      var isOverBottomHalf = isOverAxis(
          this.positionAbs.top + this.offset.click.top,
          item.top + item.height / 2,
          item.height
        ),
        isOverRightHalf = isOverAxis(
          this.positionAbs.left + this.offset.click.left,
          item.left + item.width / 2,
          item.width
        ),
        verticalDirection = this._getDragVerticalDirection(),
        horizontalDirection = this._getDragHorizontalDirection();

      if (this.floating && horizontalDirection) {
        return (
          (horizontalDirection === 'right' && isOverRightHalf) || (horizontalDirection === 'left' && !isOverRightHalf)
        );
      } else {
        return (
          verticalDirection &&
          ((verticalDirection === 'down' && isOverBottomHalf) || (verticalDirection === 'up' && !isOverBottomHalf))
        );
      }
    },

    _getDragVerticalDirection: function() {
      var delta = this.positionAbs.top - this.lastPositionAbs.top;
      return delta !== 0 && (delta > 0 ? 'down' : 'up');
    },

    _getDragHorizontalDirection: function() {
      var delta = this.positionAbs.left - this.lastPositionAbs.left;
      return delta !== 0 && (delta > 0 ? 'right' : 'left');
    },

    refresh: function(event) {
      this._refreshItems(event);
      this.refreshPositions();
      return this;
    },

    _connectWith: function() {
      var options = this.options;
      return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
    },

    _getItemsAsjQuery: function(connected) {
      var i,
        j,
        cur,
        inst,
        items = [],
        queries = [],
        connectWith = this._connectWith();

      if (connectWith && connected) {
        for (i = connectWith.length - 1; i >= 0; i--) {
          cur = $(connectWith[i]);
          for (j = cur.length - 1; j >= 0; j--) {
            inst = $.data(cur[j], this.widgetFullName);
            if (inst && inst !== this && !inst.options.disabled) {
              queries.push([
                $.isFunction(inst.options.items)
                  ? inst.options.items.call(inst.element)
                  : $(inst.options.items, inst.element)
                      .not('.ui-sortable-helper')
                      .not('.ui-sortable-placeholder'),
                inst,
              ]);
            }
          }
        }
      }

      queries.push([
        $.isFunction(this.options.items)
          ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem })
          : $(this.options.items, this.element)
              .not('.ui-sortable-helper')
              .not('.ui-sortable-placeholder'),
        this,
      ]);

      for (i = queries.length - 1; i >= 0; i--) {
        queries[i][0].each(function() {
          items.push(this);
        });
      }

      return $(items);
    },

    _removeCurrentsFromItems: function() {
      var list = this.currentItem.find(':data(' + this.widgetName + '-item)');

      this.items = $.grep(this.items, function(item) {
        for (var j = 0; j < list.length; j++) {
          if (list[j] === item.item[0]) {
            return false;
          }
        }
        return true;
      });
    },

    _refreshItems: function(event) {
      this.items = [];
      this.containers = [this];

      var i,
        j,
        cur,
        inst,
        targetData,
        _queries,
        item,
        queriesLength,
        items = this.items,
        queries = [
          [
            $.isFunction(this.options.items)
              ? this.options.items.call(this.element[0], event, { item: this.currentItem })
              : $(this.options.items, this.element),
            this,
          ],
        ],
        connectWith = this._connectWith();

      if (connectWith && this.ready) {
        //Shouldn't be run the first time through due to massive slow-down
        for (i = connectWith.length - 1; i >= 0; i--) {
          cur = $(connectWith[i]);
          for (j = cur.length - 1; j >= 0; j--) {
            inst = $.data(cur[j], this.widgetFullName);
            if (inst && inst !== this && !inst.options.disabled) {
              queries.push([
                $.isFunction(inst.options.items)
                  ? inst.options.items.call(inst.element[0], event, { item: this.currentItem })
                  : $(inst.options.items, inst.element),
                inst,
              ]);
              this.containers.push(inst);
            }
          }
        }
      }

      for (i = queries.length - 1; i >= 0; i--) {
        targetData = queries[i][1];
        _queries = queries[i][0];

        for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
          item = $(_queries[j]);

          item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)

          items.push({
            item: item,
            instance: targetData,
            width: 0,
            height: 0,
            left: 0,
            top: 0,
          });
        }
      }
    },

    refreshPositions: function(fast) {
      //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
      if (this.offsetParent && this.helper) {
        this.offset.parent = this._getParentOffset();
      }

      var i, item, t, p;

      for (i = this.items.length - 1; i >= 0; i--) {
        item = this.items[i];

        //We ignore calculating positions of all connected containers when we're not over them
        if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
          continue;
        }

        t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

        if (!fast) {
          item.width = t.outerWidth();
          item.height = t.outerHeight();
        }

        p = t.offset();
        item.left = p.left;
        item.top = p.top;
      }

      if (this.options.custom && this.options.custom.refreshContainers) {
        this.options.custom.refreshContainers.call(this);
      } else {
        for (i = this.containers.length - 1; i >= 0; i--) {
          p = this.containers[i].element.offset();
          this.containers[i].containerCache.left = p.left;
          this.containers[i].containerCache.top = p.top;
          this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
          this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
        }
      }

      return this;
    },

    _createPlaceholder: function(that) {
      that = that || this;
      var className,
        o = that.options;

      if (!o.placeholder || o.placeholder.constructor === String) {
        className = o.placeholder;
        o.placeholder = {
          element: function() {
            var nodeName = that.currentItem[0].nodeName.toLowerCase(),
              element = $('<' + nodeName + '>', that.document[0])
                .addClass(className || that.currentItem[0].className + ' ui-sortable-placeholder')
                .removeClass('ui-sortable-helper');

            if (nodeName === 'tr') {
              that.currentItem.children().each(function() {
                $('<td>&#160;</td>', that.document[0])
                  .attr('colspan', $(this).attr('colspan') || 1)
                  .appendTo(element);
              });
            } else if (nodeName === 'img') {
              element.attr('src', that.currentItem.attr('src'));
            }

            if (!className) {
              element.css('visibility', 'hidden');
            }

            return element;
          },
          update: function(container, p) {
            // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
            // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
            if (className && !o.forcePlaceholderSize) {
              return;
            }

            //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
            if (!p.height()) {
              p.height(
                that.currentItem.innerHeight() -
                  parseInt(that.currentItem.css('paddingTop') || 0, 10) -
                  parseInt(that.currentItem.css('paddingBottom') || 0, 10)
              );
            }
            if (!p.width()) {
              p.width(
                that.currentItem.innerWidth() -
                  parseInt(that.currentItem.css('paddingLeft') || 0, 10) -
                  parseInt(that.currentItem.css('paddingRight') || 0, 10)
              );
            }
          },
        };
      }

      //Create the placeholder
      that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

      //Append it after the actual current item
      that.currentItem.after(that.placeholder);

      //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
      o.placeholder.update(that, that.placeholder);
    },

    _contactContainers: function(event) {
      var i,
        j,
        dist,
        itemWithLeastDistance,
        posProperty,
        sizeProperty,
        base,
        cur,
        nearBottom,
        floating,
        innermostContainer = null,
        innermostIndex = null;

      // get innermost container that intersects with item
      for (i = this.containers.length - 1; i >= 0; i--) {
        // never consider a container that's located within the item itself
        if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
          continue;
        }

        if (this._intersectsWith(this.containers[i].containerCache)) {
          // if we've already found a container and it's more "inner" than this, then continue
          if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
            continue;
          }

          innermostContainer = this.containers[i];
          innermostIndex = i;
        } else {
          // container doesn't intersect. trigger "out" event if necessary
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger('out', event, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
      }

      // if no intersecting containers found, return
      if (!innermostContainer) {
        return;
      }

      // move the item into the container if it's not there already
      if (this.containers.length === 1) {
        if (!this.containers[innermostIndex].containerCache.over) {
          this.containers[innermostIndex]._trigger('over', event, this._uiHash(this));
          this.containers[innermostIndex].containerCache.over = 1;
        }
      } else {
        //When entering a new container, we will find the item with the least distance and append our item near it
        dist = 10000;
        itemWithLeastDistance = null;
        floating = innermostContainer.floating || isFloating(this.currentItem);
        posProperty = floating ? 'left' : 'top';
        sizeProperty = floating ? 'width' : 'height';
        base = this.positionAbs[posProperty] + this.offset.click[posProperty];
        for (j = this.items.length - 1; j >= 0; j--) {
          if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
            continue;
          }
          if (this.items[j].item[0] === this.currentItem[0]) {
            continue;
          }
          if (
            floating &&
            !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)
          ) {
            continue;
          }
          cur = this.items[j].item.offset()[posProperty];
          nearBottom = false;
          if (Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)) {
            nearBottom = true;
            cur += this.items[j][sizeProperty];
          }

          if (Math.abs(cur - base) < dist) {
            dist = Math.abs(cur - base);
            itemWithLeastDistance = this.items[j];
            this.direction = nearBottom ? 'up' : 'down';
          }
        }

        //Check if dropOnEmpty is enabled
        if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
          return;
        }

        if (this.currentContainer === this.containers[innermostIndex]) {
          return;
        }

        itemWithLeastDistance
          ? this._rearrange(event, itemWithLeastDistance, null, true)
          : this._rearrange(event, null, this.containers[innermostIndex].element, true);
        this._trigger('change', event, this._uiHash());
        this.containers[innermostIndex]._trigger('change', event, this._uiHash(this));
        this.currentContainer = this.containers[innermostIndex];

        //Update the placeholder
        this.options.placeholder.update(this.currentContainer, this.placeholder);

        this.containers[innermostIndex]._trigger('over', event, this._uiHash(this));
        this.containers[innermostIndex].containerCache.over = 1;
      }
    },

    _createHelper: function(event) {
      var o = this.options,
        helper = $.isFunction(o.helper)
          ? $(o.helper.apply(this.element[0], [event, this.currentItem]))
          : o.helper === 'clone'
          ? this.currentItem.clone()
          : this.currentItem;

      //Add the helper to the DOM if that didn't happen already
      if (!helper.parents('body').length) {
        $(o.appendTo !== 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
      }

      if (helper[0] === this.currentItem[0]) {
        this._storedCSS = {
          width: this.currentItem[0].style.width,
          height: this.currentItem[0].style.height,
          position: this.currentItem.css('position'),
          top: this.currentItem.css('top'),
          left: this.currentItem.css('left'),
        };
      }

      if (!helper[0].style.width || o.forceHelperSize) {
        helper.width(this.currentItem.width());
      }
      if (!helper[0].style.height || o.forceHelperSize) {
        helper.height(this.currentItem.height());
      }

      return helper;
    },

    _adjustOffsetFromHelper: function(obj) {
      if (typeof obj === 'string') {
        obj = obj.split(' ');
      }
      if ($.isArray(obj)) {
        obj = { left: +obj[0], top: +obj[1] || 0 };
      }
      if ('left' in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ('right' in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ('top' in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ('bottom' in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },

    _getParentOffset: function() {
      //Get the offsetParent and cache its position
      this.offsetParent = this.helper.offsetParent();
      var po = this.offsetParent.offset();

      // This is a special case where we need to modify a offset calculated on start, since the following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
      if (
        this.cssPosition === 'absolute' &&
        this.scrollParent[0] !== document &&
        $.contains(this.scrollParent[0], this.offsetParent[0])
      ) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }

      // This needs to be actually done for all browsers, since pageX/pageY includes this information
      // with an ugly IE fix
      if (
        this.offsetParent[0] === document.body ||
        (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === 'html' && $.ui.ie)
      ) {
        po = { top: 0, left: 0 };
      }

      return {
        top: po.top + (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0),
      };
    },

    _getRelativeOffset: function() {
      if (this.cssPosition === 'relative') {
        var p = this.currentItem.position();
        return {
          top: p.top - (parseInt(this.helper.css('top'), 10) || 0) + this.scrollParent.scrollTop(),
          left: p.left - (parseInt(this.helper.css('left'), 10) || 0) + this.scrollParent.scrollLeft(),
        };
      } else {
        return { top: 0, left: 0 };
      }
    },

    _cacheMargins: function() {
      this.margins = {
        left: parseInt(this.currentItem.css('marginLeft'), 10) || 0,
        top: parseInt(this.currentItem.css('marginTop'), 10) || 0,
      };
    },

    _cacheHelperProportions: function() {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight(),
      };
    },

    _setContainment: function() {
      var ce,
        co,
        over,
        o = this.options;
      if (o.containment === 'parent') {
        o.containment = this.helper[0].parentNode;
      }
      if (o.containment === 'document' || o.containment === 'window') {
        this.containment = [
          0 - this.offset.relative.left - this.offset.parent.left,
          0 - this.offset.relative.top - this.offset.parent.top,
          $(o.containment === 'document' ? document : window).width() -
            this.helperProportions.width -
            this.margins.left,
          ($(o.containment === 'document' ? document : window).height() || document.body.parentNode.scrollHeight) -
            this.helperProportions.height -
            this.margins.top,
        ];
      }

      if (!/^(document|window|parent)$/.test(o.containment)) {
        ce = $(o.containment)[0];
        co = $(o.containment).offset();
        over = $(ce).css('overflow') !== 'hidden';

        this.containment = [
          co.left +
            (parseInt($(ce).css('borderLeftWidth'), 10) || 0) +
            (parseInt($(ce).css('paddingLeft'), 10) || 0) -
            this.margins.left,
          co.top +
            (parseInt($(ce).css('borderTopWidth'), 10) || 0) +
            (parseInt($(ce).css('paddingTop'), 10) || 0) -
            this.margins.top,
          co.left +
            (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) -
            (parseInt($(ce).css('borderLeftWidth'), 10) || 0) -
            (parseInt($(ce).css('paddingRight'), 10) || 0) -
            this.helperProportions.width -
            this.margins.left,
          co.top +
            (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) -
            (parseInt($(ce).css('borderTopWidth'), 10) || 0) -
            (parseInt($(ce).css('paddingBottom'), 10) || 0) -
            this.helperProportions.height -
            this.margins.top,
        ];
      }
    },

    _convertPositionTo: function(d, pos) {
      if (!pos) {
        pos = this.position;
      }
      var mod = d === 'absolute' ? 1 : -1,
        scroll =
          this.cssPosition === 'absolute' &&
          !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]))
            ? this.offsetParent
            : this.scrollParent,
        scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);

      return {
        top:
          pos.top + // The absolute mouse position
          this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
          (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) *
            mod,
        left:
          pos.left + // The absolute mouse position
          this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
          (this.cssPosition === 'fixed'
            ? -this.scrollParent.scrollLeft()
            : scrollIsRootNode
            ? 0
            : scroll.scrollLeft()) *
            mod,
      };
    },

    _generatePosition: function(event) {
      var top,
        left,
        o = this.options,
        pageX = event.pageX,
        pageY = event.pageY,
        scroll =
          this.cssPosition === 'absolute' &&
          !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]))
            ? this.offsetParent
            : this.scrollParent,
        scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);

      // This is another very weird special case that only happens for relative elements:
      // 1. If the css position is relative
      // 2. and the scroll parent is the document or similar to the offset parent
      // we have to refresh the relative offset during the scroll so there are no jumps
      if (
        this.cssPosition === 'relative' &&
        !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])
      ) {
        this.offset.relative = this._getRelativeOffset();
      }

      /*
       * - Position constraining -
       * Constrain the position to a mix of grid, containment.
       */

      if (this.originalPosition) {
        //If we are not dragging yet, we won't check for options

        if (this.containment) {
          if (event.pageX - this.offset.click.left < this.containment[0]) {
            pageX = this.containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < this.containment[1]) {
            pageY = this.containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > this.containment[2]) {
            pageX = this.containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > this.containment[3]) {
            pageY = this.containment[3] + this.offset.click.top;
          }
        }

        if (o.grid) {
          top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
          pageY = this.containment
            ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]
              ? top
              : top - this.offset.click.top >= this.containment[1]
              ? top - o.grid[1]
              : top + o.grid[1]
            : top;

          left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
          pageX = this.containment
            ? left - this.offset.click.left >= this.containment[0] &&
              left - this.offset.click.left <= this.containment[2]
              ? left
              : left - this.offset.click.left >= this.containment[0]
              ? left - o.grid[0]
              : left + o.grid[0]
            : left;
        }
      }

      return {
        top:
          pageY - // The absolute mouse position
          this.offset.click.top - // Click offset (relative to the element)
          this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.top + // The offsetParent's offset without borders (offset + border)
          (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
        left:
          pageX - // The absolute mouse position
          this.offset.click.left - // Click offset (relative to the element)
          this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.parent.left + // The offsetParent's offset without borders (offset + border)
          (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()),
      };
    },

    _rearrange: function(event, i, a, hardRefresh) {
      a
        ? a[0].appendChild(this.placeholder[0])
        : i.item[0].parentNode.insertBefore(
            this.placeholder[0],
            this.direction === 'down' ? i.item[0] : i.item[0].nextSibling
          );

      //Various things done here to improve the performance:
      // 1. we create a setTimeout, that calls refreshPositions
      // 2. on the instance, we have a counter variable, that get's higher after every append
      // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
      // 4. this lets only the last addition to the timeout stack through
      this.counter = this.counter ? ++this.counter : 1;
      var counter = this.counter;

      this._delay(function() {
        if (counter === this.counter) {
          this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
        }
      });
    },

    _clear: function(event, noPropagation) {
      this.reverting = false;
      // We delay all events that have to be triggered to after the point where the placeholder has been removed and
      // everything else normalized again
      var i,
        delayedTriggers = [];

      // We first have to update the dom position of the actual currentItem
      // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
      if (!this._noFinalSort && this.currentItem.parent().length) {
        this.placeholder.before(this.currentItem);
      }
      this._noFinalSort = null;

      if (this.helper[0] === this.currentItem[0]) {
        for (i in this._storedCSS) {
          if (this._storedCSS[i] === 'auto' || this._storedCSS[i] === 'static') {
            this._storedCSS[i] = '';
          }
        }
        this.currentItem.css(this._storedCSS).removeClass('ui-sortable-helper');
      } else {
        this.currentItem.show();
      }

      if (this.fromOutside && !noPropagation) {
        delayedTriggers.push(function(event) {
          this._trigger('receive', event, this._uiHash(this.fromOutside));
        });
      }
      if (
        (this.fromOutside ||
          this.domPosition.prev !== this.currentItem.prev().not('.ui-sortable-helper')[0] ||
          this.domPosition.parent !== this.currentItem.parent()[0]) &&
        !noPropagation
      ) {
        delayedTriggers.push(function(event) {
          this._trigger('update', event, this._uiHash());
        }); //Trigger update callback if the DOM position has changed
      }

      // Check if the items Container has Changed and trigger appropriate
      // events.
      if (this !== this.currentContainer) {
        if (!noPropagation) {
          delayedTriggers.push(function(event) {
            this._trigger('remove', event, this._uiHash());
          });
          delayedTriggers.push(
            function(c) {
              return function(event) {
                c._trigger('receive', event, this._uiHash(this));
              };
            }.call(this, this.currentContainer)
          );
          delayedTriggers.push(
            function(c) {
              return function(event) {
                c._trigger('update', event, this._uiHash(this));
              };
            }.call(this, this.currentContainer)
          );
        }
      }

      //Post events to containers
      for (i = this.containers.length - 1; i >= 0; i--) {
        if (!noPropagation) {
          delayedTriggers.push(
            function(c) {
              return function(event) {
                c._trigger('deactivate', event, this._uiHash(this));
              };
            }.call(this, this.containers[i])
          );
        }
        if (this.containers[i].containerCache.over) {
          delayedTriggers.push(
            function(c) {
              return function(event) {
                c._trigger('out', event, this._uiHash(this));
              };
            }.call(this, this.containers[i])
          );
          this.containers[i].containerCache.over = 0;
        }
      }

      //Do what was originally in plugins
      if (this.storedCursor) {
        this.document.find('body').css('cursor', this.storedCursor);
        this.storedStylesheet.remove();
      }
      if (this._storedOpacity) {
        this.helper.css('opacity', this._storedOpacity);
      }
      if (this._storedZIndex) {
        this.helper.css('zIndex', this._storedZIndex === 'auto' ? '' : this._storedZIndex);
      }

      this.dragging = false;
      if (this.cancelHelperRemoval) {
        if (!noPropagation) {
          this._trigger('beforeStop', event, this._uiHash());
          for (i = 0; i < delayedTriggers.length; i++) {
            delayedTriggers[i].call(this, event);
          } //Trigger all delayed events
          this._trigger('stop', event, this._uiHash());
        }

        this.fromOutside = false;
        return false;
      }

      if (!noPropagation) {
        this._trigger('beforeStop', event, this._uiHash());
      }

      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
      this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

      if (this.helper[0] !== this.currentItem[0]) {
        this.helper.remove();
      }
      this.helper = null;

      if (!noPropagation) {
        for (i = 0; i < delayedTriggers.length; i++) {
          delayedTriggers[i].call(this, event);
        } //Trigger all delayed events
        this._trigger('stop', event, this._uiHash());
      }

      this.fromOutside = false;
      return true;
    },

    _trigger: function() {
      if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
        this.cancel();
      }
    },

    _uiHash: function(_inst) {
      var inst = _inst || this;
      return {
        helper: inst.helper,
        placeholder: inst.placeholder || $([]),
        position: inst.position,
        originalPosition: inst.originalPosition,
        offset: inst.positionAbs,
        item: inst.currentItem,
        sender: _inst ? _inst.element : null,
      };
    },
  });
})(jQuery);

(function($, undefined) {
  var dataSpace = 'ui-effects-';

  $.effects = {
    effect: {},
  };

  /*!
   * jQuery Color Animations v2.1.2
   * https://github.com/jquery/jquery-color
   *
   * Copyright 2013 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * Date: Wed Jan 16 08:47:09 2013 -0600
   */
  (function(jQuery, undefined) {
    var stepHooks =
        'backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor',
      // plusequals test for += 100 -= 100
      rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
      // a set of RE's that can match strings and generate color tuples.
      stringParsers = [
        {
          re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          parse: function(execResult) {
            return [execResult[1], execResult[2], execResult[3], execResult[4]];
          },
        },
        {
          re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          parse: function(execResult) {
            return [execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4]];
          },
        },
        {
          // this regex ignores A-F because it's compared against an already lowercased string
          re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
          parse: function(execResult) {
            return [parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16)];
          },
        },
        {
          // this regex ignores A-F because it's compared against an already lowercased string
          re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
          parse: function(execResult) {
            return [
              parseInt(execResult[1] + execResult[1], 16),
              parseInt(execResult[2] + execResult[2], 16),
              parseInt(execResult[3] + execResult[3], 16),
            ];
          },
        },
        {
          re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          space: 'hsla',
          parse: function(execResult) {
            return [execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4]];
          },
        },
      ],
      // jQuery.Color( )
      color = (jQuery.Color = function(color, green, blue, alpha) {
        return new jQuery.Color.fn.parse(color, green, blue, alpha);
      }),
      spaces = {
        rgba: {
          props: {
            red: {
              idx: 0,
              type: 'byte',
            },
            green: {
              idx: 1,
              type: 'byte',
            },
            blue: {
              idx: 2,
              type: 'byte',
            },
          },
        },

        hsla: {
          props: {
            hue: {
              idx: 0,
              type: 'degrees',
            },
            saturation: {
              idx: 1,
              type: 'percent',
            },
            lightness: {
              idx: 2,
              type: 'percent',
            },
          },
        },
      },
      propTypes = {
        byte: {
          floor: true,
          max: 255,
        },
        percent: {
          max: 1,
        },
        degrees: {
          mod: 360,
          floor: true,
        },
      },
      support = (color.support = {}),
      // element for support tests
      supportElem = jQuery('<p>')[0],
      // colors = jQuery.Color.names
      colors,
      // local aliases of functions called often
      each = jQuery.each;

    // determine rgba support immediately
    supportElem.style.cssText = 'background-color:rgba(1,1,1,.5)';
    support.rgba = supportElem.style.backgroundColor.indexOf('rgba') > -1;

    // define cache name and alpha properties
    // for rgba and hsla spaces
    each(spaces, function(spaceName, space) {
      space.cache = '_' + spaceName;
      space.props.alpha = {
        idx: 3,
        type: 'percent',
        def: 1,
      };
    });

    function clamp(value, prop, allowEmpty) {
      var type = propTypes[prop.type] || {};

      if (value == null) {
        return allowEmpty || !prop.def ? null : prop.def;
      }

      // ~~ is an short way of doing floor for positive numbers
      value = type.floor ? ~~value : parseFloat(value);

      // IE will pass in empty strings as value for alpha,
      // which will hit this case
      if (isNaN(value)) {
        return prop.def;
      }

      if (type.mod) {
        // we add mod before modding to make sure that negatives values
        // get converted properly: -10 -> 350
        return (value + type.mod) % type.mod;
      }

      // for now all property types without mod have min and max
      return 0 > value ? 0 : type.max < value ? type.max : value;
    }

    function stringParse(string) {
      var inst = color(),
        rgba = (inst._rgba = []);

      string = string.toLowerCase();

      each(stringParsers, function(i, parser) {
        var parsed,
          match = parser.re.exec(string),
          values = match && parser.parse(match),
          spaceName = parser.space || 'rgba';

        if (values) {
          parsed = inst[spaceName](values);

          // if this was an rgba parse the assignment might happen twice
          // oh well....
          inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
          rgba = inst._rgba = parsed._rgba;

          // exit each( stringParsers ) here because we matched
          return false;
        }
      });

      // Found a stringParser that handled it
      if (rgba.length) {
        // if this came from a parsed string, force "transparent" when alpha is 0
        // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
        if (rgba.join() === '0,0,0,0') {
          jQuery.extend(rgba, colors.transparent);
        }
        return inst;
      }

      // named colors
      return colors[string];
    }

    color.fn = jQuery.extend(color.prototype, {
      parse: function(red, green, blue, alpha) {
        if (red === undefined) {
          this._rgba = [null, null, null, null];
          return this;
        }
        if (red.jquery || red.nodeType) {
          red = jQuery(red).css(green);
          green = undefined;
        }

        var inst = this,
          type = jQuery.type(red),
          rgba = (this._rgba = []);

        // more than 1 argument specified - assume ( red, green, blue, alpha )
        if (green !== undefined) {
          red = [red, green, blue, alpha];
          type = 'array';
        }

        if (type === 'string') {
          return this.parse(stringParse(red) || colors._default);
        }

        if (type === 'array') {
          each(spaces.rgba.props, function(key, prop) {
            rgba[prop.idx] = clamp(red[prop.idx], prop);
          });
          return this;
        }

        if (type === 'object') {
          if (red instanceof color) {
            each(spaces, function(spaceName, space) {
              if (red[space.cache]) {
                inst[space.cache] = red[space.cache].slice();
              }
            });
          } else {
            each(spaces, function(spaceName, space) {
              var cache = space.cache;
              each(space.props, function(key, prop) {
                // if the cache doesn't exist, and we know how to convert
                if (!inst[cache] && space.to) {
                  // if the value was null, we don't need to copy it
                  // if the key was alpha, we don't need to copy it either
                  if (key === 'alpha' || red[key] == null) {
                    return;
                  }
                  inst[cache] = space.to(inst._rgba);
                }

                // this is the only case where we allow nulls for ALL properties.
                // call clamp with alwaysAllowEmpty
                inst[cache][prop.idx] = clamp(red[key], prop, true);
              });

              // everything defined but alpha?
              if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                // use the default of 1
                inst[cache][3] = 1;
                if (space.from) {
                  inst._rgba = space.from(inst[cache]);
                }
              }
            });
          }
          return this;
        }
      },
      is: function(compare) {
        var is = color(compare),
          same = true,
          inst = this;

        each(spaces, function(_, space) {
          var localCache,
            isCache = is[space.cache];
          if (isCache) {
            localCache = inst[space.cache] || (space.to && space.to(inst._rgba)) || [];
            each(space.props, function(_, prop) {
              if (isCache[prop.idx] != null) {
                same = isCache[prop.idx] === localCache[prop.idx];
                return same;
              }
            });
          }
          return same;
        });
        return same;
      },
      _space: function() {
        var used = [],
          inst = this;
        each(spaces, function(spaceName, space) {
          if (inst[space.cache]) {
            used.push(spaceName);
          }
        });
        return used.pop();
      },
      transition: function(other, distance) {
        var end = color(other),
          spaceName = end._space(),
          space = spaces[spaceName],
          startColor = this.alpha() === 0 ? color('transparent') : this,
          start = startColor[space.cache] || space.to(startColor._rgba),
          result = start.slice();

        end = end[space.cache];
        each(space.props, function(key, prop) {
          var index = prop.idx,
            startValue = start[index],
            endValue = end[index],
            type = propTypes[prop.type] || {};

          // if null, don't override start value
          if (endValue === null) {
            return;
          }
          // if null - use end
          if (startValue === null) {
            result[index] = endValue;
          } else {
            if (type.mod) {
              if (endValue - startValue > type.mod / 2) {
                startValue += type.mod;
              } else if (startValue - endValue > type.mod / 2) {
                startValue -= type.mod;
              }
            }
            result[index] = clamp((endValue - startValue) * distance + startValue, prop);
          }
        });
        return this[spaceName](result);
      },
      blend: function(opaque) {
        // if we are already opaque - return ourself
        if (this._rgba[3] === 1) {
          return this;
        }

        var rgb = this._rgba.slice(),
          a = rgb.pop(),
          blend = color(opaque)._rgba;

        return color(
          jQuery.map(rgb, function(v, i) {
            return (1 - a) * blend[i] + a * v;
          })
        );
      },
      toRgbaString: function() {
        var prefix = 'rgba(',
          rgba = jQuery.map(this._rgba, function(v, i) {
            return v == null ? (i > 2 ? 1 : 0) : v;
          });

        if (rgba[3] === 1) {
          rgba.pop();
          prefix = 'rgb(';
        }

        return prefix + rgba.join() + ')';
      },
      toHslaString: function() {
        var prefix = 'hsla(',
          hsla = jQuery.map(this.hsla(), function(v, i) {
            if (v == null) {
              v = i > 2 ? 1 : 0;
            }

            // catch 1 and 2
            if (i && i < 3) {
              v = Math.round(v * 100) + '%';
            }
            return v;
          });

        if (hsla[3] === 1) {
          hsla.pop();
          prefix = 'hsl(';
        }
        return prefix + hsla.join() + ')';
      },
      toHexString: function(includeAlpha) {
        var rgba = this._rgba.slice(),
          alpha = rgba.pop();

        if (includeAlpha) {
          rgba.push(~~(alpha * 255));
        }

        return (
          '#' +
          jQuery
            .map(rgba, function(v) {
              // default to 0 when nulls exist
              v = (v || 0).toString(16);
              return v.length === 1 ? '0' + v : v;
            })
            .join('')
        );
      },
      toString: function() {
        return this._rgba[3] === 0 ? 'transparent' : this.toRgbaString();
      },
    });
    color.fn.parse.prototype = color.fn;

    // hsla conversions adapted from:
    // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

    function hue2rgb(p, q, h) {
      h = (h + 1) % 1;
      if (h * 6 < 1) {
        return p + (q - p) * h * 6;
      }
      if (h * 2 < 1) {
        return q;
      }
      if (h * 3 < 2) {
        return p + (q - p) * (2 / 3 - h) * 6;
      }
      return p;
    }

    spaces.hsla.to = function(rgba) {
      if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
        return [null, null, null, rgba[3]];
      }
      var r = rgba[0] / 255,
        g = rgba[1] / 255,
        b = rgba[2] / 255,
        a = rgba[3],
        max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        diff = max - min,
        add = max + min,
        l = add * 0.5,
        h,
        s;

      if (min === max) {
        h = 0;
      } else if (r === max) {
        h = (60 * (g - b)) / diff + 360;
      } else if (g === max) {
        h = (60 * (b - r)) / diff + 120;
      } else {
        h = (60 * (r - g)) / diff + 240;
      }

      // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
      // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
      if (diff === 0) {
        s = 0;
      } else if (l <= 0.5) {
        s = diff / add;
      } else {
        s = diff / (2 - add);
      }
      return [Math.round(h) % 360, s, l, a == null ? 1 : a];
    };

    spaces.hsla.from = function(hsla) {
      if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
        return [null, null, null, hsla[3]];
      }
      var h = hsla[0] / 360,
        s = hsla[1],
        l = hsla[2],
        a = hsla[3],
        q = l <= 0.5 ? l * (1 + s) : l + s - l * s,
        p = 2 * l - q;

      return [
        Math.round(hue2rgb(p, q, h + 1 / 3) * 255),
        Math.round(hue2rgb(p, q, h) * 255),
        Math.round(hue2rgb(p, q, h - 1 / 3) * 255),
        a,
      ];
    };

    each(spaces, function(spaceName, space) {
      var props = space.props,
        cache = space.cache,
        to = space.to,
        from = space.from;

      // makes rgba() and hsla()
      color.fn[spaceName] = function(value) {
        // generate a cache for this space if it doesn't exist
        if (to && !this[cache]) {
          this[cache] = to(this._rgba);
        }
        if (value === undefined) {
          return this[cache].slice();
        }

        var ret,
          type = jQuery.type(value),
          arr = type === 'array' || type === 'object' ? value : arguments,
          local = this[cache].slice();

        each(props, function(key, prop) {
          var val = arr[type === 'object' ? key : prop.idx];
          if (val == null) {
            val = local[prop.idx];
          }
          local[prop.idx] = clamp(val, prop);
        });

        if (from) {
          ret = color(from(local));
          ret[cache] = local;
          return ret;
        } else {
          return color(local);
        }
      };

      // makes red() green() blue() alpha() hue() saturation() lightness()
      each(props, function(key, prop) {
        // alpha is included in more than one space
        if (color.fn[key]) {
          return;
        }
        color.fn[key] = function(value) {
          var vtype = jQuery.type(value),
            fn = key === 'alpha' ? (this._hsla ? 'hsla' : 'rgba') : spaceName,
            local = this[fn](),
            cur = local[prop.idx],
            match;

          if (vtype === 'undefined') {
            return cur;
          }

          if (vtype === 'function') {
            value = value.call(this, cur);
            vtype = jQuery.type(value);
          }
          if (value == null && prop.empty) {
            return this;
          }
          if (vtype === 'string') {
            match = rplusequals.exec(value);
            if (match) {
              value = cur + parseFloat(match[2]) * (match[1] === '+' ? 1 : -1);
            }
          }
          local[prop.idx] = value;
          return this[fn](local);
        };
      });
    });

    // add cssHook and .fx.step function for each named hook.
    // accept a space separated string of properties
    color.hook = function(hook) {
      var hooks = hook.split(' ');
      each(hooks, function(i, hook) {
        jQuery.cssHooks[hook] = {
          set: function(elem, value) {
            var parsed,
              curElem,
              backgroundColor = '';

            if (value !== 'transparent' && (jQuery.type(value) !== 'string' || (parsed = stringParse(value)))) {
              value = color(parsed || value);
              if (!support.rgba && value._rgba[3] !== 1) {
                curElem = hook === 'backgroundColor' ? elem.parentNode : elem;
                while ((backgroundColor === '' || backgroundColor === 'transparent') && curElem && curElem.style) {
                  try {
                    backgroundColor = jQuery.css(curElem, 'backgroundColor');
                    curElem = curElem.parentNode;
                  } catch (e) {}
                }

                value = value.blend(
                  backgroundColor && backgroundColor !== 'transparent' ? backgroundColor : '_default'
                );
              }

              value = value.toRgbaString();
            }
            try {
              elem.style[hook] = value;
            } catch (e) {
              // wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
            }
          },
        };
        jQuery.fx.step[hook] = function(fx) {
          if (!fx.colorInit) {
            fx.start = color(fx.elem, hook);
            fx.end = color(fx.end);
            fx.colorInit = true;
          }
          jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
        };
      });
    };

    color.hook(stepHooks);

    jQuery.cssHooks.borderColor = {
      expand: function(value) {
        var expanded = {};

        each(['Top', 'Right', 'Bottom', 'Left'], function(i, part) {
          expanded['border' + part + 'Color'] = value;
        });
        return expanded;
      },
    };

    // Basic color names only.
    // Usage of any of the other color names requires adding yourself or including
    // jquery.color.svg-names.js.
    colors = jQuery.Color.names = {
      // 4.1. Basic color keywords
      aqua: '#00ffff',
      black: '#000000',
      blue: '#0000ff',
      fuchsia: '#ff00ff',
      gray: '#808080',
      green: '#008000',
      lime: '#00ff00',
      maroon: '#800000',
      navy: '#000080',
      olive: '#808000',
      purple: '#800080',
      red: '#ff0000',
      silver: '#c0c0c0',
      teal: '#008080',
      white: '#ffffff',
      yellow: '#ffff00',

      // 4.2.3. "transparent" color keyword
      transparent: [null, null, null, 0],

      _default: '#ffffff',
    };
  })(jQuery);

  /******************************************************************************/
  /****************************** CLASS ANIMATIONS ******************************/
  /******************************************************************************/
  (function() {
    var classAnimationActions = ['add', 'remove', 'toggle'],
      shorthandStyles = {
        border: 1,
        borderBottom: 1,
        borderColor: 1,
        borderLeft: 1,
        borderRight: 1,
        borderTop: 1,
        borderWidth: 1,
        margin: 1,
        padding: 1,
      };

    $.each(['borderLeftStyle', 'borderRightStyle', 'borderBottomStyle', 'borderTopStyle'], function(_, prop) {
      $.fx.step[prop] = function(fx) {
        if ((fx.end !== 'none' && !fx.setAttr) || (fx.pos === 1 && !fx.setAttr)) {
          jQuery.style(fx.elem, prop, fx.end);
          fx.setAttr = true;
        }
      };
    });

    function getElementStyles(elem) {
      var key,
        len,
        style = elem.ownerDocument.defaultView
          ? elem.ownerDocument.defaultView.getComputedStyle(elem, null)
          : elem.currentStyle,
        styles = {};

      if (style && style.length && style[0] && style[style[0]]) {
        len = style.length;
        while (len--) {
          key = style[len];
          if (typeof style[key] === 'string') {
            styles[$.camelCase(key)] = style[key];
          }
        }
        // support: Opera, IE <9
      } else {
        for (key in style) {
          if (typeof style[key] === 'string') {
            styles[key] = style[key];
          }
        }
      }

      return styles;
    }

    function styleDifference(oldStyle, newStyle) {
      var diff = {},
        name,
        value;

      for (name in newStyle) {
        value = newStyle[name];
        if (oldStyle[name] !== value) {
          if (!shorthandStyles[name]) {
            if ($.fx.step[name] || !isNaN(parseFloat(value))) {
              diff[name] = value;
            }
          }
        }
      }

      return diff;
    }

    // support: jQuery <1.8
    if (!$.fn.addBack) {
      $.fn.addBack = function(selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      };
    }

    $.effects.animateClass = function(value, duration, easing, callback) {
      var o = $.speed(duration, easing, callback);

      return this.queue(function() {
        var animated = $(this),
          baseClass = animated.attr('class') || '',
          applyClassChange,
          allAnimations = o.children ? animated.find('*').addBack() : animated;

        // map the animated objects to store the original styles.
        allAnimations = allAnimations.map(function() {
          var el = $(this);
          return {
            el: el,
            start: getElementStyles(this),
          };
        });

        // apply class change
        applyClassChange = function() {
          $.each(classAnimationActions, function(i, action) {
            if (value[action]) {
              animated[action + 'Class'](value[action]);
            }
          });
        };
        applyClassChange();

        // map all animated objects again - calculate new styles and diff
        allAnimations = allAnimations.map(function() {
          this.end = getElementStyles(this.el[0]);
          this.diff = styleDifference(this.start, this.end);
          return this;
        });

        // apply original class
        animated.attr('class', baseClass);

        // map all animated objects again - this time collecting a promise
        allAnimations = allAnimations.map(function() {
          var styleInfo = this,
            dfd = $.Deferred(),
            opts = $.extend({}, o, {
              queue: false,
              complete: function() {
                dfd.resolve(styleInfo);
              },
            });

          this.el.animate(this.diff, opts);
          return dfd.promise();
        });

        // once all animations have completed:
        $.when.apply($, allAnimations.get()).done(function() {
          // set the final class
          applyClassChange();

          // for each animated element,
          // clear all css properties that were animated
          $.each(arguments, function() {
            var el = this.el;
            $.each(this.diff, function(key) {
              el.css(key, '');
            });
          });

          // this is guarnteed to be there if you use jQuery.speed()
          // it also handles dequeuing the next anim...
          o.complete.call(animated[0]);
        });
      });
    };

    $.fn.extend({
      addClass: (function(orig) {
        return function(classNames, speed, easing, callback) {
          return speed
            ? $.effects.animateClass.call(this, { add: classNames }, speed, easing, callback)
            : orig.apply(this, arguments);
        };
      })($.fn.addClass),

      removeClass: (function(orig) {
        return function(classNames, speed, easing, callback) {
          return arguments.length > 1
            ? $.effects.animateClass.call(this, { remove: classNames }, speed, easing, callback)
            : orig.apply(this, arguments);
        };
      })($.fn.removeClass),

      toggleClass: (function(orig) {
        return function(classNames, force, speed, easing, callback) {
          if (typeof force === 'boolean' || force === undefined) {
            if (!speed) {
              // without speed parameter
              return orig.apply(this, arguments);
            } else {
              return $.effects.animateClass.call(
                this,
                force ? { add: classNames } : { remove: classNames },
                speed,
                easing,
                callback
              );
            }
          } else {
            // without force parameter
            return $.effects.animateClass.call(this, { toggle: classNames }, force, speed, easing);
          }
        };
      })($.fn.toggleClass),

      switchClass: function(remove, add, speed, easing, callback) {
        return $.effects.animateClass.call(
          this,
          {
            add: add,
            remove: remove,
          },
          speed,
          easing,
          callback
        );
      },
    });
  })();

  /******************************************************************************/
  /*********************************** EFFECTS **********************************/
  /******************************************************************************/

  (function() {
    $.extend($.effects, {
      version: '1.10.3',

      // Saves a set of properties in a data storage
      save: function(element, set) {
        for (var i = 0; i < set.length; i++) {
          if (set[i] !== null) {
            element.data(dataSpace + set[i], element[0].style[set[i]]);
          }
        }
      },

      // Restores a set of previously saved properties from a data storage
      restore: function(element, set) {
        var val, i;
        for (i = 0; i < set.length; i++) {
          if (set[i] !== null) {
            val = element.data(dataSpace + set[i]);
            // support: jQuery 1.6.2
            // http://bugs.jquery.com/ticket/9917
            // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
            // We can't differentiate between "" and 0 here, so we just assume
            // empty string since it's likely to be a more common value...
            if (val === undefined) {
              val = '';
            }
            element.css(set[i], val);
          }
        }
      },

      setMode: function(el, mode) {
        if (mode === 'toggle') {
          mode = el.is(':hidden') ? 'show' : 'hide';
        }
        return mode;
      },

      // Translates a [top,left] array into a baseline value
      // this should be a little more flexible in the future to handle a string & hash
      getBaseline: function(origin, original) {
        var y, x;
        switch (origin[0]) {
          case 'top':
            y = 0;
            break;
          case 'middle':
            y = 0.5;
            break;
          case 'bottom':
            y = 1;
            break;
          default:
            y = origin[0] / original.height;
        }
        switch (origin[1]) {
          case 'left':
            x = 0;
            break;
          case 'center':
            x = 0.5;
            break;
          case 'right':
            x = 1;
            break;
          default:
            x = origin[1] / original.width;
        }
        return {
          x: x,
          y: y,
        };
      },

      // Wraps the element around a wrapper that copies position properties
      createWrapper: function(element) {
        // if the element is already wrapped, return it
        if (element.parent().is('.ui-effects-wrapper')) {
          return element.parent();
        }

        // wrap the element
        var props = {
            width: element.outerWidth(true),
            height: element.outerHeight(true),
            float: element.css('float'),
          },
          wrapper = $('<div></div>')
            .addClass('ui-effects-wrapper')
            .css({
              fontSize: '100%',
              background: 'transparent',
              border: 'none',
              margin: 0,
              padding: 0,
            }),
          // Store the size in case width/height are defined in % - Fixes #5245
          size = {
            width: element.width(),
            height: element.height(),
          },
          active = document.activeElement;

        // support: Firefox
        // Firefox incorrectly exposes anonymous content
        // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
        try {
          active.id;
        } catch (e) {
          active = document.body;
        }

        element.wrap(wrapper);

        // Fixes #7595 - Elements lose focus when wrapped.
        if (element[0] === active || $.contains(element[0], active)) {
          $(active).focus();
        }

        wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

        // transfer positioning properties to the wrapper
        if (element.css('position') === 'static') {
          wrapper.css({ position: 'relative' });
          element.css({ position: 'relative' });
        } else {
          $.extend(props, {
            position: element.css('position'),
            zIndex: element.css('z-index'),
          });
          $.each(['top', 'left', 'bottom', 'right'], function(i, pos) {
            props[pos] = element.css(pos);
            if (isNaN(parseInt(props[pos], 10))) {
              props[pos] = 'auto';
            }
          });
          element.css({
            position: 'relative',
            top: 0,
            left: 0,
            right: 'auto',
            bottom: 'auto',
          });
        }
        element.css(size);

        return wrapper.css(props).show();
      },

      removeWrapper: function(element) {
        var active = document.activeElement;

        if (element.parent().is('.ui-effects-wrapper')) {
          element.parent().replaceWith(element);

          // Fixes #7595 - Elements lose focus when wrapped.
          if (element[0] === active || $.contains(element[0], active)) {
            $(active).focus();
          }
        }

        return element;
      },

      setTransition: function(element, list, factor, value) {
        value = value || {};
        $.each(list, function(i, x) {
          var unit = element.cssUnit(x);
          if (unit[0] > 0) {
            value[x] = unit[0] * factor + unit[1];
          }
        });
        return value;
      },
    });

    // return an effect options object for the given parameters:
    function _normalizeArguments(effect, options, speed, callback) {
      // allow passing all options as the first parameter
      if ($.isPlainObject(effect)) {
        options = effect;
        effect = effect.effect;
      }

      // convert to an object
      effect = { effect: effect };

      // catch (effect, null, ...)
      if (options == null) {
        options = {};
      }

      // catch (effect, callback)
      if ($.isFunction(options)) {
        callback = options;
        speed = null;
        options = {};
      }

      // catch (effect, speed, ?)
      if (typeof options === 'number' || $.fx.speeds[options]) {
        callback = speed;
        speed = options;
        options = {};
      }

      // catch (effect, options, callback)
      if ($.isFunction(speed)) {
        callback = speed;
        speed = null;
      }

      // add options to effect
      if (options) {
        $.extend(effect, options);
      }

      speed = speed || options.duration;
      effect.duration = $.fx.off
        ? 0
        : typeof speed === 'number'
        ? speed
        : speed in $.fx.speeds
        ? $.fx.speeds[speed]
        : $.fx.speeds._default;

      effect.complete = callback || options.complete;

      return effect;
    }

    function standardAnimationOption(option) {
      // Valid standard speeds (nothing, number, named speed)
      if (!option || typeof option === 'number' || $.fx.speeds[option]) {
        return true;
      }

      // Invalid strings - treat as "normal" speed
      if (typeof option === 'string' && !$.effects.effect[option]) {
        return true;
      }

      // Complete callback
      if ($.isFunction(option)) {
        return true;
      }

      // Options hash (but not naming an effect)
      if (typeof option === 'object' && !option.effect) {
        return true;
      }

      // Didn't match any standard API
      return false;
    }

    $.fn.extend({
      effect: function(/* effect, options, speed, callback */) {
        var args = _normalizeArguments.apply(this, arguments),
          mode = args.mode,
          queue = args.queue,
          effectMethod = $.effects.effect[args.effect];

        if ($.fx.off || !effectMethod) {
          // delegate to the original method (e.g., .show()) if possible
          if (mode) {
            return this[mode](args.duration, args.complete);
          } else {
            return this.each(function() {
              if (args.complete) {
                args.complete.call(this);
              }
            });
          }
        }

        function run(next) {
          var elem = $(this),
            complete = args.complete,
            mode = args.mode;

          function done() {
            if ($.isFunction(complete)) {
              complete.call(elem[0]);
            }
            if ($.isFunction(next)) {
              next();
            }
          }

          // If the element already has the correct final state, delegate to
          // the core methods so the internal tracking of "olddisplay" works.
          if (elem.is(':hidden') ? mode === 'hide' : mode === 'show') {
            elem[mode]();
            done();
          } else {
            effectMethod.call(elem[0], args, done);
          }
        }

        return queue === false ? this.each(run) : this.queue(queue || 'fx', run);
      },

      show: (function(orig) {
        return function(option) {
          if (standardAnimationOption(option)) {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'show';
            return this.effect.call(this, args);
          }
        };
      })($.fn.show),

      hide: (function(orig) {
        return function(option) {
          if (standardAnimationOption(option)) {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'hide';
            return this.effect.call(this, args);
          }
        };
      })($.fn.hide),

      toggle: (function(orig) {
        return function(option) {
          if (standardAnimationOption(option) || typeof option === 'boolean') {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'toggle';
            return this.effect.call(this, args);
          }
        };
      })($.fn.toggle),

      // helper functions
      cssUnit: function(key) {
        var style = this.css(key),
          val = [];

        $.each(['em', 'px', '%', 'pt'], function(i, unit) {
          if (style.indexOf(unit) > 0) {
            val = [parseFloat(style), unit];
          }
        });
        return val;
      },
    });
  })();

  /******************************************************************************/
  /*********************************** EASING ***********************************/
  /******************************************************************************/

  (function() {
    // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

    var baseEasings = {};

    $.each(['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'], function(i, name) {
      baseEasings[name] = function(p) {
        return Math.pow(p, i + 2);
      };
    });

    $.extend(baseEasings, {
      Sine: function(p) {
        return 1 - Math.cos((p * Math.PI) / 2);
      },
      Circ: function(p) {
        return 1 - Math.sqrt(1 - p * p);
      },
      Elastic: function(p) {
        return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin((((p - 1) * 80 - 7.5) * Math.PI) / 15);
      },
      Back: function(p) {
        return p * p * (3 * p - 2);
      },
      Bounce: function(p) {
        var pow2,
          bounce = 4;

        while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
        return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
      },
    });

    $.each(baseEasings, function(name, easeIn) {
      $.easing['easeIn' + name] = easeIn;
      $.easing['easeOut' + name] = function(p) {
        return 1 - easeIn(1 - p);
      };
      $.easing['easeInOut' + name] = function(p) {
        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
      };
    });
  })();
})(jQuery);

(function($, undefined) {
  var uid = 0,
    hideProps = {},
    showProps = {};

  hideProps.height = hideProps.paddingTop = hideProps.paddingBottom = hideProps.borderTopWidth = hideProps.borderBottomWidth =
    'hide';
  showProps.height = showProps.paddingTop = showProps.paddingBottom = showProps.borderTopWidth = showProps.borderBottomWidth =
    'show';

  $.widget('ui.accordion', {
    version: '1.10.3',
    options: {
      active: 0,
      animate: {},
      collapsible: false,
      event: 'click',
      header: '> li > :first-child,> :not(li):even',
      heightStyle: 'auto',
      icons: {
        activeHeader: 'ui-icon-triangle-1-s',
        header: 'ui-icon-triangle-1-e',
      },

      // callbacks
      activate: null,
      beforeActivate: null,
    },

    _create: function() {
      var options = this.options;
      this.prevShow = this.prevHide = $();
      this.element
        .addClass('ui-accordion ui-widget ui-helper-reset')
        // ARIA
        .attr('role', 'tablist');

      // don't allow collapsible: false and active: false / null
      if (!options.collapsible && (options.active === false || options.active == null)) {
        options.active = 0;
      }

      this._processPanels();
      // handle negative values
      if (options.active < 0) {
        options.active += this.headers.length;
      }
      this._refresh();
    },

    _getCreateEventData: function() {
      return {
        header: this.active,
        panel: !this.active.length ? $() : this.active.next(),
        content: !this.active.length ? $() : this.active.next(),
      };
    },

    _createIcons: function() {
      var icons = this.options.icons;
      if (icons) {
        $('<span>')
          .addClass('ui-accordion-header-icon ui-icon ' + icons.header)
          .prependTo(this.headers);
        this.active
          .children('.ui-accordion-header-icon')
          .removeClass(icons.header)
          .addClass(icons.activeHeader);
        this.headers.addClass('ui-accordion-icons');
      }
    },

    _destroyIcons: function() {
      this.headers
        .removeClass('ui-accordion-icons')
        .children('.ui-accordion-header-icon')
        .remove();
    },

    _destroy: function() {
      var contents;

      // clean up main element
      this.element.removeClass('ui-accordion ui-widget ui-helper-reset').removeAttr('role');

      // clean up headers
      this.headers
        .removeClass(
          'ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top'
        )
        .removeAttr('role')
        .removeAttr('aria-selected')
        .removeAttr('aria-controls')
        .removeAttr('tabIndex')
        .each(function() {
          if (/^ui-accordion/.test(this.id)) {
            this.removeAttribute('id');
          }
        });
      this._destroyIcons();

      // clean up content panels
      contents = this.headers
        .next()
        .css('display', '')
        .removeAttr('role')
        .removeAttr('aria-expanded')
        .removeAttr('aria-hidden')
        .removeAttr('aria-labelledby')
        .removeClass(
          'ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled'
        )
        .each(function() {
          if (/^ui-accordion/.test(this.id)) {
            this.removeAttribute('id');
          }
        });
      if (this.options.heightStyle !== 'content') {
        contents.css('height', '');
      }
    },

    _setOption: function(key, value) {
      if (key === 'active') {
        // _activate() will handle invalid values and update this.options
        this._activate(value);
        return;
      }

      if (key === 'event') {
        if (this.options.event) {
          this._off(this.headers, this.options.event);
        }
        this._setupEvents(value);
      }

      this._super(key, value);

      // setting collapsible: false while collapsed; open first panel
      if (key === 'collapsible' && !value && this.options.active === false) {
        this._activate(0);
      }

      if (key === 'icons') {
        this._destroyIcons();
        if (value) {
          this._createIcons();
        }
      }

      // #5332 - opacity doesn't cascade to positioned elements in IE
      // so we need to add the disabled class to the headers and panels
      if (key === 'disabled') {
        this.headers.add(this.headers.next()).toggleClass('ui-state-disabled', !!value);
      }
    },

    _keydown: function(event) {
      /*jshint maxcomplexity:15*/
      if (event.altKey || event.ctrlKey) {
        return;
      }

      var keyCode = $.ui.keyCode,
        length = this.headers.length,
        currentIndex = this.headers.index(event.target),
        toFocus = false;

      switch (event.keyCode) {
        case keyCode.RIGHT:
        case keyCode.DOWN:
          toFocus = this.headers[(currentIndex + 1) % length];
          break;
        case keyCode.LEFT:
        case keyCode.UP:
          toFocus = this.headers[(currentIndex - 1 + length) % length];
          break;
        case keyCode.SPACE:
        case keyCode.ENTER:
          this._eventHandler(event);
          break;
        case keyCode.HOME:
          toFocus = this.headers[0];
          break;
        case keyCode.END:
          toFocus = this.headers[length - 1];
          break;
      }

      if (toFocus) {
        $(event.target).attr('tabIndex', -1);
        $(toFocus).attr('tabIndex', 0);
        toFocus.focus();
        event.preventDefault();
      }
    },

    _panelKeyDown: function(event) {
      if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
        $(event.currentTarget)
          .prev()
          .focus();
      }
    },

    refresh: function() {
      var options = this.options;
      this._processPanels();

      // was collapsed or no panel
      if ((options.active === false && options.collapsible === true) || !this.headers.length) {
        options.active = false;
        this.active = $();
        // active false only when collapsible is true
      } else if (options.active === false) {
        this._activate(0);
        // was active, but active panel is gone
      } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
        // all remaining panel are disabled
        if (this.headers.length === this.headers.find('.ui-state-disabled').length) {
          options.active = false;
          this.active = $();
          // activate previous panel
        } else {
          this._activate(Math.max(0, options.active - 1));
        }
        // was active, active panel still exists
      } else {
        // make sure active index is correct
        options.active = this.headers.index(this.active);
      }

      this._destroyIcons();

      this._refresh();
    },

    _processPanels: function() {
      this.headers = this.element
        .find(this.options.header)
        .addClass('ui-accordion-header ui-helper-reset ui-state-default ui-corner-all');

      this.headers
        .next()
        .addClass('ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom')
        .filter(':not(.ui-accordion-content-active)')
        .hide();
    },

    _refresh: function() {
      var maxHeight,
        options = this.options,
        heightStyle = options.heightStyle,
        parent = this.element.parent(),
        accordionId = (this.accordionId = 'ui-accordion-' + (this.element.attr('id') || ++uid));

      this.active = this._findActive(options.active)
        .addClass('ui-accordion-header-active ui-state-active ui-corner-top')
        .removeClass('ui-corner-all');
      this.active
        .next()
        .addClass('ui-accordion-content-active')
        .show();

      this.headers
        .attr('role', 'tab')
        .each(function(i) {
          var header = $(this),
            headerId = header.attr('id'),
            panel = header.next(),
            panelId = panel.attr('id');
          if (!headerId) {
            headerId = accordionId + '-header-' + i;
            header.attr('id', headerId);
          }
          if (!panelId) {
            panelId = accordionId + '-panel-' + i;
            panel.attr('id', panelId);
          }
          header.attr('aria-controls', panelId);
          panel.attr('aria-labelledby', headerId);
        })
        .next()
        .attr('role', 'tabpanel');

      this.headers
        .not(this.active)
        .attr({
          'aria-selected': 'false',
          tabIndex: -1,
        })
        .next()
        .attr({
          'aria-expanded': 'false',
          'aria-hidden': 'true',
        })
        .hide();

      // make sure at least one header is in the tab order
      if (!this.active.length) {
        this.headers.eq(0).attr('tabIndex', 0);
      } else {
        this.active
          .attr({
            'aria-selected': 'true',
            tabIndex: 0,
          })
          .next()
          .attr({
            'aria-expanded': 'true',
            'aria-hidden': 'false',
          });
      }

      this._createIcons();

      this._setupEvents(options.event);

      if (heightStyle === 'fill') {
        maxHeight = parent.height();
        this.element.siblings(':visible').each(function() {
          var elem = $(this),
            position = elem.css('position');

          if (position === 'absolute' || position === 'fixed') {
            return;
          }
          maxHeight -= elem.outerHeight(true);
        });

        this.headers.each(function() {
          maxHeight -= $(this).outerHeight(true);
        });

        this.headers
          .next()
          .each(function() {
            $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
          })
          .css('overflow', 'auto');
      } else if (heightStyle === 'auto') {
        maxHeight = 0;
        this.headers
          .next()
          .each(function() {
            maxHeight = Math.max(
              maxHeight,
              $(this)
                .css('height', '')
                .height()
            );
          })
          .height(maxHeight);
      }
    },

    _activate: function(index) {
      var active = this._findActive(index)[0];

      // trying to activate the already active panel
      if (active === this.active[0]) {
        return;
      }

      // trying to collapse, simulate a click on the currently active header
      active = active || this.active[0];

      this._eventHandler({
        target: active,
        currentTarget: active,
        preventDefault: $.noop,
      });
    },

    _findActive: function(selector) {
      return typeof selector === 'number' ? this.headers.eq(selector) : $();
    },

    _setupEvents: function(event) {
      var events = {
        keydown: '_keydown',
      };
      if (event) {
        $.each(event.split(' '), function(index, eventName) {
          events[eventName] = '_eventHandler';
        });
      }

      this._off(this.headers.add(this.headers.next()));
      this._on(this.headers, events);
      this._on(this.headers.next(), { keydown: '_panelKeyDown' });
      this._hoverable(this.headers);
      this._focusable(this.headers);
    },

    _eventHandler: function(event) {
      var options = this.options,
        active = this.active,
        clicked = $(event.currentTarget),
        clickedIsActive = clicked[0] === active[0],
        collapsing = clickedIsActive && options.collapsible,
        toShow = collapsing ? $() : clicked.next(),
        toHide = active.next(),
        eventData = {
          oldHeader: active,
          oldPanel: toHide,
          newHeader: collapsing ? $() : clicked,
          newPanel: toShow,
        };

      event.preventDefault();

      if (
        // click on active header, but not collapsible
        (clickedIsActive && !options.collapsible) ||
        // allow canceling activation
        this._trigger('beforeActivate', event, eventData) === false
      ) {
        return;
      }

      options.active = collapsing ? false : this.headers.index(clicked);

      // when the call to ._toggle() comes after the class changes
      // it causes a very odd bug in IE 8 (see #6720)
      this.active = clickedIsActive ? $() : clicked;
      this._toggle(eventData);

      // switch classes
      // corner classes on the previously active header stay after the animation
      active.removeClass('ui-accordion-header-active ui-state-active');
      if (options.icons) {
        active
          .children('.ui-accordion-header-icon')
          .removeClass(options.icons.activeHeader)
          .addClass(options.icons.header);
      }

      if (!clickedIsActive) {
        clicked.removeClass('ui-corner-all').addClass('ui-accordion-header-active ui-state-active ui-corner-top');
        if (options.icons) {
          clicked
            .children('.ui-accordion-header-icon')
            .removeClass(options.icons.header)
            .addClass(options.icons.activeHeader);
        }

        clicked.next().addClass('ui-accordion-content-active');
      }
    },

    _toggle: function(data) {
      var toShow = data.newPanel,
        toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

      // handle activating a panel during the animation for another activation
      this.prevShow.add(this.prevHide).stop(true, true);
      this.prevShow = toShow;
      this.prevHide = toHide;

      if (this.options.animate) {
        this._animate(toShow, toHide, data);
      } else {
        toHide.hide();
        toShow.show();
        this._toggleComplete(data);
      }

      toHide.attr({
        'aria-expanded': 'false',
        'aria-hidden': 'true',
      });
      toHide.prev().attr('aria-selected', 'false');
      // if we're switching panels, remove the old header from the tab order
      // if we're opening from collapsed state, remove the previous header from the tab order
      // if we're collapsing, then keep the collapsing header in the tab order
      if (toShow.length && toHide.length) {
        toHide.prev().attr('tabIndex', -1);
      } else if (toShow.length) {
        this.headers
          .filter(function() {
            return $(this).attr('tabIndex') === 0;
          })
          .attr('tabIndex', -1);
      }

      toShow
        .attr({
          'aria-expanded': 'true',
          'aria-hidden': 'false',
        })
        .prev()
        .attr({
          'aria-selected': 'true',
          tabIndex: 0,
        });
    },

    _animate: function(toShow, toHide, data) {
      var total,
        easing,
        duration,
        that = this,
        adjust = 0,
        down = toShow.length && (!toHide.length || toShow.index() < toHide.index()),
        animate = this.options.animate || {},
        options = (down && animate.down) || animate,
        complete = function() {
          that._toggleComplete(data);
        };

      if (typeof options === 'number') {
        duration = options;
      }
      if (typeof options === 'string') {
        easing = options;
      }
      // fall back from options to animation in case of partial down settings
      easing = easing || options.easing || animate.easing;
      duration = duration || options.duration || animate.duration;

      if (!toHide.length) {
        return toShow.animate(showProps, duration, easing, complete);
      }
      if (!toShow.length) {
        return toHide.animate(hideProps, duration, easing, complete);
      }

      total = toShow.show().outerHeight();
      toHide.animate(hideProps, {
        duration: duration,
        easing: easing,
        step: function(now, fx) {
          fx.now = Math.round(now);
        },
      });
      toShow.hide().animate(showProps, {
        duration: duration,
        easing: easing,
        complete: complete,
        step: function(now, fx) {
          fx.now = Math.round(now);
          if (fx.prop !== 'height') {
            adjust += fx.now;
          } else if (that.options.heightStyle !== 'content') {
            fx.now = Math.round(total - toHide.outerHeight() - adjust);
            adjust = 0;
          }
        },
      });
    },

    _toggleComplete: function(data) {
      var toHide = data.oldPanel;

      toHide
        .removeClass('ui-accordion-content-active')
        .prev()
        .removeClass('ui-corner-top')
        .addClass('ui-corner-all');

      // Work around for rendering bug in IE (#5421)
      if (toHide.length) {
        toHide.parent()[0].className = toHide.parent()[0].className;
      }

      this._trigger('activate', null, data);
    },
  });
})(jQuery);

(function($, undefined) {
  // used to prevent race conditions with remote data sources
  var requestIndex = 0;

  $.widget('ui.autocomplete', {
    version: '1.10.3',
    defaultElement: '<input>',
    options: {
      appendTo: null,
      autoFocus: false,
      delay: 300,
      minLength: 1,
      position: {
        my: 'left top',
        at: 'left bottom',
        collision: 'none',
      },
      source: null,

      // callbacks
      change: null,
      close: null,
      focus: null,
      open: null,
      response: null,
      search: null,
      select: null,
    },

    pending: 0,

    _create: function() {
      // Some browsers only repeat keydown events, not keypress events,
      // so we use the suppressKeyPress flag to determine if we've already
      // handled the keydown event. #7269
      // Unfortunately the code for & in keypress is the same as the up arrow,
      // so we use the suppressKeyPressRepeat flag to avoid handling keypress
      // events when we know the keydown event was used to modify the
      // search term. #7799
      var suppressKeyPress,
        suppressKeyPressRepeat,
        suppressInput,
        nodeName = this.element[0].nodeName.toLowerCase(),
        isTextarea = nodeName === 'textarea',
        isInput = nodeName === 'input';

      this.isMultiLine =
        // Textareas are always multi-line
        isTextarea
          ? true
          : // Inputs are always single-line, even if inside a contentEditable element
          // IE also treats inputs as contentEditable
          isInput
          ? false
          : // All other element types are determined by whether or not they're contentEditable
            this.element.prop('isContentEditable');

      this.valueMethod = this.element[isTextarea || isInput ? 'val' : 'text'];
      this.isNewMenu = true;

      this.element.addClass('ui-autocomplete-input').attr('autocomplete', 'off');

      this._on(this.element, {
        keydown: function(event) {
          /*jshint maxcomplexity:15*/
          if (this.element.prop('readOnly')) {
            suppressKeyPress = true;
            suppressInput = true;
            suppressKeyPressRepeat = true;
            return;
          }

          suppressKeyPress = false;
          suppressInput = false;
          suppressKeyPressRepeat = false;
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
            case keyCode.PAGE_UP:
              suppressKeyPress = true;
              this._move('previousPage', event);
              break;
            case keyCode.PAGE_DOWN:
              suppressKeyPress = true;
              this._move('nextPage', event);
              break;
            case keyCode.UP:
              suppressKeyPress = true;
              this._keyEvent('previous', event);
              break;
            case keyCode.DOWN:
              suppressKeyPress = true;
              this._keyEvent('next', event);
              break;
            case keyCode.ENTER:
            case keyCode.NUMPAD_ENTER:
              // when menu is open and has focus
              if (this.menu.active) {
                // #6055 - Opera still allows the keypress to occur
                // which causes forms to submit
                suppressKeyPress = true;
                event.preventDefault();
                this.menu.select(event);
              }
              break;
            case keyCode.TAB:
              if (this.menu.active) {
                this.menu.select(event);
              }
              break;
            case keyCode.ESCAPE:
              if (this.menu.element.is(':visible')) {
                this._value(this.term);
                this.close(event);
                // Different browsers have different default behavior for escape
                // Single press can mean undo or clear
                // Double press in IE means clear the whole form
                event.preventDefault();
              }
              break;
            default:
              suppressKeyPressRepeat = true;
              // search timeout should be triggered before the input value is changed
              this._searchTimeout(event);
              break;
          }
        },
        keypress: function(event) {
          if (suppressKeyPress) {
            suppressKeyPress = false;
            if (!this.isMultiLine || this.menu.element.is(':visible')) {
              event.preventDefault();
            }
            return;
          }
          if (suppressKeyPressRepeat) {
            return;
          }

          // replicate some key handlers to allow them to repeat in Firefox and Opera
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
            case keyCode.PAGE_UP:
              this._move('previousPage', event);
              break;
            case keyCode.PAGE_DOWN:
              this._move('nextPage', event);
              break;
            case keyCode.UP:
              this._keyEvent('previous', event);
              break;
            case keyCode.DOWN:
              this._keyEvent('next', event);
              break;
          }
        },
        input: function(event) {
          if (suppressInput) {
            suppressInput = false;
            event.preventDefault();
            return;
          }
          this._searchTimeout(event);
        },
        focus: function() {
          this.selectedItem = null;
          this.previous = this._value();
        },
        blur: function(event) {
          if (this.cancelBlur) {
            delete this.cancelBlur;
            return;
          }

          clearTimeout(this.searching);
          this.close(event);
          this._change(event);
        },
      });

      this._initSource();
      this.menu = $('<ul>')
        .addClass('ui-autocomplete ui-front')
        .appendTo(this._appendTo())
        .menu({
          // disable ARIA support, the live region takes care of that
          role: null,
        })
        .hide()
        .data('ui-menu');

      this._on(this.menu.element, {
        mousedown: function(event) {
          // prevent moving focus out of the text field
          event.preventDefault();

          // IE doesn't prevent moving focus even with event.preventDefault()
          // so we set a flag to know when we should ignore the blur event
          this.cancelBlur = true;
          this._delay(function() {
            delete this.cancelBlur;
          });

          // clicking on the scrollbar causes focus to shift to the body
          // but we can't detect a mouseup or a click immediately afterward
          // so we have to track the next mousedown and close the menu if
          // the user clicks somewhere outside of the autocomplete
          var menuElement = this.menu.element[0];
          if (!$(event.target).closest('.ui-menu-item').length) {
            this._delay(function() {
              var that = this;
              this.document.one('mousedown', function(event) {
                if (
                  event.target !== that.element[0] &&
                  event.target !== menuElement &&
                  !$.contains(menuElement, event.target)
                ) {
                  that.close();
                }
              });
            });
          }
        },
        menufocus: function(event, ui) {
          // support: Firefox
          // Prevent accidental activation of menu items in Firefox (#7024 #9118)
          if (this.isNewMenu) {
            this.isNewMenu = false;
            if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
              this.menu.blur();

              this.document.one('mousemove', function() {
                $(event.target).trigger(event.originalEvent);
              });

              return;
            }
          }

          var item = ui.item.data('ui-autocomplete-item');
          if (false !== this._trigger('focus', event, { item: item })) {
            // use value to match what will end up in the input, if it was a key event
            if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
              this._value(item.value);
            }
          } else {
            // Normally the input is populated with the item's value as the
            // menu is navigated, causing screen readers to notice a change and
            // announce the item. Since the focus event was canceled, this doesn't
            // happen, so we update the live region so that screen readers can
            // still notice the change and announce it.
            this.liveRegion.text(item.value);
          }
        },
        menuselect: function(event, ui) {
          var item = ui.item.data('ui-autocomplete-item'),
            previous = this.previous;

          // only trigger when focus was lost (click on menu)
          if (this.element[0] !== this.document[0].activeElement) {
            this.element.focus();
            this.previous = previous;
            // #6109 - IE triggers two focus events and the second
            // is asynchronous, so we need to reset the previous
            // term synchronously and asynchronously :-(
            this._delay(function() {
              this.previous = previous;
              this.selectedItem = item;
            });
          }

          if (false !== this._trigger('select', event, { item: item })) {
            this._value(item.value);
          }
          // reset the term after the select event
          // this allows custom select handling to work properly
          this.term = this._value();

          this.close(event);
          this.selectedItem = item;
        },
      });

      this.liveRegion = $('<span>', {
        role: 'status',
        'aria-live': 'polite',
      })
        .addClass('ui-helper-hidden-accessible')
        .insertBefore(this.element);

      // turning off autocomplete prevents the browser from remembering the
      // value when navigating through history, so we re-enable autocomplete
      // if the page is unloaded before the widget is destroyed. #7790
      this._on(this.window, {
        beforeunload: function() {
          this.element.removeAttr('autocomplete');
        },
      });
    },

    _destroy: function() {
      clearTimeout(this.searching);
      this.element.removeClass('ui-autocomplete-input').removeAttr('autocomplete');
      this.menu.element.remove();
      this.liveRegion.remove();
    },

    _setOption: function(key, value) {
      this._super(key, value);
      if (key === 'source') {
        this._initSource();
      }
      if (key === 'appendTo') {
        this.menu.element.appendTo(this._appendTo());
      }
      if (key === 'disabled' && value && this.xhr) {
        this.xhr.abort();
      }
    },

    _appendTo: function() {
      var element = this.options.appendTo;

      if (element) {
        element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
      }

      if (!element) {
        element = this.element.closest('.ui-front');
      }

      if (!element.length) {
        element = this.document[0].body;
      }

      return element;
    },

    _initSource: function() {
      var array,
        url,
        that = this;
      if ($.isArray(this.options.source)) {
        array = this.options.source;
        this.source = function(request, response) {
          response($.ui.autocomplete.filter(array, request.term));
        };
      } else if (typeof this.options.source === 'string') {
        url = this.options.source;
        this.source = function(request, response) {
          if (that.xhr) {
            that.xhr.abort();
          }
          that.xhr = $.ajax({
            url: url,
            data: request,
            dataType: 'json',
            success: function(data) {
              response(data);
            },
            error: function() {
              response([]);
            },
          });
        };
      } else {
        this.source = this.options.source;
      }
    },

    _searchTimeout: function(event) {
      clearTimeout(this.searching);
      this.searching = this._delay(function() {
        // only search if the value has changed
        if (this.term !== this._value()) {
          this.selectedItem = null;
          this.search(null, event);
        }
      }, this.options.delay);
    },

    search: function(value, event) {
      value = value != null ? value : this._value();

      // always save the actual value, not the one passed as an argument
      this.term = this._value();

      if (value.length < this.options.minLength) {
        return this.close(event);
      }

      if (this._trigger('search', event) === false) {
        return;
      }

      return this._search(value);
    },

    _search: function(value) {
      this.pending++;
      this.element.addClass('ui-autocomplete-loading');
      this.cancelSearch = false;

      this.source({ term: value }, this._response());
    },

    _response: function() {
      var that = this,
        index = ++requestIndex;

      return function(content) {
        if (index === requestIndex) {
          that.__response(content);
        }

        that.pending--;
        if (!that.pending) {
          that.element.removeClass('ui-autocomplete-loading');
        }
      };
    },

    __response: function(content) {
      if (content) {
        content = this._normalize(content);
      }
      this._trigger('response', null, { content: content });
      if (!this.options.disabled && content && content.length && !this.cancelSearch) {
        this._suggest(content);
        this._trigger('open');
      } else {
        // use ._close() instead of .close() so we don't cancel future searches
        this._close();
      }
    },

    close: function(event) {
      this.cancelSearch = true;
      this._close(event);
    },

    _close: function(event) {
      if (this.menu.element.is(':visible')) {
        this.menu.element.hide();
        this.menu.blur();
        this.isNewMenu = true;
        this._trigger('close', event);
      }
    },

    _change: function(event) {
      if (this.previous !== this._value()) {
        this._trigger('change', event, { item: this.selectedItem });
      }
    },

    _normalize: function(items) {
      // assume all items have the right format when the first item is complete
      if (items.length && items[0].label && items[0].value) {
        return items;
      }
      return $.map(items, function(item) {
        if (typeof item === 'string') {
          return {
            label: item,
            value: item,
          };
        }
        return $.extend(
          {
            label: item.label || item.value,
            value: item.value || item.label,
          },
          item
        );
      });
    },

    _suggest: function(items) {
      var ul = this.menu.element.empty();
      this._renderMenu(ul, items);
      this.isNewMenu = true;
      this.menu.refresh();

      // size and position menu
      ul.show();
      this._resizeMenu();
      ul.position(
        $.extend(
          {
            of: this.element,
          },
          this.options.position
        )
      );

      if (this.options.autoFocus) {
        this.menu.next();
      }
    },

    _resizeMenu: function() {
      var ul = this.menu.element;
      ul.outerWidth(
        Math.max(
          // Firefox wraps long text (possibly a rounding bug)
          // so we add 1px to avoid the wrapping (#7513)
          ul.width('').outerWidth() + 1,
          this.element.outerWidth()
        )
      );
    },

    _renderMenu: function(ul, items) {
      var that = this;
      $.each(items, function(index, item) {
        that._renderItemData(ul, item);
      });
    },

    _renderItemData: function(ul, item) {
      return this._renderItem(ul, item).data('ui-autocomplete-item', item);
    },

    _renderItem: function(ul, item) {
      return $('<li>')
        .append($('<a>').text(item.label))
        .appendTo(ul);
    },

    _move: function(direction, event) {
      if (!this.menu.element.is(':visible')) {
        this.search(null, event);
        return;
      }
      if (
        (this.menu.isFirstItem() && /^previous/.test(direction)) ||
        (this.menu.isLastItem() && /^next/.test(direction))
      ) {
        this._value(this.term);
        this.menu.blur();
        return;
      }
      this.menu[direction](event);
    },

    widget: function() {
      return this.menu.element;
    },

    _value: function() {
      return this.valueMethod.apply(this.element, arguments);
    },

    _keyEvent: function(keyEvent, event) {
      if (!this.isMultiLine || this.menu.element.is(':visible')) {
        this._move(keyEvent, event);

        // prevents moving cursor to beginning/end of the text field in some browsers
        event.preventDefault();
      }
    },
  });

  $.extend($.ui.autocomplete, {
    escapeRegex: function(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
    },
    filter: function(array, term) {
      var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), 'i');
      return $.grep(array, function(value) {
        return matcher.test(value.label || value.value || value);
      });
    },
  });

  // live region extension, adding a `messages` option
  // NOTE: This is an experimental API. We are still investigating
  // a full solution for string manipulation and internationalization.
  $.widget('ui.autocomplete', $.ui.autocomplete, {
    options: {
      messages: {
        noResults: 'No search results.',
        results: function(amount) {
          return (
            amount +
            (amount > 1 ? ' results are' : ' result is') +
            ' available, use up and down arrow keys to navigate.'
          );
        },
      },
    },

    __response: function(content) {
      var message;
      this._superApply(arguments);
      if (this.options.disabled || this.cancelSearch) {
        return;
      }
      if (content && content.length) {
        message = this.options.messages.results(content.length);
      } else {
        message = this.options.messages.noResults;
      }
      this.liveRegion.text(message);
    },
  });
})(jQuery);

(function($, undefined) {
  var lastActive,
    startXPos,
    startYPos,
    clickDragged,
    baseClasses = 'ui-button ui-widget ui-state-default ui-corner-all',
    stateClasses = 'ui-state-hover ui-state-active ',
    typeClasses =
      'ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only',
    formResetHandler = function() {
      var form = $(this);
      setTimeout(function() {
        form.find(':ui-button').button('refresh');
      }, 1);
    },
    radioGroup = function(radio) {
      var name = radio.name,
        form = radio.form,
        radios = $([]);
      if (name) {
        name = name.replace(/'/g, "\\'");
        if (form) {
          radios = $(form).find("[name='" + name + "']");
        } else {
          radios = $("[name='" + name + "']", radio.ownerDocument).filter(function() {
            return !this.form;
          });
        }
      }
      return radios;
    };

  $.widget('ui.button', {
    version: '1.10.3',
    defaultElement: '<button>',
    options: {
      disabled: null,
      text: true,
      label: null,
      icons: {
        primary: null,
        secondary: null,
      },
    },
    _create: function() {
      this.element
        .closest('form')
        .unbind('reset' + this.eventNamespace)
        .bind('reset' + this.eventNamespace, formResetHandler);

      if (typeof this.options.disabled !== 'boolean') {
        this.options.disabled = !!this.element.prop('disabled');
      } else {
        this.element.prop('disabled', this.options.disabled);
      }

      this._determineButtonType();
      this.hasTitle = !!this.buttonElement.attr('title');

      var that = this,
        options = this.options,
        toggleButton = this.type === 'checkbox' || this.type === 'radio',
        activeClass = !toggleButton ? 'ui-state-active' : '',
        focusClass = 'ui-state-focus';

      if (options.label === null) {
        options.label = this.type === 'input' ? this.buttonElement.val() : this.buttonElement.html();
      }

      this._hoverable(this.buttonElement);

      this.buttonElement
        .addClass(baseClasses)
        .attr('role', 'button')
        .bind('mouseenter' + this.eventNamespace, function() {
          if (options.disabled) {
            return;
          }
          if (this === lastActive) {
            $(this).addClass('ui-state-active');
          }
        })
        .bind('mouseleave' + this.eventNamespace, function() {
          if (options.disabled) {
            return;
          }
          $(this).removeClass(activeClass);
        })
        .bind('click' + this.eventNamespace, function(event) {
          if (options.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
          }
        });

      this.element
        .bind('focus' + this.eventNamespace, function() {
          // no need to check disabled, focus won't be triggered anyway
          that.buttonElement.addClass(focusClass);
        })
        .bind('blur' + this.eventNamespace, function() {
          that.buttonElement.removeClass(focusClass);
        });

      if (toggleButton) {
        this.element.bind('change' + this.eventNamespace, function() {
          if (clickDragged) {
            return;
          }
          that.refresh();
        });
        // if mouse moves between mousedown and mouseup (drag) set clickDragged flag
        // prevents issue where button state changes but checkbox/radio checked state
        // does not in Firefox (see ticket #6970)
        this.buttonElement
          .bind('mousedown' + this.eventNamespace, function(event) {
            if (options.disabled) {
              return;
            }
            clickDragged = false;
            startXPos = event.pageX;
            startYPos = event.pageY;
          })
          .bind('mouseup' + this.eventNamespace, function(event) {
            if (options.disabled) {
              return;
            }
            if (startXPos !== event.pageX || startYPos !== event.pageY) {
              clickDragged = true;
            }
          });
      }

      if (this.type === 'checkbox') {
        this.buttonElement.bind('click' + this.eventNamespace, function() {
          if (options.disabled || clickDragged) {
            return false;
          }
        });
      } else if (this.type === 'radio') {
        this.buttonElement.bind('click' + this.eventNamespace, function() {
          if (options.disabled || clickDragged) {
            return false;
          }
          $(this).addClass('ui-state-active');
          that.buttonElement.attr('aria-pressed', 'true');

          var radio = that.element[0];
          radioGroup(radio)
            .not(radio)
            .map(function() {
              return $(this).button('widget')[0];
            })
            .removeClass('ui-state-active')
            .attr('aria-pressed', 'false');
        });
      } else {
        this.buttonElement
          .bind('mousedown' + this.eventNamespace, function() {
            if (options.disabled) {
              return false;
            }
            $(this).addClass('ui-state-active');
            lastActive = this;
            that.document.one('mouseup', function() {
              lastActive = null;
            });
          })
          .bind('mouseup' + this.eventNamespace, function() {
            if (options.disabled) {
              return false;
            }
            $(this).removeClass('ui-state-active');
          })
          .bind('keydown' + this.eventNamespace, function(event) {
            if (options.disabled) {
              return false;
            }
            if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
              $(this).addClass('ui-state-active');
            }
          })
          // see #8559, we bind to blur here in case the button element loses
          // focus between keydown and keyup, it would be left in an "active" state
          .bind('keyup' + this.eventNamespace + ' blur' + this.eventNamespace, function() {
            $(this).removeClass('ui-state-active');
          });

        if (this.buttonElement.is('a')) {
          this.buttonElement.keyup(function(event) {
            if (event.keyCode === $.ui.keyCode.SPACE) {
              // TODO pass through original event correctly (just as 2nd argument doesn't work)
              $(this).click();
            }
          });
        }
      }

      // TODO: pull out $.Widget's handling for the disabled option into
      // $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
      // be overridden by individual plugins
      this._setOption('disabled', options.disabled);
      this._resetButton();
    },

    _determineButtonType: function() {
      var ancestor, labelSelector, checked;

      if (this.element.is('[type=checkbox]')) {
        this.type = 'checkbox';
      } else if (this.element.is('[type=radio]')) {
        this.type = 'radio';
      } else if (this.element.is('input')) {
        this.type = 'input';
      } else {
        this.type = 'button';
      }

      if (this.type === 'checkbox' || this.type === 'radio') {
        // we don't search against the document in case the element
        // is disconnected from the DOM
        ancestor = this.element.parents().last();
        labelSelector = "label[for='" + this.element.attr('id') + "']";
        this.buttonElement = ancestor.find(labelSelector);
        if (!this.buttonElement.length) {
          ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
          this.buttonElement = ancestor.filter(labelSelector);
          if (!this.buttonElement.length) {
            this.buttonElement = ancestor.find(labelSelector);
          }
        }
        this.element.addClass('ui-helper-hidden-accessible');

        checked = this.element.is(':checked');
        if (checked) {
          this.buttonElement.addClass('ui-state-active');
        }
        this.buttonElement.prop('aria-pressed', checked);
      } else {
        this.buttonElement = this.element;
      }
    },

    widget: function() {
      return this.buttonElement;
    },

    _destroy: function() {
      this.element.removeClass('ui-helper-hidden-accessible');
      this.buttonElement
        .removeClass(baseClasses + ' ' + stateClasses + ' ' + typeClasses)
        .removeAttr('role')
        .removeAttr('aria-pressed')
        .html(this.buttonElement.find('.ui-button-text').html());

      if (!this.hasTitle) {
        this.buttonElement.removeAttr('title');
      }
    },

    _setOption: function(key, value) {
      this._super(key, value);
      if (key === 'disabled') {
        if (value) {
          this.element.prop('disabled', true);
        } else {
          this.element.prop('disabled', false);
        }
        return;
      }
      this._resetButton();
    },

    refresh: function() {
      //See #8237 & #8828
      var isDisabled = this.element.is('input, button')
        ? this.element.is(':disabled')
        : this.element.hasClass('ui-button-disabled');

      if (isDisabled !== this.options.disabled) {
        this._setOption('disabled', isDisabled);
      }
      if (this.type === 'radio') {
        radioGroup(this.element[0]).each(function() {
          if ($(this).is(':checked')) {
            $(this)
              .button('widget')
              .addClass('ui-state-active')
              .attr('aria-pressed', 'true');
          } else {
            $(this)
              .button('widget')
              .removeClass('ui-state-active')
              .attr('aria-pressed', 'false');
          }
        });
      } else if (this.type === 'checkbox') {
        if (this.element.is(':checked')) {
          this.buttonElement.addClass('ui-state-active').attr('aria-pressed', 'true');
        } else {
          this.buttonElement.removeClass('ui-state-active').attr('aria-pressed', 'false');
        }
      }
    },

    _resetButton: function() {
      if (this.type === 'input') {
        if (this.options.label) {
          this.element.val(this.options.label);
        }
        return;
      }
      var buttonElement = this.buttonElement.removeClass(typeClasses),
        buttonText = $('<span></span>', this.document[0])
          .addClass('ui-button-text')
          .html(this.options.label)
          .appendTo(buttonElement.empty())
          .text(),
        icons = this.options.icons,
        multipleIcons = icons.primary && icons.secondary,
        buttonClasses = [];

      if (icons.primary || icons.secondary) {
        if (this.options.text) {
          buttonClasses.push('ui-button-text-icon' + (multipleIcons ? 's' : icons.primary ? '-primary' : '-secondary'));
        }

        if (icons.primary) {
          buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>");
        }

        if (icons.secondary) {
          buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>");
        }

        if (!this.options.text) {
          buttonClasses.push(multipleIcons ? 'ui-button-icons-only' : 'ui-button-icon-only');

          if (!this.hasTitle) {
            buttonElement.attr('title', $.trim(buttonText));
          }
        }
      } else {
        buttonClasses.push('ui-button-text-only');
      }
      buttonElement.addClass(buttonClasses.join(' '));
    },
  });

  $.widget('ui.buttonset', {
    version: '1.10.3',
    options: {
      items:
        'button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)',
    },

    _create: function() {
      this.element.addClass('ui-buttonset');
    },

    _init: function() {
      this.refresh();
    },

    _setOption: function(key, value) {
      if (key === 'disabled') {
        this.buttons.button('option', key, value);
      }

      this._super(key, value);
    },

    refresh: function() {
      var rtl = this.element.css('direction') === 'rtl';

      this.buttons = this.element
        .find(this.options.items)
        .filter(':ui-button')
        .button('refresh')
        .end()
        .not(':ui-button')
        .button()
        .end()
        .map(function() {
          return $(this).button('widget')[0];
        })
        .removeClass('ui-corner-all ui-corner-left ui-corner-right')
        .filter(':first')
        .addClass(rtl ? 'ui-corner-right' : 'ui-corner-left')
        .end()
        .filter(':last')
        .addClass(rtl ? 'ui-corner-left' : 'ui-corner-right')
        .end()
        .end();
    },

    _destroy: function() {
      this.element.removeClass('ui-buttonset');
      this.buttons
        .map(function() {
          return $(this).button('widget')[0];
        })
        .removeClass('ui-corner-left ui-corner-right')
        .end()
        .button('destroy');
    },
  });
})(jQuery);

(function($, undefined) {
  $.extend($.ui, { datepicker: { version: '1.10.3' } });

  var PROP_NAME = 'datepicker',
    instActive;

  /* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

  function Datepicker() {
    this._curInst = null; // The current instance in use
    this._keyEvent = false; // If the last event was a key event
    this._disabledInputs = []; // List of date picker inputs that have been disabled
    this._datepickerShowing = false; // True if the popup picker is showing , false if not
    this._inDialog = false; // True if showing within a "dialog", false if not
    this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
    this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
    this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
    this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
    this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
    this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
    this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
    this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
    this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
    this.regional = []; // Available regional settings, indexed by language code
    this.regional[''] = {
      // Default regional settings
      closeText: 'Done', // Display text for close link
      prevText: 'Prev', // Display text for previous month link
      nextText: 'Next', // Display text for next month link
      currentText: 'Today', // Display text for current month link
      monthNames: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
      ], // Names of months for drop-down and formatting
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
      dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
      dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
      dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'], // Column headings for days starting at Sunday
      weekHeader: 'Wk', // Column header for week of the year
      dateFormat: 'mm/dd/yy', // See format options on parseDate
      firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
      isRTL: false, // True if right-to-left language, false if left-to-right
      showMonthAfterYear: false, // True if the year select precedes month, false for month then year
      yearSuffix: '', // Additional text to append to the year in the month headers
    };
    this._defaults = {
      // Global defaults for all the date picker instances
      showOn: 'focus', // "focus" for popup on focus,
      // "button" for trigger button, or "both" for either
      showAnim: 'fadeIn', // Name of jQuery animation for popup
      showOptions: {}, // Options for enhanced animations
      defaultDate: null, // Used when field is blank: actual date,
      // +/-number for offset from today, null for today
      appendText: '', // Display text following the input box, e.g. showing the format
      buttonText: '...', // Text for trigger button
      buttonImage: '', // URL for trigger button image
      buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
      hideIfNoPrevNext: false, // True to hide next/previous month links
      // if not applicable, false to just disable them
      navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
      gotoCurrent: false, // True if today link goes back to current selection instead
      changeMonth: false, // True if month can be selected directly, false if only prev/next
      changeYear: false, // True if year can be selected directly, false if only prev/next
      yearRange: 'c-10:c+10', // Range of years to display in drop-down,
      // either relative to today's year (-nn:+nn), relative to currently displayed year
      // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
      showOtherMonths: false, // True to show dates in other months, false to leave blank
      selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
      showWeek: false, // True to show week of the year, false to not show it
      calculateWeek: this.iso8601Week, // How to calculate the week of the year,
      // takes a Date and returns the number of the week for it
      shortYearCutoff: '+10', // Short year values < this are in the current century,
      // > this are in the previous century,
      // string value starting with "+" for current year + value
      minDate: null, // The earliest selectable date, or null for no limit
      maxDate: null, // The latest selectable date, or null for no limit
      duration: 'fast', // Duration of display/closure
      beforeShowDay: null, // Function that takes a date and returns an array with
      // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
      // [2] = cell title (optional), e.g. $.datepicker.noWeekends
      beforeShow: null, // Function that takes an input field and
      // returns a set of custom settings for the date picker
      onSelect: null, // Define a callback function when a date is selected
      onChangeMonthYear: null, // Define a callback function when the month or year is changed
      onClose: null, // Define a callback function when the datepicker is closed
      numberOfMonths: 1, // Number of months to show at a time
      showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
      stepMonths: 1, // Number of months to step back/forward
      stepBigMonths: 12, // Number of months to step back/forward for the big links
      altField: '', // Selector for an alternate field to store selected dates into
      altFormat: '', // The date format to use for the alternate field
      constrainInput: true, // The input is constrained by the current date format
      showButtonPanel: false, // True to show button panel, false to not show it
      autoSize: false, // True to size the input for the date format, false to leave as is
      disabled: false, // The initial disabled state
    };
    $.extend(this._defaults, this.regional['']);
    this.dpDiv = bindHover(
      $(
        "<div id='" +
          this._mainDivId +
          "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"
      )
    );
  }

  $.extend(Datepicker.prototype, {
    /* Class name added to elements to indicate already configured with a date picker. */
    markerClassName: 'hasDatepicker',

    //Keep track of the maximum number of rows displayed (see #7043)
    maxRows: 4,

    // TODO rename to "widget" when switching to widget factory
    _widgetDatepicker: function() {
      return this.dpDiv;
    },

    /* Override the default settings for all instances of the date picker.
     * @param  settings  object - the new settings to use as defaults (anonymous object)
     * @return the manager object
     */
    setDefaults: function(settings) {
      extendRemove(this._defaults, settings || {});
      return this;
    },

    /* Attach the date picker to a jQuery selection.
     * @param  target	element - the target input field or division or span
     * @param  settings  object - the new settings to use for this date picker instance (anonymous)
     */
    _attachDatepicker: function(target, settings) {
      var nodeName, inline, inst;
      nodeName = target.nodeName.toLowerCase();
      inline = nodeName === 'div' || nodeName === 'span';
      if (!target.id) {
        this.uuid += 1;
        target.id = 'dp' + this.uuid;
      }
      inst = this._newInst($(target), inline);
      inst.settings = $.extend({}, settings || {});
      if (nodeName === 'input') {
        this._connectDatepicker(target, inst);
      } else if (inline) {
        this._inlineDatepicker(target, inst);
      }
    },

    /* Create a new instance object. */
    _newInst: function(target, inline) {
      var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, '\\\\$1'); // escape jQuery meta chars
      return {
        id: id,
        input: target, // associated target
        selectedDay: 0,
        selectedMonth: 0,
        selectedYear: 0, // current selection
        drawMonth: 0,
        drawYear: 0, // month being drawn
        inline: inline, // is datepicker inline or not
        dpDiv: !inline
          ? this.dpDiv // presentation div
          : bindHover(
              $(
                "<div class='" +
                  this._inlineClass +
                  " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"
              )
            ),
      };
    },

    /* Attach the date picker to an input field. */
    _connectDatepicker: function(target, inst) {
      var input = $(target);
      inst.append = $([]);
      inst.trigger = $([]);
      if (input.hasClass(this.markerClassName)) {
        return;
      }
      this._attachments(input, inst);
      input
        .addClass(this.markerClassName)
        .keydown(this._doKeyDown)
        .keypress(this._doKeyPress)
        .keyup(this._doKeyUp);
      this._autoSize(inst);
      $.data(target, PROP_NAME, inst);
      //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
      if (inst.settings.disabled) {
        this._disableDatepicker(target);
      }
    },

    /* Make attachments based on settings. */
    _attachments: function(input, inst) {
      var showOn,
        buttonText,
        buttonImage,
        appendText = this._get(inst, 'appendText'),
        isRTL = this._get(inst, 'isRTL');

      if (inst.append) {
        inst.append.remove();
      }
      if (appendText) {
        inst.append = $("<span class='" + this._appendClass + "'>" + appendText + '</span>');
        input[isRTL ? 'before' : 'after'](inst.append);
      }

      input.unbind('focus', this._showDatepicker);

      if (inst.trigger) {
        inst.trigger.remove();
      }

      showOn = this._get(inst, 'showOn');
      if (showOn === 'focus' || showOn === 'both') {
        // pop-up date picker when in the marked field
        input.focus(this._showDatepicker);
      }
      if (showOn === 'button' || showOn === 'both') {
        // pop-up date picker when button clicked
        buttonText = this._get(inst, 'buttonText');
        buttonImage = this._get(inst, 'buttonImage');
        inst.trigger = $(
          this._get(inst, 'buttonImageOnly')
            ? $('<img/>')
                .addClass(this._triggerClass)
                .attr({ src: buttonImage, alt: buttonText, title: buttonText })
            : $("<button type='button'></button>")
                .addClass(this._triggerClass)
                .html(
                  !buttonImage ? buttonText : $('<img/>').attr({ src: buttonImage, alt: buttonText, title: buttonText })
                )
        );
        input[isRTL ? 'before' : 'after'](inst.trigger);
        inst.trigger.click(function() {
          if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
            $.datepicker._hideDatepicker();
          } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
            $.datepicker._hideDatepicker();
            $.datepicker._showDatepicker(input[0]);
          } else {
            $.datepicker._showDatepicker(input[0]);
          }
          return false;
        });
      }
    },

    /* Apply the maximum length for the date format. */
    _autoSize: function(inst) {
      if (this._get(inst, 'autoSize') && !inst.inline) {
        var findMax,
          max,
          maxI,
          i,
          date = new Date(2009, 12 - 1, 20), // Ensure double digits
          dateFormat = this._get(inst, 'dateFormat');

        if (dateFormat.match(/[DM]/)) {
          findMax = function(names) {
            max = 0;
            maxI = 0;
            for (i = 0; i < names.length; i++) {
              if (names[i].length > max) {
                max = names[i].length;
                maxI = i;
              }
            }
            return maxI;
          };
          date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? 'monthNames' : 'monthNamesShort')));
          date.setDate(
            findMax(this._get(inst, dateFormat.match(/DD/) ? 'dayNames' : 'dayNamesShort')) + 20 - date.getDay()
          );
        }
        inst.input.attr('size', this._formatDate(inst, date).length);
      }
    },

    /* Attach an inline date picker to a div. */
    _inlineDatepicker: function(target, inst) {
      var divSpan = $(target);
      if (divSpan.hasClass(this.markerClassName)) {
        return;
      }
      divSpan.addClass(this.markerClassName).append(inst.dpDiv);
      $.data(target, PROP_NAME, inst);
      this._setDate(inst, this._getDefaultDate(inst), true);
      this._updateDatepicker(inst);
      this._updateAlternate(inst);
      //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
      if (inst.settings.disabled) {
        this._disableDatepicker(target);
      }
      // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
      // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
      inst.dpDiv.css('display', 'block');
    },

    /* Pop-up the date picker in a "dialog" box.
     * @param  input element - ignored
     * @param  date	string or Date - the initial date to display
     * @param  onSelect  function - the function to call when a date is selected
     * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
     * @param  pos int[2] - coordinates for the dialog's position within the screen or
     *					event - with x/y coordinates or
     *					leave empty for default (screen centre)
     * @return the manager object
     */
    _dialogDatepicker: function(input, date, onSelect, settings, pos) {
      var id,
        browserWidth,
        browserHeight,
        scrollX,
        scrollY,
        inst = this._dialogInst; // internal instance

      if (!inst) {
        this.uuid += 1;
        id = 'dp' + this.uuid;
        this._dialogInput = $(
          "<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>"
        );
        this._dialogInput.keydown(this._doKeyDown);
        $('body').append(this._dialogInput);
        inst = this._dialogInst = this._newInst(this._dialogInput, false);
        inst.settings = {};
        $.data(this._dialogInput[0], PROP_NAME, inst);
      }
      extendRemove(inst.settings, settings || {});
      date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
      this._dialogInput.val(date);

      this._pos = pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null;
      if (!this._pos) {
        browserWidth = document.documentElement.clientWidth;
        browserHeight = document.documentElement.clientHeight;
        scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        this._pos =
          // should use actual width/height below
          [browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY];
      }

      // move input on screen for focus, but hidden behind dialog
      this._dialogInput.css('left', this._pos[0] + 20 + 'px').css('top', this._pos[1] + 'px');
      inst.settings.onSelect = onSelect;
      this._inDialog = true;
      this.dpDiv.addClass(this._dialogClass);
      this._showDatepicker(this._dialogInput[0]);
      if ($.blockUI) {
        $.blockUI(this.dpDiv);
      }
      $.data(this._dialogInput[0], PROP_NAME, inst);
      return this;
    },

    /* Detach a datepicker from its control.
     * @param  target	element - the target input field or division or span
     */
    _destroyDatepicker: function(target) {
      var nodeName,
        $target = $(target),
        inst = $.data(target, PROP_NAME);

      if (!$target.hasClass(this.markerClassName)) {
        return;
      }

      nodeName = target.nodeName.toLowerCase();
      $.removeData(target, PROP_NAME);
      if (nodeName === 'input') {
        inst.append.remove();
        inst.trigger.remove();
        $target
          .removeClass(this.markerClassName)
          .unbind('focus', this._showDatepicker)
          .unbind('keydown', this._doKeyDown)
          .unbind('keypress', this._doKeyPress)
          .unbind('keyup', this._doKeyUp);
      } else if (nodeName === 'div' || nodeName === 'span') {
        $target.removeClass(this.markerClassName).empty();
      }
    },

    /* Enable the date picker to a jQuery selection.
     * @param  target	element - the target input field or division or span
     */
    _enableDatepicker: function(target) {
      var nodeName,
        inline,
        $target = $(target),
        inst = $.data(target, PROP_NAME);

      if (!$target.hasClass(this.markerClassName)) {
        return;
      }

      nodeName = target.nodeName.toLowerCase();
      if (nodeName === 'input') {
        target.disabled = false;
        inst.trigger
          .filter('button')
          .each(function() {
            this.disabled = false;
          })
          .end()
          .filter('img')
          .css({ opacity: '1.0', cursor: '' });
      } else if (nodeName === 'div' || nodeName === 'span') {
        inline = $target.children('.' + this._inlineClass);
        inline.children().removeClass('ui-state-disabled');
        inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', false);
      }
      this._disabledInputs = $.map(this._disabledInputs, function(value) {
        return value === target ? null : value;
      }); // delete entry
    },

    /* Disable the date picker to a jQuery selection.
     * @param  target	element - the target input field or division or span
     */
    _disableDatepicker: function(target) {
      var nodeName,
        inline,
        $target = $(target),
        inst = $.data(target, PROP_NAME);

      if (!$target.hasClass(this.markerClassName)) {
        return;
      }

      nodeName = target.nodeName.toLowerCase();
      if (nodeName === 'input') {
        target.disabled = true;
        inst.trigger
          .filter('button')
          .each(function() {
            this.disabled = true;
          })
          .end()
          .filter('img')
          .css({ opacity: '0.5', cursor: 'default' });
      } else if (nodeName === 'div' || nodeName === 'span') {
        inline = $target.children('.' + this._inlineClass);
        inline.children().addClass('ui-state-disabled');
        inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', true);
      }
      this._disabledInputs = $.map(this._disabledInputs, function(value) {
        return value === target ? null : value;
      }); // delete entry
      this._disabledInputs[this._disabledInputs.length] = target;
    },

    /* Is the first field in a jQuery collection disabled as a datepicker?
     * @param  target	element - the target input field or division or span
     * @return boolean - true if disabled, false if enabled
     */
    _isDisabledDatepicker: function(target) {
      if (!target) {
        return false;
      }
      for (var i = 0; i < this._disabledInputs.length; i++) {
        if (this._disabledInputs[i] === target) {
          return true;
        }
      }
      return false;
    },

    /* Retrieve the instance data for the target control.
     * @param  target  element - the target input field or division or span
     * @return  object - the associated instance data
     * @throws  error if a jQuery problem getting data
     */
    _getInst: function(target) {
      try {
        return $.data(target, PROP_NAME);
      } catch (err) {
        throw 'Missing instance data for this datepicker';
      }
    },

    /* Update or retrieve the settings for a date picker attached to an input field or division.
     * @param  target  element - the target input field or division or span
     * @param  name	object - the new settings to update or
     *				string - the name of the setting to change or retrieve,
     *				when retrieving also "all" for all instance settings or
     *				"defaults" for all global defaults
     * @param  value   any - the new value for the setting
     *				(omit if above is an object or to retrieve a value)
     */
    _optionDatepicker: function(target, name, value) {
      var settings,
        date,
        minDate,
        maxDate,
        inst = this._getInst(target);

      if (arguments.length === 2 && typeof name === 'string') {
        return name === 'defaults'
          ? $.extend({}, $.datepicker._defaults)
          : inst
          ? name === 'all'
            ? $.extend({}, inst.settings)
            : this._get(inst, name)
          : null;
      }

      settings = name || {};
      if (typeof name === 'string') {
        settings = {};
        settings[name] = value;
      }

      if (inst) {
        if (this._curInst === inst) {
          this._hideDatepicker();
        }

        date = this._getDateDatepicker(target, true);
        minDate = this._getMinMaxDate(inst, 'min');
        maxDate = this._getMinMaxDate(inst, 'max');
        extendRemove(inst.settings, settings);
        // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
        if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
          inst.settings.minDate = this._formatDate(inst, minDate);
        }
        if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
          inst.settings.maxDate = this._formatDate(inst, maxDate);
        }
        if ('disabled' in settings) {
          if (settings.disabled) {
            this._disableDatepicker(target);
          } else {
            this._enableDatepicker(target);
          }
        }
        this._attachments($(target), inst);
        this._autoSize(inst);
        this._setDate(inst, date);
        this._updateAlternate(inst);
        this._updateDatepicker(inst);
      }
    },

    // change method deprecated
    _changeDatepicker: function(target, name, value) {
      this._optionDatepicker(target, name, value);
    },

    /* Redraw the date picker attached to an input field or division.
     * @param  target  element - the target input field or division or span
     */
    _refreshDatepicker: function(target) {
      var inst = this._getInst(target);
      if (inst) {
        this._updateDatepicker(inst);
      }
    },

    /* Set the dates for a jQuery selection.
     * @param  target element - the target input field or division or span
     * @param  date	Date - the new date
     */
    _setDateDatepicker: function(target, date) {
      var inst = this._getInst(target);
      if (inst) {
        this._setDate(inst, date);
        this._updateDatepicker(inst);
        this._updateAlternate(inst);
      }
    },

    /* Get the date(s) for the first entry in a jQuery selection.
     * @param  target element - the target input field or division or span
     * @param  noDefault boolean - true if no default date is to be used
     * @return Date - the current date
     */
    _getDateDatepicker: function(target, noDefault) {
      var inst = this._getInst(target);
      if (inst && !inst.inline) {
        this._setDateFromField(inst, noDefault);
      }
      return inst ? this._getDate(inst) : null;
    },

    /* Handle keystrokes. */
    _doKeyDown: function(event) {
      var onSelect,
        dateStr,
        sel,
        inst = $.datepicker._getInst(event.target),
        handled = true,
        isRTL = inst.dpDiv.is('.ui-datepicker-rtl');

      inst._keyEvent = true;
      if ($.datepicker._datepickerShowing) {
        switch (event.keyCode) {
          case 9:
            $.datepicker._hideDatepicker();
            handled = false;
            break; // hide on tab out
          case 13:
            sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + $.datepicker._currentClass + ')', inst.dpDiv);
            if (sel[0]) {
              $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
            }

            onSelect = $.datepicker._get(inst, 'onSelect');
            if (onSelect) {
              dateStr = $.datepicker._formatDate(inst);

              // trigger custom callback
              onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]);
            } else {
              $.datepicker._hideDatepicker();
            }

            return false; // don't submit the form
          case 27:
            $.datepicker._hideDatepicker();
            break; // hide on escape
          case 33:
            $.datepicker._adjustDate(
              event.target,
              event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'),
              'M'
            );
            break; // previous month/year on page up/+ ctrl
          case 34:
            $.datepicker._adjustDate(
              event.target,
              event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'),
              'M'
            );
            break; // next month/year on page down/+ ctrl
          case 35:
            if (event.ctrlKey || event.metaKey) {
              $.datepicker._clearDate(event.target);
            }
            handled = event.ctrlKey || event.metaKey;
            break; // clear on ctrl or command +end
          case 36:
            if (event.ctrlKey || event.metaKey) {
              $.datepicker._gotoToday(event.target);
            }
            handled = event.ctrlKey || event.metaKey;
            break; // current on ctrl or command +home
          case 37:
            if (event.ctrlKey || event.metaKey) {
              $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, 'D');
            }
            handled = event.ctrlKey || event.metaKey;
            // -1 day on ctrl or command +left
            if (event.originalEvent.altKey) {
              $.datepicker._adjustDate(
                event.target,
                event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'),
                'M'
              );
            }
            // next month/year on alt +left on Mac
            break;
          case 38:
            if (event.ctrlKey || event.metaKey) {
              $.datepicker._adjustDate(event.target, -7, 'D');
            }
            handled = event.ctrlKey || event.metaKey;
            break; // -1 week on ctrl or command +up
          case 39:
            if (event.ctrlKey || event.metaKey) {
              $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, 'D');
            }
            handled = event.ctrlKey || event.metaKey;
            // +1 day on ctrl or command +right
            if (event.originalEvent.altKey) {
              $.datepicker._adjustDate(
                event.target,
                event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'),
                'M'
              );
            }
            // next month/year on alt +right
            break;
          case 40:
            if (event.ctrlKey || event.metaKey) {
              $.datepicker._adjustDate(event.target, +7, 'D');
            }
            handled = event.ctrlKey || event.metaKey;
            break; // +1 week on ctrl or command +down
          default:
            handled = false;
        }
      } else if (event.keyCode === 36 && event.ctrlKey) {
        // display the date picker on ctrl+home
        $.datepicker._showDatepicker(this);
      } else {
        handled = false;
      }

      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    },

    /* Filter entered characters - based on date format. */
    _doKeyPress: function(event) {
      var chars,
        chr,
        inst = $.datepicker._getInst(event.target);

      if ($.datepicker._get(inst, 'constrainInput')) {
        chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
        chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
        return event.ctrlKey || event.metaKey || chr < ' ' || !chars || chars.indexOf(chr) > -1;
      }
    },

    /* Synchronise manual entry and field/alternate field. */
    _doKeyUp: function(event) {
      var date,
        inst = $.datepicker._getInst(event.target);

      if (inst.input.val() !== inst.lastVal) {
        try {
          date = $.datepicker.parseDate(
            $.datepicker._get(inst, 'dateFormat'),
            inst.input ? inst.input.val() : null,
            $.datepicker._getFormatConfig(inst)
          );

          if (date) {
            // only if valid
            $.datepicker._setDateFromField(inst);
            $.datepicker._updateAlternate(inst);
            $.datepicker._updateDatepicker(inst);
          }
        } catch (err) {}
      }
      return true;
    },

    /* Pop-up the date picker for a given input field.
     * If false returned from beforeShow event handler do not show.
     * @param  input  element - the input field attached to the date picker or
     *					event - if triggered by focus
     */
    _showDatepicker: function(input) {
      input = input.target || input;
      if (input.nodeName.toLowerCase() !== 'input') {
        // find from button/image trigger
        input = $('input', input.parentNode)[0];
      }

      if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
        // already here
        return;
      }

      var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;

      inst = $.datepicker._getInst(input);
      if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
        $.datepicker._curInst.dpDiv.stop(true, true);
        if (inst && $.datepicker._datepickerShowing) {
          $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
        }
      }

      beforeShow = $.datepicker._get(inst, 'beforeShow');
      beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
      if (beforeShowSettings === false) {
        return;
      }
      extendRemove(inst.settings, beforeShowSettings);

      inst.lastVal = null;
      $.datepicker._lastInput = input;
      $.datepicker._setDateFromField(inst);

      if ($.datepicker._inDialog) {
        // hide cursor
        input.value = '';
      }
      if (!$.datepicker._pos) {
        // position below input
        $.datepicker._pos = $.datepicker._findPos(input);
        $.datepicker._pos[1] += input.offsetHeight; // add the height
      }

      isFixed = false;
      $(input)
        .parents()
        .each(function() {
          isFixed |= $(this).css('position') === 'fixed';
          return !isFixed;
        });

      offset = { left: $.datepicker._pos[0], top: $.datepicker._pos[1] };
      $.datepicker._pos = null;
      //to avoid flashes on Firefox
      inst.dpDiv.empty();
      // determine sizing offscreen
      inst.dpDiv.css({ position: 'absolute', display: 'block', top: '-1000px' });
      $.datepicker._updateDatepicker(inst);
      // fix width for dynamic number of date pickers
      // and adjust position before showing
      offset = $.datepicker._checkOffset(inst, offset, isFixed);
      inst.dpDiv.css({
        position: $.datepicker._inDialog && $.blockUI ? 'static' : isFixed ? 'fixed' : 'absolute',
        display: 'none',
        left: offset.left + 'px',
        top: offset.top + 'px',
      });

      if (!inst.inline) {
        showAnim = $.datepicker._get(inst, 'showAnim');
        duration = $.datepicker._get(inst, 'duration');
        inst.dpDiv.zIndex($(input).zIndex() + 1);
        $.datepicker._datepickerShowing = true;

        if ($.effects && $.effects.effect[showAnim]) {
          inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration);
        } else {
          inst.dpDiv[showAnim || 'show'](showAnim ? duration : null);
        }

        if ($.datepicker._shouldFocusInput(inst)) {
          inst.input.focus();
        }

        $.datepicker._curInst = inst;
      }
    },

    /* Generate the date picker content. */
    _updateDatepicker: function(inst) {
      this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
      instActive = inst; // for delegate hover events
      inst.dpDiv.empty().append(this._generateHTML(inst));
      this._attachHandlers(inst);
      inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();

      var origyearshtml,
        numMonths = this._getNumberOfMonths(inst),
        cols = numMonths[1],
        width = 17;

      inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
      if (cols > 1) {
        inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', width * cols + 'em');
      }
      inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? 'add' : 'remove') + 'Class']('ui-datepicker-multi');
      inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') + 'Class']('ui-datepicker-rtl');

      if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
        inst.input.focus();
      }

      // deffered render of the years select (to avoid flashes on Firefox)
      if (inst.yearshtml) {
        origyearshtml = inst.yearshtml;
        setTimeout(function() {
          //assure that inst.yearshtml didn't change.
          if (origyearshtml === inst.yearshtml && inst.yearshtml) {
            inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
          }
          origyearshtml = inst.yearshtml = null;
        }, 0);
      }
    },

    // #6694 - don't focus the input if it's already focused
    // this breaks the change event in IE
    // Support: IE and jQuery <1.9
    _shouldFocusInput: function(inst) {
      return inst.input && inst.input.is(':visible') && !inst.input.is(':disabled') && !inst.input.is(':focus');
    },

    /* Check positioning to remain on screen. */
    _checkOffset: function(inst, offset, isFixed) {
      var dpWidth = inst.dpDiv.outerWidth(),
        dpHeight = inst.dpDiv.outerHeight(),
        inputWidth = inst.input ? inst.input.outerWidth() : 0,
        inputHeight = inst.input ? inst.input.outerHeight() : 0,
        viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
        viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

      offset.left -= this._get(inst, 'isRTL') ? dpWidth - inputWidth : 0;
      offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
      offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;

      // now check if datepicker is showing outside window viewport - move to a better place if so.
      offset.left -= Math.min(
        offset.left,
        offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0
      );
      offset.top -= Math.min(
        offset.top,
        offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0
      );

      return offset;
    },

    /* Find an object's position on the screen. */
    _findPos: function(obj) {
      var position,
        inst = this._getInst(obj),
        isRTL = this._get(inst, 'isRTL');

      while (obj && (obj.type === 'hidden' || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
        obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
      }

      position = $(obj).offset();
      return [position.left, position.top];
    },

    /* Hide the date picker from view.
     * @param  input  element - the input field attached to the date picker
     */
    _hideDatepicker: function(input) {
      var showAnim,
        duration,
        postProcess,
        onClose,
        inst = this._curInst;

      if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
        return;
      }

      if (this._datepickerShowing) {
        showAnim = this._get(inst, 'showAnim');
        duration = this._get(inst, 'duration');
        postProcess = function() {
          $.datepicker._tidyDialog(inst);
        };

        // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
        if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
          inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
        } else {
          inst.dpDiv[showAnim === 'slideDown' ? 'slideUp' : showAnim === 'fadeIn' ? 'fadeOut' : 'hide'](
            showAnim ? duration : null,
            postProcess
          );
        }

        if (!showAnim) {
          postProcess();
        }
        this._datepickerShowing = false;

        onClose = this._get(inst, 'onClose');
        if (onClose) {
          onClose.apply(inst.input ? inst.input[0] : null, [inst.input ? inst.input.val() : '', inst]);
        }

        this._lastInput = null;
        if (this._inDialog) {
          this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
          if ($.blockUI) {
            $.unblockUI();
            $('body').append(this.dpDiv);
          }
        }
        this._inDialog = false;
      }
    },

    /* Tidy up after a dialog display. */
    _tidyDialog: function(inst) {
      inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
    },

    /* Close date picker if clicked elsewhere. */
    _checkExternalClick: function(event) {
      if (!$.datepicker._curInst) {
        return;
      }

      var $target = $(event.target),
        inst = $.datepicker._getInst($target[0]);

      if (
        ($target[0].id !== $.datepicker._mainDivId &&
          $target.parents('#' + $.datepicker._mainDivId).length === 0 &&
          !$target.hasClass($.datepicker.markerClassName) &&
          !$target.closest('.' + $.datepicker._triggerClass).length &&
          $.datepicker._datepickerShowing &&
          !($.datepicker._inDialog && $.blockUI)) ||
        ($target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst)
      ) {
        $.datepicker._hideDatepicker();
      }
    },

    /* Adjust one of the date sub-fields. */
    _adjustDate: function(id, offset, period) {
      var target = $(id),
        inst = this._getInst(target[0]);

      if (this._isDisabledDatepicker(target[0])) {
        return;
      }
      this._adjustInstDate(
        inst,
        offset + (period === 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
        period
      );
      this._updateDatepicker(inst);
    },

    /* Action for current link. */
    _gotoToday: function(id) {
      var date,
        target = $(id),
        inst = this._getInst(target[0]);

      if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
        inst.selectedDay = inst.currentDay;
        inst.drawMonth = inst.selectedMonth = inst.currentMonth;
        inst.drawYear = inst.selectedYear = inst.currentYear;
      } else {
        date = new Date();
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
      }
      this._notifyChange(inst);
      this._adjustDate(target);
    },

    /* Action for selecting a new month/year. */
    _selectMonthYear: function(id, select, period) {
      var target = $(id),
        inst = this._getInst(target[0]);

      inst['selected' + (period === 'M' ? 'Month' : 'Year')] = inst[
        'draw' + (period === 'M' ? 'Month' : 'Year')
      ] = parseInt(select.options[select.selectedIndex].value, 10);

      this._notifyChange(inst);
      this._adjustDate(target);
    },

    /* Action for selecting a day. */
    _selectDay: function(id, month, year, td) {
      var inst,
        target = $(id);

      if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
        return;
      }

      inst = this._getInst(target[0]);
      inst.selectedDay = inst.currentDay = $('a', td).html();
      inst.selectedMonth = inst.currentMonth = month;
      inst.selectedYear = inst.currentYear = year;
      this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
    },

    /* Erase the input field and hide the date picker. */
    _clearDate: function(id) {
      var target = $(id);
      this._selectDate(target, '');
    },

    /* Update the input field with the selected date. */
    _selectDate: function(id, dateStr) {
      var onSelect,
        target = $(id),
        inst = this._getInst(target[0]);

      dateStr = dateStr != null ? dateStr : this._formatDate(inst);
      if (inst.input) {
        inst.input.val(dateStr);
      }
      this._updateAlternate(inst);

      onSelect = this._get(inst, 'onSelect');
      if (onSelect) {
        onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]); // trigger custom callback
      } else if (inst.input) {
        inst.input.trigger('change'); // fire the change event
      }

      if (inst.inline) {
        this._updateDatepicker(inst);
      } else {
        this._hideDatepicker();
        this._lastInput = inst.input[0];
        if (typeof inst.input[0] !== 'object') {
          inst.input.focus(); // restore focus
        }
        this._lastInput = null;
      }
    },

    /* Update any alternate field to synchronise with the main field. */
    _updateAlternate: function(inst) {
      var altFormat,
        date,
        dateStr,
        altField = this._get(inst, 'altField');

      if (altField) {
        // update alternate field too
        altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
        date = this._getDate(inst);
        dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
        $(altField).each(function() {
          $(this).val(dateStr);
        });
      }
    },

    /* Set as beforeShowDay function to prevent selection of weekends.
     * @param  date  Date - the date to customise
     * @return [boolean, string] - is this date selectable?, what is its CSS class?
     */
    noWeekends: function(date) {
      var day = date.getDay();
      return [day > 0 && day < 6, ''];
    },

    /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
     * @param  date  Date - the date to get the week for
     * @return  number - the number of the week within the year that contains this date
     */
    iso8601Week: function(date) {
      var time,
        checkDate = new Date(date.getTime());

      // Find Thursday of this week starting on Monday
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

      time = checkDate.getTime();
      checkDate.setMonth(0); // Compare with Jan 1
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    },

    /* Parse a string value into a date object.
     * See formatDate below for the possible formats.
     *
     * @param  format string - the expected format of the date
     * @param  value string - the date in the above format
     * @param  settings Object - attributes include:
     *					shortYearCutoff  number - the cutoff year for determining the century (optional)
     *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
     *					dayNames		string[7] - names of the days from Sunday (optional)
     *					monthNamesShort string[12] - abbreviated names of the months (optional)
     *					monthNames		string[12] - names of the months (optional)
     * @return  Date - the extracted date value or null if value is blank
     */
    parseDate: function(format, value, settings) {
      if (format == null || value == null) {
        throw 'Invalid arguments';
      }

      value = typeof value === 'object' ? value.toString() : value + '';
      if (value === '') {
        return null;
      }

      var iFormat,
        dim,
        extra,
        iValue = 0,
        shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
        shortYearCutoff =
          typeof shortYearCutoffTemp !== 'string'
            ? shortYearCutoffTemp
            : (new Date().getFullYear() % 100) + parseInt(shortYearCutoffTemp, 10),
        dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
        dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
        monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
        monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
        year = -1,
        month = -1,
        day = -1,
        doy = -1,
        literal = false,
        date,
        // Check whether a format character is doubled
        lookAhead = function(match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        },
        // Extract a number from the string value
        getNumber = function(match) {
          var isDoubled = lookAhead(match),
            size = match === '@' ? 14 : match === '!' ? 20 : match === 'y' && isDoubled ? 4 : match === 'o' ? 3 : 2,
            digits = new RegExp('^\\d{1,' + size + '}'),
            num = value.substring(iValue).match(digits);
          if (!num) {
            throw 'Missing number at position ' + iValue;
          }
          iValue += num[0].length;
          return parseInt(num[0], 10);
        },
        // Extract a name from the string value and convert to an index
        getName = function(match, shortNames, longNames) {
          var index = -1,
            names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
              return [[k, v]];
            }).sort(function(a, b) {
              return -(a[1].length - b[1].length);
            });

          $.each(names, function(i, pair) {
            var name = pair[1];
            if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
              index = pair[0];
              iValue += name.length;
              return false;
            }
          });
          if (index !== -1) {
            return index + 1;
          } else {
            throw 'Unknown name at position ' + iValue;
          }
        },
        // Confirm that a literal character matches the string value
        checkLiteral = function() {
          if (value.charAt(iValue) !== format.charAt(iFormat)) {
            throw 'Unexpected literal at position ' + iValue;
          }
          iValue++;
        };

      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
            literal = false;
          } else {
            checkLiteral();
          }
        } else {
          switch (format.charAt(iFormat)) {
            case 'd':
              day = getNumber('d');
              break;
            case 'D':
              getName('D', dayNamesShort, dayNames);
              break;
            case 'o':
              doy = getNumber('o');
              break;
            case 'm':
              month = getNumber('m');
              break;
            case 'M':
              month = getName('M', monthNamesShort, monthNames);
              break;
            case 'y':
              year = getNumber('y');
              break;
            case '@':
              date = new Date(getNumber('@'));
              year = date.getFullYear();
              month = date.getMonth() + 1;
              day = date.getDate();
              break;
            case '!':
              date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
              year = date.getFullYear();
              month = date.getMonth() + 1;
              day = date.getDate();
              break;
            case "'":
              if (lookAhead("'")) {
                checkLiteral();
              } else {
                literal = true;
              }
              break;
            default:
              checkLiteral();
          }
        }
      }

      if (iValue < value.length) {
        extra = value.substr(iValue);
        if (!/^\s+/.test(extra)) {
          throw 'Extra/unparsed characters found in date: ' + extra;
        }
      }

      if (year === -1) {
        year = new Date().getFullYear();
      } else if (year < 100) {
        year += new Date().getFullYear() - (new Date().getFullYear() % 100) + (year <= shortYearCutoff ? 0 : -100);
      }

      if (doy > -1) {
        month = 1;
        day = doy;
        do {
          dim = this._getDaysInMonth(year, month - 1);
          if (day <= dim) {
            break;
          }
          month++;
          day -= dim;
        } while (true);
      }

      date = this._daylightSavingAdjust(new Date(year, month - 1, day));
      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
        throw 'Invalid date'; // E.g. 31/02/00
      }
      return date;
    },

    /* Standard date formats. */
    ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
    COOKIE: 'D, dd M yy',
    ISO_8601: 'yy-mm-dd',
    RFC_822: 'D, d M y',
    RFC_850: 'DD, dd-M-y',
    RFC_1036: 'D, d M y',
    RFC_1123: 'D, d M yy',
    RFC_2822: 'D, d M yy',
    RSS: 'D, d M y', // RFC 822
    TICKS: '!',
    TIMESTAMP: '@',
    W3C: 'yy-mm-dd', // ISO 8601

    _ticksTo1970:
      ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) *
      24 *
      60 *
      60 *
      10000000,

    /* Format a date object into a string value.
     * The format can be combinations of the following:
     * d  - day of month (no leading zero)
     * dd - day of month (two digit)
     * o  - day of year (no leading zeros)
     * oo - day of year (three digit)
     * D  - day name short
     * DD - day name long
     * m  - month of year (no leading zero)
     * mm - month of year (two digit)
     * M  - month name short
     * MM - month name long
     * y  - year (two digit)
     * yy - year (four digit)
     * @ - Unix timestamp (ms since 01/01/1970)
     * ! - Windows ticks (100ns since 01/01/0001)
     * "..." - literal text
     * '' - single quote
     *
     * @param  format string - the desired format of the date
     * @param  date Date - the date value to format
     * @param  settings Object - attributes include:
     *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
     *					dayNames		string[7] - names of the days from Sunday (optional)
     *					monthNamesShort string[12] - abbreviated names of the months (optional)
     *					monthNames		string[12] - names of the months (optional)
     * @return  string - the date in the above format
     */
    formatDate: function(format, date, settings) {
      if (!date) {
        return '';
      }

      var iFormat,
        dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
        dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
        monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
        monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
        // Check whether a format character is doubled
        lookAhead = function(match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        },
        // Format a number, with leading zero if necessary
        formatNumber = function(match, value, len) {
          var num = '' + value;
          if (lookAhead(match)) {
            while (num.length < len) {
              num = '0' + num;
            }
          }
          return num;
        },
        // Format a name, short or long as requested
        formatName = function(match, value, shortNames, longNames) {
          return lookAhead(match) ? longNames[value] : shortNames[value];
        },
        output = '',
        literal = false;

      if (date) {
        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
              literal = false;
            } else {
              output += format.charAt(iFormat);
            }
          } else {
            switch (format.charAt(iFormat)) {
              case 'd':
                output += formatNumber('d', date.getDate(), 2);
                break;
              case 'D':
                output += formatName('D', date.getDay(), dayNamesShort, dayNames);
                break;
              case 'o':
                output += formatNumber(
                  'o',
                  Math.round(
                    (new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() -
                      new Date(date.getFullYear(), 0, 0).getTime()) /
                      86400000
                  ),
                  3
                );
                break;
              case 'm':
                output += formatNumber('m', date.getMonth() + 1, 2);
                break;
              case 'M':
                output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
                break;
              case 'y':
                output += lookAhead('y')
                  ? date.getFullYear()
                  : (date.getYear() % 100 < 10 ? '0' : '') + (date.getYear() % 100);
                break;
              case '@':
                output += date.getTime();
                break;
              case '!':
                output += date.getTime() * 10000 + this._ticksTo1970;
                break;
              case "'":
                if (lookAhead("'")) {
                  output += "'";
                } else {
                  literal = true;
                }
                break;
              default:
                output += format.charAt(iFormat);
            }
          }
        }
      }
      return output;
    },

    /* Extract all possible characters from the date format. */
    _possibleChars: function(format) {
      var iFormat,
        chars = '',
        literal = false,
        // Check whether a format character is doubled
        lookAhead = function(match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        };

      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
            literal = false;
          } else {
            chars += format.charAt(iFormat);
          }
        } else {
          switch (format.charAt(iFormat)) {
            case 'd':
            case 'm':
            case 'y':
            case '@':
              chars += '0123456789';
              break;
            case 'D':
            case 'M':
              return null; // Accept anything
            case "'":
              if (lookAhead("'")) {
                chars += "'";
              } else {
                literal = true;
              }
              break;
            default:
              chars += format.charAt(iFormat);
          }
        }
      }
      return chars;
    },

    /* Get a setting value, defaulting if necessary. */
    _get: function(inst, name) {
      return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
    },

    /* Parse existing date and initialise date picker. */
    _setDateFromField: function(inst, noDefault) {
      if (inst.input.val() === inst.lastVal) {
        return;
      }

      var dateFormat = this._get(inst, 'dateFormat'),
        dates = (inst.lastVal = inst.input ? inst.input.val() : null),
        defaultDate = this._getDefaultDate(inst),
        date = defaultDate,
        settings = this._getFormatConfig(inst);

      try {
        date = this.parseDate(dateFormat, dates, settings) || defaultDate;
      } catch (event) {
        dates = noDefault ? '' : dates;
      }
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      inst.currentDay = dates ? date.getDate() : 0;
      inst.currentMonth = dates ? date.getMonth() : 0;
      inst.currentYear = dates ? date.getFullYear() : 0;
      this._adjustInstDate(inst);
    },

    /* Retrieve the default date shown on opening. */
    _getDefaultDate: function(inst) {
      return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
    },

    /* A date may be specified as an exact value or a relative one. */
    _determineDate: function(inst, date, defaultDate) {
      var offsetNumeric = function(offset) {
          var date = new Date();
          date.setDate(date.getDate() + offset);
          return date;
        },
        offsetString = function(offset) {
          try {
            return $.datepicker.parseDate(
              $.datepicker._get(inst, 'dateFormat'),
              offset,
              $.datepicker._getFormatConfig(inst)
            );
          } catch (e) {
            // Ignore
          }

          var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(),
            year = date.getFullYear(),
            month = date.getMonth(),
            day = date.getDate(),
            pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
            matches = pattern.exec(offset);

          while (matches) {
            switch (matches[2] || 'd') {
              case 'd':
              case 'D':
                day += parseInt(matches[1], 10);
                break;
              case 'w':
              case 'W':
                day += parseInt(matches[1], 10) * 7;
                break;
              case 'm':
              case 'M':
                month += parseInt(matches[1], 10);
                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                break;
              case 'y':
              case 'Y':
                year += parseInt(matches[1], 10);
                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                break;
            }
            matches = pattern.exec(offset);
          }
          return new Date(year, month, day);
        },
        newDate =
          date == null || date === ''
            ? defaultDate
            : typeof date === 'string'
            ? offsetString(date)
            : typeof date === 'number'
            ? isNaN(date)
              ? defaultDate
              : offsetNumeric(date)
            : new Date(date.getTime());

      newDate = newDate && newDate.toString() === 'Invalid Date' ? defaultDate : newDate;
      if (newDate) {
        newDate.setHours(0);
        newDate.setMinutes(0);
        newDate.setSeconds(0);
        newDate.setMilliseconds(0);
      }
      return this._daylightSavingAdjust(newDate);
    },

    /* Handle switch to/from daylight saving.
     * Hours may be non-zero on daylight saving cut-over:
     * > 12 when midnight changeover, but then cannot generate
     * midnight datetime, so jump to 1AM, otherwise reset.
     * @param  date  (Date) the date to check
     * @return  (Date) the corrected date
     */
    _daylightSavingAdjust: function(date) {
      if (!date) {
        return null;
      }
      date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
      return date;
    },

    /* Set the date(s) directly. */
    _setDate: function(inst, date, noChange) {
      var clear = !date,
        origMonth = inst.selectedMonth,
        origYear = inst.selectedYear,
        newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

      inst.selectedDay = inst.currentDay = newDate.getDate();
      inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
      inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
      if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
        this._notifyChange(inst);
      }
      this._adjustInstDate(inst);
      if (inst.input) {
        inst.input.val(clear ? '' : this._formatDate(inst));
      }
    },

    /* Retrieve the date(s) directly. */
    _getDate: function(inst) {
      var startDate =
        !inst.currentYear || (inst.input && inst.input.val() === '')
          ? null
          : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
      return startDate;
    },

    /* Attach the onxxx handlers.  These are declared statically so
     * they work with static code transformers like Caja.
     */
    _attachHandlers: function(inst) {
      var stepMonths = this._get(inst, 'stepMonths'),
        id = '#' + inst.id.replace(/\\\\/g, '\\');
      inst.dpDiv.find('[data-handler]').map(function() {
        var handler = {
          prev: function() {
            $.datepicker._adjustDate(id, -stepMonths, 'M');
          },
          next: function() {
            $.datepicker._adjustDate(id, +stepMonths, 'M');
          },
          hide: function() {
            $.datepicker._hideDatepicker();
          },
          today: function() {
            $.datepicker._gotoToday(id);
          },
          selectDay: function() {
            $.datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
            return false;
          },
          selectMonth: function() {
            $.datepicker._selectMonthYear(id, this, 'M');
            return false;
          },
          selectYear: function() {
            $.datepicker._selectMonthYear(id, this, 'Y');
            return false;
          },
        };
        $(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
      });
    },

    /* Generate the HTML for the current state of the date picker. */
    _generateHTML: function(inst) {
      var maxDraw,
        prevText,
        prev,
        nextText,
        next,
        currentText,
        gotoDate,
        controls,
        buttonPanel,
        firstDay,
        showWeek,
        dayNames,
        dayNamesMin,
        monthNames,
        monthNamesShort,
        beforeShowDay,
        showOtherMonths,
        selectOtherMonths,
        defaultDate,
        html,
        dow,
        row,
        group,
        col,
        selectedDate,
        cornerClass,
        calender,
        thead,
        day,
        daysInMonth,
        leadDays,
        curRows,
        numRows,
        printDate,
        dRow,
        tbody,
        daySettings,
        otherMonth,
        unselectable,
        tempDate = new Date(),
        today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
        isRTL = this._get(inst, 'isRTL'),
        showButtonPanel = this._get(inst, 'showButtonPanel'),
        hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext'),
        navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat'),
        numMonths = this._getNumberOfMonths(inst),
        showCurrentAtPos = this._get(inst, 'showCurrentAtPos'),
        stepMonths = this._get(inst, 'stepMonths'),
        isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1,
        currentDate = this._daylightSavingAdjust(
          !inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)
        ),
        minDate = this._getMinMaxDate(inst, 'min'),
        maxDate = this._getMinMaxDate(inst, 'max'),
        drawMonth = inst.drawMonth - showCurrentAtPos,
        drawYear = inst.drawYear;

      if (drawMonth < 0) {
        drawMonth += 12;
        drawYear--;
      }
      if (maxDate) {
        maxDraw = this._daylightSavingAdjust(
          new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate())
        );
        maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
        while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
          drawMonth--;
          if (drawMonth < 0) {
            drawMonth = 11;
            drawYear--;
          }
        }
      }
      inst.drawMonth = drawMonth;
      inst.drawYear = drawYear;

      prevText = this._get(inst, 'prevText');
      prevText = !navigationAsDateFormat
        ? prevText
        : this.formatDate(
            prevText,
            this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
            this._getFormatConfig(inst)
          );

      prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth)
        ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
          " title='" +
          prevText +
          "'><span class='ui-icon ui-icon-circle-triangle-" +
          (isRTL ? 'e' : 'w') +
          "'>" +
          prevText +
          '</span></a>'
        : hideIfNoPrevNext
        ? ''
        : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" +
          prevText +
          "'><span class='ui-icon ui-icon-circle-triangle-" +
          (isRTL ? 'e' : 'w') +
          "'>" +
          prevText +
          '</span></a>';

      nextText = this._get(inst, 'nextText');
      nextText = !navigationAsDateFormat
        ? nextText
        : this.formatDate(
            nextText,
            this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
            this._getFormatConfig(inst)
          );

      next = this._canAdjustMonth(inst, +1, drawYear, drawMonth)
        ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
          " title='" +
          nextText +
          "'><span class='ui-icon ui-icon-circle-triangle-" +
          (isRTL ? 'w' : 'e') +
          "'>" +
          nextText +
          '</span></a>'
        : hideIfNoPrevNext
        ? ''
        : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" +
          nextText +
          "'><span class='ui-icon ui-icon-circle-triangle-" +
          (isRTL ? 'w' : 'e') +
          "'>" +
          nextText +
          '</span></a>';

      currentText = this._get(inst, 'currentText');
      gotoDate = this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today;
      currentText = !navigationAsDateFormat
        ? currentText
        : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));

      controls = !inst.inline
        ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
          this._get(inst, 'closeText') +
          '</button>'
        : '';

      buttonPanel = showButtonPanel
        ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" +
          (isRTL ? controls : '') +
          (this._isInRange(inst, gotoDate)
            ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
              '>' +
              currentText +
              '</button>'
            : '') +
          (isRTL ? '' : controls) +
          '</div>'
        : '';

      firstDay = parseInt(this._get(inst, 'firstDay'), 10);
      firstDay = isNaN(firstDay) ? 0 : firstDay;

      showWeek = this._get(inst, 'showWeek');
      dayNames = this._get(inst, 'dayNames');
      dayNamesMin = this._get(inst, 'dayNamesMin');
      monthNames = this._get(inst, 'monthNames');
      monthNamesShort = this._get(inst, 'monthNamesShort');
      beforeShowDay = this._get(inst, 'beforeShowDay');
      showOtherMonths = this._get(inst, 'showOtherMonths');
      selectOtherMonths = this._get(inst, 'selectOtherMonths');
      defaultDate = this._getDefaultDate(inst);
      html = '';
      dow;
      for (row = 0; row < numMonths[0]; row++) {
        group = '';
        this.maxRows = 4;
        for (col = 0; col < numMonths[1]; col++) {
          selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
          cornerClass = ' ui-corner-all';
          calender = '';
          if (isMultiMonth) {
            calender += "<div class='ui-datepicker-group";
            if (numMonths[1] > 1) {
              switch (col) {
                case 0:
                  calender += ' ui-datepicker-group-first';
                  cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left');
                  break;
                case numMonths[1] - 1:
                  calender += ' ui-datepicker-group-last';
                  cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right');
                  break;
                default:
                  calender += ' ui-datepicker-group-middle';
                  cornerClass = '';
                  break;
              }
            }
            calender += "'>";
          }
          calender +=
            "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" +
            cornerClass +
            "'>" +
            (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : '') +
            (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : '') +
            this._generateMonthYearHeader(
              inst,
              drawMonth,
              drawYear,
              minDate,
              maxDate,
              row > 0 || col > 0,
              monthNames,
              monthNamesShort
            ) + // draw month headers
            "</div><table class='ui-datepicker-calendar'><thead>" +
            '<tr>';
          thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, 'weekHeader') + '</th>' : '';
          for (dow = 0; dow < 7; dow++) {
            // days of the week
            day = (dow + firstDay) % 7;
            thead +=
              '<th' +
              ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : '') +
              '>' +
              "<span title='" +
              dayNames[day] +
              "'>" +
              dayNamesMin[day] +
              '</span></th>';
          }
          calender += thead + '</tr></thead><tbody>';
          daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
          if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
          }
          leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
          curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
          numRows = isMultiMonth ? (this.maxRows > curRows ? this.maxRows : curRows) : curRows; //If multiple months, use the higher number of rows (see #7043)
          this.maxRows = numRows;
          printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
          for (dRow = 0; dRow < numRows; dRow++) {
            // create date picker rows
            calender += '<tr>';
            tbody = !showWeek
              ? ''
              : "<td class='ui-datepicker-week-col'>" + this._get(inst, 'calculateWeek')(printDate) + '</td>';
            for (dow = 0; dow < 7; dow++) {
              // create date picker days
              daySettings = beforeShowDay
                ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate])
                : [true, ''];
              otherMonth = printDate.getMonth() !== drawMonth;
              unselectable =
                (otherMonth && !selectOtherMonths) ||
                !daySettings[0] ||
                (minDate && printDate < minDate) ||
                (maxDate && printDate > maxDate);
              tbody +=
                "<td class='" +
                ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
                (otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
                ((printDate.getTime() === selectedDate.getTime() &&
                  drawMonth === inst.selectedMonth &&
                  inst._keyEvent) || // user pressed key
                (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime())
                  ? // or defaultDate is current printedDate and defaultDate is selectedDate
                    ' ' + this._dayOverClass
                  : '') + // highlight selected day
                (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled' : '') + // highlight unselectable days
                (otherMonth && !showOtherMonths
                  ? ''
                  : ' ' +
                    daySettings[1] + // highlight custom dates
                    (printDate.getTime() === currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
                    (printDate.getTime() === today.getTime() ? ' ui-datepicker-today' : '')) +
                "'" + // highlight today (if different)
                ((!otherMonth || showOtherMonths) && daySettings[2]
                  ? " title='" + daySettings[2].replace(/'/g, '&#39;') + "'"
                  : '') + // cell title
                (unselectable
                  ? ''
                  : " data-handler='selectDay' data-event='click' data-month='" +
                    printDate.getMonth() +
                    "' data-year='" +
                    printDate.getFullYear() +
                    "'") +
                '>' + // actions
                (otherMonth && !showOtherMonths
                  ? '&#xa0;' // display for other months
                  : unselectable
                  ? "<span class='ui-state-default'>" + printDate.getDate() + '</span>'
                  : "<a class='ui-state-default" +
                    (printDate.getTime() === today.getTime() ? ' ui-state-highlight' : '') +
                    (printDate.getTime() === currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
                    (otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
                    "' href='#'>" +
                    printDate.getDate() +
                    '</a>') +
                '</td>'; // display selectable date
              printDate.setDate(printDate.getDate() + 1);
              printDate = this._daylightSavingAdjust(printDate);
            }
            calender += tbody + '</tr>';
          }
          drawMonth++;
          if (drawMonth > 11) {
            drawMonth = 0;
            drawYear++;
          }
          calender +=
            '</tbody></table>' +
            (isMultiMonth
              ? '</div>' +
                (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : '')
              : '');
          group += calender;
        }
        html += group;
      }
      html += buttonPanel;
      inst._keyEvent = false;
      return html;
    },

    /* Generate the month and year header. */
    _generateMonthYearHeader: function(
      inst,
      drawMonth,
      drawYear,
      minDate,
      maxDate,
      secondary,
      monthNames,
      monthNamesShort
    ) {
      var inMinYear,
        inMaxYear,
        month,
        years,
        thisYear,
        determineYear,
        year,
        endYear,
        changeMonth = this._get(inst, 'changeMonth'),
        changeYear = this._get(inst, 'changeYear'),
        showMonthAfterYear = this._get(inst, 'showMonthAfterYear'),
        html = "<div class='ui-datepicker-title'>",
        monthHtml = '';

      // month selection
      if (secondary || !changeMonth) {
        monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + '</span>';
      } else {
        inMinYear = minDate && minDate.getFullYear() === drawYear;
        inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
        monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
        for (month = 0; month < 12; month++) {
          if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
            monthHtml +=
              "<option value='" +
              month +
              "'" +
              (month === drawMonth ? " selected='selected'" : '') +
              '>' +
              monthNamesShort[month] +
              '</option>';
          }
        }
        monthHtml += '</select>';
      }

      if (!showMonthAfterYear) {
        html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
      }

      // year selection
      if (!inst.yearshtml) {
        inst.yearshtml = '';
        if (secondary || !changeYear) {
          html += "<span class='ui-datepicker-year'>" + drawYear + '</span>';
        } else {
          // determine range of years to display
          years = this._get(inst, 'yearRange').split(':');
          thisYear = new Date().getFullYear();
          determineYear = function(value) {
            var year = value.match(/c[+\-].*/)
              ? drawYear + parseInt(value.substring(1), 10)
              : value.match(/[+\-].*/)
              ? thisYear + parseInt(value, 10)
              : parseInt(value, 10);
            return isNaN(year) ? thisYear : year;
          };
          year = determineYear(years[0]);
          endYear = Math.max(year, determineYear(years[1] || ''));
          year = minDate ? Math.max(year, minDate.getFullYear()) : year;
          endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
          inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
          for (; year <= endYear; year++) {
            inst.yearshtml +=
              "<option value='" +
              year +
              "'" +
              (year === drawYear ? " selected='selected'" : '') +
              '>' +
              year +
              '</option>';
          }
          inst.yearshtml += '</select>';

          html += inst.yearshtml;
          inst.yearshtml = null;
        }
      }

      html += this._get(inst, 'yearSuffix');
      if (showMonthAfterYear) {
        html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
      }
      html += '</div>'; // Close datepicker_header
      return html;
    },

    /* Adjust one of the date sub-fields. */
    _adjustInstDate: function(inst, offset, period) {
      var year = inst.drawYear + (period === 'Y' ? offset : 0),
        month = inst.drawMonth + (period === 'M' ? offset : 0),
        day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === 'D' ? offset : 0),
        date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      if (period === 'M' || period === 'Y') {
        this._notifyChange(inst);
      }
    },

    /* Ensure a date is within any min/max bounds. */
    _restrictMinMax: function(inst, date) {
      var minDate = this._getMinMaxDate(inst, 'min'),
        maxDate = this._getMinMaxDate(inst, 'max'),
        newDate = minDate && date < minDate ? minDate : date;
      return maxDate && newDate > maxDate ? maxDate : newDate;
    },

    /* Notify change of month/year. */
    _notifyChange: function(inst) {
      var onChange = this._get(inst, 'onChangeMonthYear');
      if (onChange) {
        onChange.apply(inst.input ? inst.input[0] : null, [inst.selectedYear, inst.selectedMonth + 1, inst]);
      }
    },

    /* Determine the number of months to show. */
    _getNumberOfMonths: function(inst) {
      var numMonths = this._get(inst, 'numberOfMonths');
      return numMonths == null ? [1, 1] : typeof numMonths === 'number' ? [1, numMonths] : numMonths;
    },

    /* Determine the current maximum date - ensure no time components are set. */
    _getMinMaxDate: function(inst, minMax) {
      return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
    },

    /* Find the number of days in a given month. */
    _getDaysInMonth: function(year, month) {
      return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
    },

    /* Find the day of the week of the first of a month. */
    _getFirstDayOfMonth: function(year, month) {
      return new Date(year, month, 1).getDay();
    },

    /* Determines if we should allow a "next/prev" month display change. */
    _canAdjustMonth: function(inst, offset, curYear, curMonth) {
      var numMonths = this._getNumberOfMonths(inst),
        date = this._daylightSavingAdjust(
          new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1)
        );

      if (offset < 0) {
        date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
      }
      return this._isInRange(inst, date);
    },

    /* Is the given date in the accepted range? */
    _isInRange: function(inst, date) {
      var yearSplit,
        currentYear,
        minDate = this._getMinMaxDate(inst, 'min'),
        maxDate = this._getMinMaxDate(inst, 'max'),
        minYear = null,
        maxYear = null,
        years = this._get(inst, 'yearRange');
      if (years) {
        yearSplit = years.split(':');
        currentYear = new Date().getFullYear();
        minYear = parseInt(yearSplit[0], 10);
        maxYear = parseInt(yearSplit[1], 10);
        if (yearSplit[0].match(/[+\-].*/)) {
          minYear += currentYear;
        }
        if (yearSplit[1].match(/[+\-].*/)) {
          maxYear += currentYear;
        }
      }

      return (
        (!minDate || date.getTime() >= minDate.getTime()) &&
        (!maxDate || date.getTime() <= maxDate.getTime()) &&
        (!minYear || date.getFullYear() >= minYear) &&
        (!maxYear || date.getFullYear() <= maxYear)
      );
    },

    /* Provide the configuration settings for formatting/parsing. */
    _getFormatConfig: function(inst) {
      var shortYearCutoff = this._get(inst, 'shortYearCutoff');
      shortYearCutoff =
        typeof shortYearCutoff !== 'string'
          ? shortYearCutoff
          : (new Date().getFullYear() % 100) + parseInt(shortYearCutoff, 10);
      return {
        shortYearCutoff: shortYearCutoff,
        dayNamesShort: this._get(inst, 'dayNamesShort'),
        dayNames: this._get(inst, 'dayNames'),
        monthNamesShort: this._get(inst, 'monthNamesShort'),
        monthNames: this._get(inst, 'monthNames'),
      };
    },

    /* Format the given date for display. */
    _formatDate: function(inst, day, month, year) {
      if (!day) {
        inst.currentDay = inst.selectedDay;
        inst.currentMonth = inst.selectedMonth;
        inst.currentYear = inst.selectedYear;
      }
      var date = day
        ? typeof day === 'object'
          ? day
          : this._daylightSavingAdjust(new Date(year, month, day))
        : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
      return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
    },
  });

  /*
   * Bind hover events for datepicker elements.
   * Done via delegate so the binding only occurs once in the lifetime of the parent div.
   * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
   */
  function bindHover(dpDiv) {
    var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
    return dpDiv
      .delegate(selector, 'mouseout', function() {
        $(this).removeClass('ui-state-hover');
        if (this.className.indexOf('ui-datepicker-prev') !== -1) {
          $(this).removeClass('ui-datepicker-prev-hover');
        }
        if (this.className.indexOf('ui-datepicker-next') !== -1) {
          $(this).removeClass('ui-datepicker-next-hover');
        }
      })
      .delegate(selector, 'mouseover', function() {
        if (!$.datepicker._isDisabledDatepicker(instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
          $(this)
            .parents('.ui-datepicker-calendar')
            .find('a')
            .removeClass('ui-state-hover');
          $(this).addClass('ui-state-hover');
          if (this.className.indexOf('ui-datepicker-prev') !== -1) {
            $(this).addClass('ui-datepicker-prev-hover');
          }
          if (this.className.indexOf('ui-datepicker-next') !== -1) {
            $(this).addClass('ui-datepicker-next-hover');
          }
        }
      });
  }

  /* jQuery extend now ignores nulls! */
  function extendRemove(target, props) {
    $.extend(target, props);
    for (var name in props) {
      if (props[name] == null) {
        target[name] = props[name];
      }
    }
    return target;
  }

  /* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
  $.fn.datepicker = function(options) {
    /* Verify an empty collection wasn't passed - Fixes #6976 */
    if (!this.length) {
      return this;
    }

    /* Initialise the date picker. */
    if (!$.datepicker.initialized) {
      $(document).mousedown($.datepicker._checkExternalClick);
      $.datepicker.initialized = true;
    }

    /* Append datepicker main container to body if not exist. */
    if ($('#' + $.datepicker._mainDivId).length === 0) {
      $('body').append($.datepicker.dpDiv);
    }

    var otherArgs = Array.prototype.slice.call(arguments, 1);
    if (typeof options === 'string' && (options === 'isDisabled' || options === 'getDate' || options === 'widget')) {
      return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
    }
    if (options === 'option' && arguments.length === 2 && typeof arguments[1] === 'string') {
      return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
    }
    return this.each(function() {
      typeof options === 'string'
        ? $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this].concat(otherArgs))
        : $.datepicker._attachDatepicker(this, options);
    });
  };

  $.datepicker = new Datepicker(); // singleton instance
  $.datepicker.initialized = false;
  $.datepicker.uuid = new Date().getTime();
  $.datepicker.version = '1.10.3';
})(jQuery);

(function($, undefined) {
  var sizeRelatedOptions = {
      buttons: true,
      height: true,
      maxHeight: true,
      maxWidth: true,
      minHeight: true,
      minWidth: true,
      width: true,
    },
    resizableRelatedOptions = {
      maxHeight: true,
      maxWidth: true,
      minHeight: true,
      minWidth: true,
    };

  $.widget('ui.dialog', {
    version: '1.10.3',
    options: {
      appendTo: 'body',
      autoOpen: true,
      buttons: [],
      closeOnEscape: true,
      closeText: 'close',
      dialogClass: '',
      draggable: true,
      hide: null,
      height: 'auto',
      maxHeight: null,
      maxWidth: null,
      minHeight: 150,
      minWidth: 150,
      modal: false,
      position: {
        my: 'center',
        at: 'center',
        of: window,
        collision: 'fit',
        // Ensure the titlebar is always visible
        using: function(pos) {
          var topOffset = $(this)
            .css(pos)
            .offset().top;
          if (topOffset < 0) {
            $(this).css('top', pos.top - topOffset);
          }
        },
      },
      resizable: true,
      show: null,
      title: null,
      width: 300,

      // callbacks
      beforeClose: null,
      close: null,
      drag: null,
      dragStart: null,
      dragStop: null,
      focus: null,
      open: null,
      resize: null,
      resizeStart: null,
      resizeStop: null,
    },

    _create: function() {
      this.originalCss = {
        display: this.element[0].style.display,
        width: this.element[0].style.width,
        minHeight: this.element[0].style.minHeight,
        maxHeight: this.element[0].style.maxHeight,
        height: this.element[0].style.height,
      };
      this.originalPosition = {
        parent: this.element.parent(),
        index: this.element
          .parent()
          .children()
          .index(this.element),
      };
      this.originalTitle = this.element.attr('title');
      this.options.title = this.options.title || this.originalTitle;

      this._createWrapper();

      this.element
        .show()
        .removeAttr('title')
        .addClass('ui-dialog-content ui-widget-content')
        .appendTo(this.uiDialog);

      this._createTitlebar();
      this._createButtonPane();

      if (this.options.draggable && $.fn.draggable) {
        this._makeDraggable();
      }
      if (this.options.resizable && $.fn.resizable) {
        this._makeResizable();
      }

      this._isOpen = false;
    },

    _init: function() {
      if (this.options.autoOpen) {
        this.open();
      }
    },

    _appendTo: function() {
      var element = this.options.appendTo;
      if (element && (element.jquery || element.nodeType)) {
        return $(element);
      }
      return this.document.find(element || 'body').eq(0);
    },

    _destroy: function() {
      var next,
        originalPosition = this.originalPosition;

      this._destroyOverlay();

      this.element
        .removeUniqueId()
        .removeClass('ui-dialog-content ui-widget-content')
        .css(this.originalCss)
        // Without detaching first, the following becomes really slow
        .detach();

      this.uiDialog.stop(true, true).remove();

      if (this.originalTitle) {
        this.element.attr('title', this.originalTitle);
      }

      next = originalPosition.parent.children().eq(originalPosition.index);
      // Don't try to place the dialog next to itself (#8613)
      if (next.length && next[0] !== this.element[0]) {
        next.before(this.element);
      } else {
        originalPosition.parent.append(this.element);
      }
    },

    widget: function() {
      return this.uiDialog;
    },

    disable: $.noop,
    enable: $.noop,

    close: function(event) {
      var that = this;

      if (!this._isOpen || this._trigger('beforeClose', event) === false) {
        return;
      }

      this._isOpen = false;
      this._destroyOverlay();

      if (!this.opener.filter(':focusable').focus().length) {
        // Hiding a focused element doesn't trigger blur in WebKit
        // so in case we have nothing to focus on, explicitly blur the active element
        // https://bugs.webkit.org/show_bug.cgi?id=47182
        $(this.document[0].activeElement).blur();
      }

      this._hide(this.uiDialog, this.options.hide, function() {
        that._trigger('close', event);
      });
    },

    isOpen: function() {
      return this._isOpen;
    },

    moveToTop: function() {
      this._moveToTop();
    },

    _moveToTop: function(event, silent) {
      var moved = !!this.uiDialog.nextAll(':visible').insertBefore(this.uiDialog).length;
      if (moved && !silent) {
        this._trigger('focus', event);
      }
      return moved;
    },

    open: function() {
      var that = this;
      if (this._isOpen) {
        if (this._moveToTop()) {
          this._focusTabbable();
        }
        return;
      }

      this._isOpen = true;
      this.opener = $(this.document[0].activeElement);

      this._size();
      this._position();
      this._createOverlay();
      this._moveToTop(null, true);
      this._show(this.uiDialog, this.options.show, function() {
        that._focusTabbable();
        that._trigger('focus');
      });

      this._trigger('open');
    },

    _focusTabbable: function() {
      // Set focus to the first match:
      // 1. First element inside the dialog matching [autofocus]
      // 2. Tabbable element inside the content element
      // 3. Tabbable element inside the buttonpane
      // 4. The close button
      // 5. The dialog itself
      var hasFocus = this.element.find('[autofocus]');
      if (!hasFocus.length) {
        hasFocus = this.element.find(':tabbable');
      }
      if (!hasFocus.length) {
        hasFocus = this.uiDialogButtonPane.find(':tabbable');
      }
      if (!hasFocus.length) {
        hasFocus = this.uiDialogTitlebarClose.filter(':tabbable');
      }
      if (!hasFocus.length) {
        hasFocus = this.uiDialog;
      }
      hasFocus.eq(0).focus();
    },

    _keepFocus: function(event) {
      function checkFocus() {
        var activeElement = this.document[0].activeElement,
          isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
        if (!isActive) {
          this._focusTabbable();
        }
      }
      event.preventDefault();
      checkFocus.call(this);
      // support: IE
      // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
      // so we check again later
      this._delay(checkFocus);
    },

    _createWrapper: function() {
      this.uiDialog = $('<div>')
        .addClass('ui-dialog ui-widget ui-widget-content ui-corner-all ui-front ' + this.options.dialogClass)
        .hide()
        .attr({
          // Setting tabIndex makes the div focusable
          tabIndex: -1,
          role: 'dialog',
        })
        .appendTo(this._appendTo());

      this._on(this.uiDialog, {
        keydown: function(event) {
          if (
            this.options.closeOnEscape &&
            !event.isDefaultPrevented() &&
            event.keyCode &&
            event.keyCode === $.ui.keyCode.ESCAPE
          ) {
            event.preventDefault();
            this.close(event);
            return;
          }

          // prevent tabbing out of dialogs
          if (event.keyCode !== $.ui.keyCode.TAB) {
            return;
          }
          var tabbables = this.uiDialog.find(':tabbable'),
            first = tabbables.filter(':first'),
            last = tabbables.filter(':last');

          if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
            first.focus(1);
            event.preventDefault();
          } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
            last.focus(1);
            event.preventDefault();
          }
        },
        mousedown: function(event) {
          if (this._moveToTop(event)) {
            this._focusTabbable();
          }
        },
      });

      // We assume that any existing aria-describedby attribute means
      // that the dialog content is marked up properly
      // otherwise we brute force the content as the description
      if (!this.element.find('[aria-describedby]').length) {
        this.uiDialog.attr({
          'aria-describedby': this.element.uniqueId().attr('id'),
        });
      }
    },

    _createTitlebar: function() {
      var uiDialogTitle;

      this.uiDialogTitlebar = $('<div>')
        .addClass('ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix')
        .prependTo(this.uiDialog);
      this._on(this.uiDialogTitlebar, {
        mousedown: function(event) {
          // Don't prevent click on close button (#8838)
          // Focusing a dialog that is partially scrolled out of view
          // causes the browser to scroll it into view, preventing the click event
          if (!$(event.target).closest('.ui-dialog-titlebar-close')) {
            // Dialog isn't getting focus when dragging (#8063)
            this.uiDialog.focus();
          }
        },
      });

      this.uiDialogTitlebarClose = $('<button></button>')
        .button({
          label: this.options.closeText,
          icons: {
            primary: 'ui-icon-closethick',
          },
          text: false,
        })
        .addClass('ui-dialog-titlebar-close')
        .appendTo(this.uiDialogTitlebar);
      this._on(this.uiDialogTitlebarClose, {
        click: function(event) {
          event.preventDefault();
          this.close(event);
        },
      });

      uiDialogTitle = $('<span>')
        .uniqueId()
        .addClass('ui-dialog-title')
        .prependTo(this.uiDialogTitlebar);
      this._title(uiDialogTitle);

      this.uiDialog.attr({
        'aria-labelledby': uiDialogTitle.attr('id'),
      });
    },

    _title: function(title) {
      if (!this.options.title) {
        title.html('&#160;');
      }
      title.text(this.options.title);
    },

    _createButtonPane: function() {
      this.uiDialogButtonPane = $('<div>').addClass('ui-dialog-buttonpane ui-widget-content ui-helper-clearfix');

      this.uiButtonSet = $('<div>')
        .addClass('ui-dialog-buttonset')
        .appendTo(this.uiDialogButtonPane);

      this._createButtons();
    },

    _createButtons: function() {
      var that = this,
        buttons = this.options.buttons;

      // if we already have a button pane, remove it
      this.uiDialogButtonPane.remove();
      this.uiButtonSet.empty();

      if ($.isEmptyObject(buttons) || ($.isArray(buttons) && !buttons.length)) {
        this.uiDialog.removeClass('ui-dialog-buttons');
        return;
      }

      $.each(buttons, function(name, props) {
        var click, buttonOptions;
        props = $.isFunction(props) ? { click: props, text: name } : props;
        // Default to a non-submitting button
        props = $.extend({ type: 'button' }, props);
        // Change the context for the click callback to be the main element
        click = props.click;
        props.click = function() {
          click.apply(that.element[0], arguments);
        };
        buttonOptions = {
          icons: props.icons,
          text: props.showText,
        };
        delete props.icons;
        delete props.showText;
        $('<button></button>', props)
          .button(buttonOptions)
          .appendTo(that.uiButtonSet);
      });
      this.uiDialog.addClass('ui-dialog-buttons');
      this.uiDialogButtonPane.appendTo(this.uiDialog);
    },

    _makeDraggable: function() {
      var that = this,
        options = this.options;

      function filteredUi(ui) {
        return {
          position: ui.position,
          offset: ui.offset,
        };
      }

      this.uiDialog.draggable({
        cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
        handle: '.ui-dialog-titlebar',
        containment: 'document',
        start: function(event, ui) {
          $(this).addClass('ui-dialog-dragging');
          that._blockFrames();
          that._trigger('dragStart', event, filteredUi(ui));
        },
        drag: function(event, ui) {
          that._trigger('drag', event, filteredUi(ui));
        },
        stop: function(event, ui) {
          options.position = [
            ui.position.left - that.document.scrollLeft(),
            ui.position.top - that.document.scrollTop(),
          ];
          $(this).removeClass('ui-dialog-dragging');
          that._unblockFrames();
          that._trigger('dragStop', event, filteredUi(ui));
        },
      });
    },

    _makeResizable: function() {
      var that = this,
        options = this.options,
        handles = options.resizable,
        // .ui-resizable has position: relative defined in the stylesheet
        // but dialogs have to use absolute or fixed positioning
        position = this.uiDialog.css('position'),
        resizeHandles = typeof handles === 'string' ? handles : 'n,e,s,w,se,sw,ne,nw';

      function filteredUi(ui) {
        return {
          originalPosition: ui.originalPosition,
          originalSize: ui.originalSize,
          position: ui.position,
          size: ui.size,
        };
      }

      this.uiDialog
        .resizable({
          cancel: '.ui-dialog-content',
          containment: 'document',
          alsoResize: this.element,
          maxWidth: options.maxWidth,
          maxHeight: options.maxHeight,
          minWidth: options.minWidth,
          minHeight: this._minHeight(),
          handles: resizeHandles,
          start: function(event, ui) {
            $(this).addClass('ui-dialog-resizing');
            that._blockFrames();
            that._trigger('resizeStart', event, filteredUi(ui));
          },
          resize: function(event, ui) {
            that._trigger('resize', event, filteredUi(ui));
          },
          stop: function(event, ui) {
            options.height = $(this).height();
            options.width = $(this).width();
            $(this).removeClass('ui-dialog-resizing');
            that._unblockFrames();
            that._trigger('resizeStop', event, filteredUi(ui));
          },
        })
        .css('position', position);
    },

    _minHeight: function() {
      var options = this.options;

      return options.height === 'auto' ? options.minHeight : Math.min(options.minHeight, options.height);
    },

    _position: function() {
      // Need to show the dialog to get the actual offset in the position plugin
      var isVisible = this.uiDialog.is(':visible');
      if (!isVisible) {
        this.uiDialog.show();
      }
      this.uiDialog.position(this.options.position);
      if (!isVisible) {
        this.uiDialog.hide();
      }
    },

    _setOptions: function(options) {
      var that = this,
        resize = false,
        resizableOptions = {};

      $.each(options, function(key, value) {
        that._setOption(key, value);

        if (key in sizeRelatedOptions) {
          resize = true;
        }
        if (key in resizableRelatedOptions) {
          resizableOptions[key] = value;
        }
      });

      if (resize) {
        this._size();
        this._position();
      }
      if (this.uiDialog.is(':data(ui-resizable)')) {
        this.uiDialog.resizable('option', resizableOptions);
      }
    },

    _setOption: function(key, value) {
      /*jshint maxcomplexity:15*/
      var isDraggable,
        isResizable,
        uiDialog = this.uiDialog;

      if (key === 'dialogClass') {
        uiDialog.removeClass(this.options.dialogClass).addClass(value);
      }

      if (key === 'disabled') {
        return;
      }

      this._super(key, value);

      if (key === 'appendTo') {
        this.uiDialog.appendTo(this._appendTo());
      }

      if (key === 'buttons') {
        this._createButtons();
      }

      if (key === 'closeText') {
        this.uiDialogTitlebarClose.button({
          // Ensure that we always pass a string
          label: '' + value,
        });
      }

      if (key === 'draggable') {
        isDraggable = uiDialog.is(':data(ui-draggable)');
        if (isDraggable && !value) {
          uiDialog.draggable('destroy');
        }

        if (!isDraggable && value) {
          this._makeDraggable();
        }
      }

      if (key === 'position') {
        this._position();
      }

      if (key === 'resizable') {
        // currently resizable, becoming non-resizable
        isResizable = uiDialog.is(':data(ui-resizable)');
        if (isResizable && !value) {
          uiDialog.resizable('destroy');
        }

        // currently resizable, changing handles
        if (isResizable && typeof value === 'string') {
          uiDialog.resizable('option', 'handles', value);
        }

        // currently non-resizable, becoming resizable
        if (!isResizable && value !== false) {
          this._makeResizable();
        }
      }

      if (key === 'title') {
        this._title(this.uiDialogTitlebar.find('.ui-dialog-title'));
      }
    },

    _size: function() {
      // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
      // divs will both have width and height set, so we need to reset them
      var nonContentHeight,
        minContentHeight,
        maxContentHeight,
        options = this.options;

      // Reset content sizing
      this.element.show().css({
        width: 'auto',
        minHeight: 0,
        maxHeight: 'none',
        height: 0,
      });

      if (options.minWidth > options.width) {
        options.width = options.minWidth;
      }

      // reset wrapper sizing
      // determine the height of all the non-content elements
      nonContentHeight = this.uiDialog
        .css({
          height: 'auto',
          width: options.width,
        })
        .outerHeight();
      minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
      maxContentHeight =
        typeof options.maxHeight === 'number' ? Math.max(0, options.maxHeight - nonContentHeight) : 'none';

      if (options.height === 'auto') {
        this.element.css({
          minHeight: minContentHeight,
          maxHeight: maxContentHeight,
          height: 'auto',
        });
      } else {
        this.element.height(Math.max(0, options.height - nonContentHeight));
      }

      if (this.uiDialog.is(':data(ui-resizable)')) {
        this.uiDialog.resizable('option', 'minHeight', this._minHeight());
      }
    },

    _blockFrames: function() {
      this.iframeBlocks = this.document.find('iframe').map(function() {
        var iframe = $(this);

        return $('<div>')
          .css({
            position: 'absolute',
            width: iframe.outerWidth(),
            height: iframe.outerHeight(),
          })
          .appendTo(iframe.parent())
          .offset(iframe.offset())[0];
      });
    },

    _unblockFrames: function() {
      if (this.iframeBlocks) {
        this.iframeBlocks.remove();
        delete this.iframeBlocks;
      }
    },

    _allowInteraction: function(event) {
      if ($(event.target).closest('.ui-dialog').length) {
        return true;
      }

      // TODO: Remove hack when datepicker implements
      // the .ui-front logic (#8989)
      return !!$(event.target).closest('.ui-datepicker').length;
    },

    _createOverlay: function() {
      if (!this.options.modal) {
        return;
      }

      var that = this,
        widgetFullName = this.widgetFullName;
      if (!$.ui.dialog.overlayInstances) {
        // Prevent use of anchors and inputs.
        // We use a delay in case the overlay is created from an
        // event that we're going to be cancelling. (#2804)
        this._delay(function() {
          // Handle .dialog().dialog("close") (#4065)
          if ($.ui.dialog.overlayInstances) {
            this.document.bind('focusin.dialog', function(event) {
              if (!that._allowInteraction(event)) {
                event.preventDefault();
                $('.ui-dialog:visible:last .ui-dialog-content')
                  .data(widgetFullName)
                  ._focusTabbable();
              }
            });
          }
        });
      }

      this.overlay = $('<div>')
        .addClass('ui-widget-overlay ui-front')
        .appendTo(this._appendTo());
      this._on(this.overlay, {
        mousedown: '_keepFocus',
      });
      $.ui.dialog.overlayInstances++;
    },

    _destroyOverlay: function() {
      if (!this.options.modal) {
        return;
      }

      if (this.overlay) {
        $.ui.dialog.overlayInstances--;

        if (!$.ui.dialog.overlayInstances) {
          this.document.unbind('focusin.dialog');
        }
        this.overlay.remove();
        this.overlay = null;
      }
    },
  });

  $.ui.dialog.overlayInstances = 0;

  // DEPRECATED
  if ($.uiBackCompat !== false) {
    // position option with array notation
    // just override with old implementation
    $.widget('ui.dialog', $.ui.dialog, {
      _position: function() {
        var position = this.options.position,
          myAt = [],
          offset = [0, 0],
          isVisible;

        if (position) {
          if (typeof position === 'string' || (typeof position === 'object' && '0' in position)) {
            myAt = position.split ? position.split(' ') : [position[0], position[1]];
            if (myAt.length === 1) {
              myAt[1] = myAt[0];
            }

            $.each(['left', 'top'], function(i, offsetPosition) {
              if (+myAt[i] === myAt[i]) {
                offset[i] = myAt[i];
                myAt[i] = offsetPosition;
              }
            });

            position = {
              my:
                myAt[0] +
                (offset[0] < 0 ? offset[0] : '+' + offset[0]) +
                ' ' +
                myAt[1] +
                (offset[1] < 0 ? offset[1] : '+' + offset[1]),
              at: myAt.join(' '),
            };
          }

          position = $.extend({}, $.ui.dialog.prototype.options.position, position);
        } else {
          position = $.ui.dialog.prototype.options.position;
        }

        // need to show the dialog to get the actual offset in the position plugin
        isVisible = this.uiDialog.is(':visible');
        if (!isVisible) {
          this.uiDialog.show();
        }
        this.uiDialog.position(position);
        if (!isVisible) {
          this.uiDialog.hide();
        }
      },
    });
  }
})(jQuery);

(function($, undefined) {
  var rvertical = /up|down|vertical/,
    rpositivemotion = /up|left|vertical|horizontal/;

  $.effects.effect.blind = function(o, done) {
    // Create element
    var el = $(this),
      props = ['position', 'top', 'bottom', 'left', 'right', 'height', 'width'],
      mode = $.effects.setMode(el, o.mode || 'hide'),
      direction = o.direction || 'up',
      vertical = rvertical.test(direction),
      ref = vertical ? 'height' : 'width',
      ref2 = vertical ? 'top' : 'left',
      motion = rpositivemotion.test(direction),
      animation = {},
      show = mode === 'show',
      wrapper,
      distance,
      margin;

    // if already wrapped, the wrapper's properties are my property. #6245
    if (el.parent().is('.ui-effects-wrapper')) {
      $.effects.save(el.parent(), props);
    } else {
      $.effects.save(el, props);
    }
    el.show();
    wrapper = $.effects.createWrapper(el).css({
      overflow: 'hidden',
    });

    distance = wrapper[ref]();
    margin = parseFloat(wrapper.css(ref2)) || 0;

    animation[ref] = show ? distance : 0;
    if (!motion) {
      el.css(vertical ? 'bottom' : 'right', 0)
        .css(vertical ? 'top' : 'left', 'auto')
        .css({ position: 'absolute' });

      animation[ref2] = show ? margin : distance + margin;
    }

    // start at 0 if we are showing
    if (show) {
      wrapper.css(ref, 0);
      if (!motion) {
        wrapper.css(ref2, margin + distance);
      }
    }

    // Animate
    wrapper.animate(animation, {
      duration: o.duration,
      easing: o.easing,
      queue: false,
      complete: function() {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      },
    });
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.bounce = function(o, done) {
    var el = $(this),
      props = ['position', 'top', 'bottom', 'left', 'right', 'height', 'width'],
      // defaults:
      mode = $.effects.setMode(el, o.mode || 'effect'),
      hide = mode === 'hide',
      show = mode === 'show',
      direction = o.direction || 'up',
      distance = o.distance,
      times = o.times || 5,
      // number of internal animations
      anims = times * 2 + (show || hide ? 1 : 0),
      speed = o.duration / anims,
      easing = o.easing,
      // utility:
      ref = direction === 'up' || direction === 'down' ? 'top' : 'left',
      motion = direction === 'up' || direction === 'left',
      i,
      upAnim,
      downAnim,
      // we will need to re-assemble the queue to stack our animations in place
      queue = el.queue(),
      queuelen = queue.length;

    // Avoid touching opacity to prevent clearType and PNG issues in IE
    if (show || hide) {
      props.push('opacity');
    }

    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el); // Create Wrapper

    // default distance for the BIGGEST bounce is the outer Distance / 3
    if (!distance) {
      distance = el[ref === 'top' ? 'outerHeight' : 'outerWidth']() / 3;
    }

    if (show) {
      downAnim = { opacity: 1 };
      downAnim[ref] = 0;

      // if we are showing, force opacity 0 and set the initial position
      // then do the "first" animation
      el.css('opacity', 0)
        .css(ref, motion ? -distance * 2 : distance * 2)
        .animate(downAnim, speed, easing);
    }

    // start at the smallest distance if we are hiding
    if (hide) {
      distance = distance / Math.pow(2, times - 1);
    }

    downAnim = {};
    downAnim[ref] = 0;
    // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
    for (i = 0; i < times; i++) {
      upAnim = {};
      upAnim[ref] = (motion ? '-=' : '+=') + distance;

      el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);

      distance = hide ? distance * 2 : distance / 2;
    }

    // Last Bounce when Hiding
    if (hide) {
      upAnim = { opacity: 0 };
      upAnim[ref] = (motion ? '-=' : '+=') + distance;

      el.animate(upAnim, speed, easing);
    }

    el.queue(function() {
      if (hide) {
        el.hide();
      }
      $.effects.restore(el, props);
      $.effects.removeWrapper(el);
      done();
    });

    // inject all the animations we just queued to be first in line (after "inprogress")
    if (queuelen > 1) {
      queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
    }
    el.dequeue();
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.clip = function(o, done) {
    // Create element
    var el = $(this),
      props = ['position', 'top', 'bottom', 'left', 'right', 'height', 'width'],
      mode = $.effects.setMode(el, o.mode || 'hide'),
      show = mode === 'show',
      direction = o.direction || 'vertical',
      vert = direction === 'vertical',
      size = vert ? 'height' : 'width',
      position = vert ? 'top' : 'left',
      animation = {},
      wrapper,
      animate,
      distance;

    // Save & Show
    $.effects.save(el, props);
    el.show();

    // Create Wrapper
    wrapper = $.effects.createWrapper(el).css({
      overflow: 'hidden',
    });
    animate = el[0].tagName === 'IMG' ? wrapper : el;
    distance = animate[size]();

    // Shift
    if (show) {
      animate.css(size, 0);
      animate.css(position, distance / 2);
    }

    // Create Animation Object:
    animation[size] = show ? distance : 0;
    animation[position] = show ? 0 : distance / 2;

    // Animate
    animate.animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function() {
        if (!show) {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      },
    });
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.drop = function(o, done) {
    var el = $(this),
      props = ['position', 'top', 'bottom', 'left', 'right', 'opacity', 'height', 'width'],
      mode = $.effects.setMode(el, o.mode || 'hide'),
      show = mode === 'show',
      direction = o.direction || 'left',
      ref = direction === 'up' || direction === 'down' ? 'top' : 'left',
      motion = direction === 'up' || direction === 'left' ? 'pos' : 'neg',
      animation = {
        opacity: show ? 1 : 0,
      },
      distance;

    // Adjust
    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);

    distance = o.distance || el[ref === 'top' ? 'outerHeight' : 'outerWidth'](true) / 2;

    if (show) {
      el.css('opacity', 0).css(ref, motion === 'pos' ? -distance : distance);
    }

    // Animation
    animation[ref] = (show ? (motion === 'pos' ? '+=' : '-=') : motion === 'pos' ? '-=' : '+=') + distance;

    // Animate
    el.animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function() {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      },
    });
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.explode = function(o, done) {
    var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3,
      cells = rows,
      el = $(this),
      mode = $.effects.setMode(el, o.mode || 'hide'),
      show = mode === 'show',
      // show and then visibility:hidden the element before calculating offset
      offset = el
        .show()
        .css('visibility', 'hidden')
        .offset(),
      // width and height of a piece
      width = Math.ceil(el.outerWidth() / cells),
      height = Math.ceil(el.outerHeight() / rows),
      pieces = [],
      // loop
      i,
      j,
      left,
      top,
      mx,
      my;

    // children animate complete:
    function childComplete() {
      pieces.push(this);
      if (pieces.length === rows * cells) {
        animComplete();
      }
    }

    // clone the element for each row and cell.
    for (i = 0; i < rows; i++) {
      // ===>
      top = offset.top + i * height;
      my = i - (rows - 1) / 2;

      for (j = 0; j < cells; j++) {
        // |||
        left = offset.left + j * width;
        mx = j - (cells - 1) / 2;

        // Create a clone of the now hidden main element that will be absolute positioned
        // within a wrapper div off the -left and -top equal to size of our pieces
        el.clone()
          .appendTo('body')
          .wrap('<div></div>')
          .css({
            position: 'absolute',
            visibility: 'visible',
            left: -j * width,
            top: -i * height,
          })

          // select the wrapper - make it overflow: hidden and absolute positioned based on
          // where the original was located +left and +top equal to the size of pieces
          .parent()
          .addClass('ui-effects-explode')
          .css({
            position: 'absolute',
            overflow: 'hidden',
            width: width,
            height: height,
            left: left + (show ? mx * width : 0),
            top: top + (show ? my * height : 0),
            opacity: show ? 0 : 1,
          })
          .animate(
            {
              left: left + (show ? 0 : mx * width),
              top: top + (show ? 0 : my * height),
              opacity: show ? 1 : 0,
            },
            o.duration || 500,
            o.easing,
            childComplete
          );
      }
    }

    function animComplete() {
      el.css({
        visibility: 'visible',
      });
      $(pieces).remove();
      if (!show) {
        el.hide();
      }
      done();
    }
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.fade = function(o, done) {
    var el = $(this),
      mode = $.effects.setMode(el, o.mode || 'toggle');

    el.animate(
      {
        opacity: mode,
      },
      {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: done,
      }
    );
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.fold = function(o, done) {
    // Create element
    var el = $(this),
      props = ['position', 'top', 'bottom', 'left', 'right', 'height', 'width'],
      mode = $.effects.setMode(el, o.mode || 'hide'),
      show = mode === 'show',
      hide = mode === 'hide',
      size = o.size || 15,
      percent = /([0-9]+)%/.exec(size),
      horizFirst = !!o.horizFirst,
      widthFirst = show !== horizFirst,
      ref = widthFirst ? ['width', 'height'] : ['height', 'width'],
      duration = o.duration / 2,
      wrapper,
      distance,
      animation1 = {},
      animation2 = {};

    $.effects.save(el, props);
    el.show();

    // Create Wrapper
    wrapper = $.effects.createWrapper(el).css({
      overflow: 'hidden',
    });
    distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];

    if (percent) {
      size = (parseInt(percent[1], 10) / 100) * distance[hide ? 0 : 1];
    }
    if (show) {
      wrapper.css(
        horizFirst
          ? {
              height: 0,
              width: size,
            }
          : {
              height: size,
              width: 0,
            }
      );
    }

    // Animation
    animation1[ref[0]] = show ? distance[0] : size;
    animation2[ref[1]] = show ? distance[1] : 0;

    // Animate
    wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function() {
      if (hide) {
        el.hide();
      }
      $.effects.restore(el, props);
      $.effects.removeWrapper(el);
      done();
    });
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.highlight = function(o, done) {
    var elem = $(this),
      props = ['backgroundImage', 'backgroundColor', 'opacity'],
      mode = $.effects.setMode(elem, o.mode || 'show'),
      animation = {
        backgroundColor: elem.css('backgroundColor'),
      };

    if (mode === 'hide') {
      animation.opacity = 0;
    }

    $.effects.save(elem, props);

    elem
      .show()
      .css({
        backgroundImage: 'none',
        backgroundColor: o.color || '#ffff99',
      })
      .animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
          if (mode === 'hide') {
            elem.hide();
          }
          $.effects.restore(elem, props);
          done();
        },
      });
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.pulsate = function(o, done) {
    var elem = $(this),
      mode = $.effects.setMode(elem, o.mode || 'show'),
      show = mode === 'show',
      hide = mode === 'hide',
      showhide = show || mode === 'hide',
      // showing or hiding leaves of the "last" animation
      anims = (o.times || 5) * 2 + (showhide ? 1 : 0),
      duration = o.duration / anims,
      animateTo = 0,
      queue = elem.queue(),
      queuelen = queue.length,
      i;

    if (show || !elem.is(':visible')) {
      elem.css('opacity', 0).show();
      animateTo = 1;
    }

    // anims - 1 opacity "toggles"
    for (i = 1; i < anims; i++) {
      elem.animate(
        {
          opacity: animateTo,
        },
        duration,
        o.easing
      );
      animateTo = 1 - animateTo;
    }

    elem.animate(
      {
        opacity: animateTo,
      },
      duration,
      o.easing
    );

    elem.queue(function() {
      if (hide) {
        elem.hide();
      }
      done();
    });

    // We just queued up "anims" animations, we need to put them next in the queue
    if (queuelen > 1) {
      queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
    }
    elem.dequeue();
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.puff = function(o, done) {
    var elem = $(this),
      mode = $.effects.setMode(elem, o.mode || 'hide'),
      hide = mode === 'hide',
      percent = parseInt(o.percent, 10) || 150,
      factor = percent / 100,
      original = {
        height: elem.height(),
        width: elem.width(),
        outerHeight: elem.outerHeight(),
        outerWidth: elem.outerWidth(),
      };

    $.extend(o, {
      effect: 'scale',
      queue: false,
      fade: true,
      mode: mode,
      complete: done,
      percent: hide ? percent : 100,
      from: hide
        ? original
        : {
            height: original.height * factor,
            width: original.width * factor,
            outerHeight: original.outerHeight * factor,
            outerWidth: original.outerWidth * factor,
          },
    });

    elem.effect(o);
  };

  $.effects.effect.scale = function(o, done) {
    // Create element
    var el = $(this),
      options = $.extend(true, {}, o),
      mode = $.effects.setMode(el, o.mode || 'effect'),
      percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : mode === 'hide' ? 0 : 100),
      direction = o.direction || 'both',
      origin = o.origin,
      original = {
        height: el.height(),
        width: el.width(),
        outerHeight: el.outerHeight(),
        outerWidth: el.outerWidth(),
      },
      factor = {
        y: direction !== 'horizontal' ? percent / 100 : 1,
        x: direction !== 'vertical' ? percent / 100 : 1,
      };

    // We are going to pass this effect to the size effect:
    options.effect = 'size';
    options.queue = false;
    options.complete = done;

    // Set default origin and restore for show/hide
    if (mode !== 'effect') {
      options.origin = origin || ['middle', 'center'];
      options.restore = true;
    }

    options.from =
      o.from ||
      (mode === 'show'
        ? {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0,
          }
        : original);
    options.to = {
      height: original.height * factor.y,
      width: original.width * factor.x,
      outerHeight: original.outerHeight * factor.y,
      outerWidth: original.outerWidth * factor.x,
    };

    // Fade option to support puff
    if (options.fade) {
      if (mode === 'show') {
        options.from.opacity = 0;
        options.to.opacity = 1;
      }
      if (mode === 'hide') {
        options.from.opacity = 1;
        options.to.opacity = 0;
      }
    }

    // Animate
    el.effect(options);
  };

  $.effects.effect.size = function(o, done) {
    // Create element
    var original,
      baseline,
      factor,
      el = $(this),
      props0 = ['position', 'top', 'bottom', 'left', 'right', 'width', 'height', 'overflow', 'opacity'],
      // Always restore
      props1 = ['position', 'top', 'bottom', 'left', 'right', 'overflow', 'opacity'],
      // Copy for children
      props2 = ['width', 'height', 'overflow'],
      cProps = ['fontSize'],
      vProps = ['borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'],
      hProps = ['borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight'],
      // Set options
      mode = $.effects.setMode(el, o.mode || 'effect'),
      restore = o.restore || mode !== 'effect',
      scale = o.scale || 'both',
      origin = o.origin || ['middle', 'center'],
      position = el.css('position'),
      props = restore ? props0 : props1,
      zero = {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0,
      };

    if (mode === 'show') {
      el.show();
    }
    original = {
      height: el.height(),
      width: el.width(),
      outerHeight: el.outerHeight(),
      outerWidth: el.outerWidth(),
    };

    if (o.mode === 'toggle' && mode === 'show') {
      el.from = o.to || zero;
      el.to = o.from || original;
    } else {
      el.from = o.from || (mode === 'show' ? zero : original);
      el.to = o.to || (mode === 'hide' ? zero : original);
    }

    // Set scaling factor
    factor = {
      from: {
        y: el.from.height / original.height,
        x: el.from.width / original.width,
      },
      to: {
        y: el.to.height / original.height,
        x: el.to.width / original.width,
      },
    };

    // Scale the css box
    if (scale === 'box' || scale === 'both') {
      // Vertical props scaling
      if (factor.from.y !== factor.to.y) {
        props = props.concat(vProps);
        el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
        el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
      }

      // Horizontal props scaling
      if (factor.from.x !== factor.to.x) {
        props = props.concat(hProps);
        el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
        el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
      }
    }

    // Scale the content
    if (scale === 'content' || scale === 'both') {
      // Vertical props scaling
      if (factor.from.y !== factor.to.y) {
        props = props.concat(cProps).concat(props2);
        el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
        el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
      }
    }

    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);
    el.css('overflow', 'hidden').css(el.from);

    // Adjust
    if (origin) {
      // Calculate baseline shifts
      baseline = $.effects.getBaseline(origin, original);
      el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
      el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
      el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
      el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
    }
    el.css(el.from); // set top & left

    // Animate
    if (scale === 'content' || scale === 'both') {
      // Scale the children

      // Add margins/font-size
      vProps = vProps.concat(['marginTop', 'marginBottom']).concat(cProps);
      hProps = hProps.concat(['marginLeft', 'marginRight']);
      props2 = props0.concat(vProps).concat(hProps);

      el.find('*[width]').each(function() {
        var child = $(this),
          c_original = {
            height: child.height(),
            width: child.width(),
            outerHeight: child.outerHeight(),
            outerWidth: child.outerWidth(),
          };
        if (restore) {
          $.effects.save(child, props2);
        }

        child.from = {
          height: c_original.height * factor.from.y,
          width: c_original.width * factor.from.x,
          outerHeight: c_original.outerHeight * factor.from.y,
          outerWidth: c_original.outerWidth * factor.from.x,
        };
        child.to = {
          height: c_original.height * factor.to.y,
          width: c_original.width * factor.to.x,
          outerHeight: c_original.height * factor.to.y,
          outerWidth: c_original.width * factor.to.x,
        };

        // Vertical props scaling
        if (factor.from.y !== factor.to.y) {
          child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
          child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
        }

        // Horizontal props scaling
        if (factor.from.x !== factor.to.x) {
          child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
          child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
        }

        // Animate children
        child.css(child.from);
        child.animate(child.to, o.duration, o.easing, function() {
          // Restore children
          if (restore) {
            $.effects.restore(child, props2);
          }
        });
      });
    }

    // Animate
    el.animate(el.to, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function() {
        if (el.to.opacity === 0) {
          el.css('opacity', el.from.opacity);
        }
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        if (!restore) {
          // we need to calculate our new positioning based on the scaling
          if (position === 'static') {
            el.css({
              position: 'relative',
              top: el.to.top,
              left: el.to.left,
            });
          } else {
            $.each(['top', 'left'], function(idx, pos) {
              el.css(pos, function(_, str) {
                var val = parseInt(str, 10),
                  toRef = idx ? el.to.left : el.to.top;

                // if original was "auto", recalculate the new value from wrapper
                if (str === 'auto') {
                  return toRef + 'px';
                }

                return val + toRef + 'px';
              });
            });
          }
        }

        $.effects.removeWrapper(el);
        done();
      },
    });
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.shake = function(o, done) {
    var el = $(this),
      props = ['position', 'top', 'bottom', 'left', 'right', 'height', 'width'],
      mode = $.effects.setMode(el, o.mode || 'effect'),
      direction = o.direction || 'left',
      distance = o.distance || 20,
      times = o.times || 3,
      anims = times * 2 + 1,
      speed = Math.round(o.duration / anims),
      ref = direction === 'up' || direction === 'down' ? 'top' : 'left',
      positiveMotion = direction === 'up' || direction === 'left',
      animation = {},
      animation1 = {},
      animation2 = {},
      i,
      // we will need to re-assemble the queue to stack our animations in place
      queue = el.queue(),
      queuelen = queue.length;

    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);

    // Animation
    animation[ref] = (positiveMotion ? '-=' : '+=') + distance;
    animation1[ref] = (positiveMotion ? '+=' : '-=') + distance * 2;
    animation2[ref] = (positiveMotion ? '-=' : '+=') + distance * 2;

    // Animate
    el.animate(animation, speed, o.easing);

    // Shakes
    for (i = 1; i < times; i++) {
      el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
    }
    el.animate(animation1, speed, o.easing)
      .animate(animation, speed / 2, o.easing)
      .queue(function() {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      });

    // inject all the animations we just queued to be first in line (after "inprogress")
    if (queuelen > 1) {
      queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
    }
    el.dequeue();
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.slide = function(o, done) {
    // Create element
    var el = $(this),
      props = ['position', 'top', 'bottom', 'left', 'right', 'width', 'height'],
      mode = $.effects.setMode(el, o.mode || 'show'),
      show = mode === 'show',
      direction = o.direction || 'left',
      ref = direction === 'up' || direction === 'down' ? 'top' : 'left',
      positiveMotion = direction === 'up' || direction === 'left',
      distance,
      animation = {};

    // Adjust
    $.effects.save(el, props);
    el.show();
    distance = o.distance || el[ref === 'top' ? 'outerHeight' : 'outerWidth'](true);

    $.effects.createWrapper(el).css({
      overflow: 'hidden',
    });

    if (show) {
      el.css(ref, positiveMotion ? (isNaN(distance) ? '-' + distance : -distance) : distance);
    }

    // Animation
    animation[ref] = (show ? (positiveMotion ? '+=' : '-=') : positiveMotion ? '-=' : '+=') + distance;

    // Animate
    el.animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function() {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      },
    });
  };
})(jQuery);

(function($, undefined) {
  $.effects.effect.transfer = function(o, done) {
    var elem = $(this),
      target = $(o.to),
      targetFixed = target.css('position') === 'fixed',
      body = $('body'),
      fixTop = targetFixed ? body.scrollTop() : 0,
      fixLeft = targetFixed ? body.scrollLeft() : 0,
      endPosition = target.offset(),
      animation = {
        top: endPosition.top - fixTop,
        left: endPosition.left - fixLeft,
        height: target.innerHeight(),
        width: target.innerWidth(),
      },
      startPosition = elem.offset(),
      transfer = $("<div class='ui-effects-transfer'></div>")
        .appendTo(document.body)
        .addClass(o.className)
        .css({
          top: startPosition.top - fixTop,
          left: startPosition.left - fixLeft,
          height: elem.innerHeight(),
          width: elem.innerWidth(),
          position: targetFixed ? 'fixed' : 'absolute',
        })
        .animate(animation, o.duration, o.easing, function() {
          transfer.remove();
          done();
        });
  };
})(jQuery);

(function($, undefined) {
  $.widget('ui.menu', {
    version: '1.10.3',
    defaultElement: '<ul>',
    delay: 300,
    options: {
      icons: {
        submenu: 'ui-icon-carat-1-e',
      },
      menus: 'ul',
      position: {
        my: 'left top',
        at: 'right top',
      },
      role: 'menu',

      // callbacks
      blur: null,
      focus: null,
      select: null,
    },

    _create: function() {
      this.activeMenu = this.element;
      // flag used to prevent firing of the click handler
      // as the event bubbles up through nested menus
      this.mouseHandled = false;
      this.element
        .uniqueId()
        .addClass('ui-menu ui-widget ui-widget-content ui-corner-all')
        .toggleClass('ui-menu-icons', !!this.element.find('.ui-icon').length)
        .attr({
          role: this.options.role,
          tabIndex: 0,
        })
        // need to catch all clicks on disabled menu
        // not possible through _on
        .bind(
          'click' + this.eventNamespace,
          $.proxy(function(event) {
            if (this.options.disabled) {
              event.preventDefault();
            }
          }, this)
        );

      if (this.options.disabled) {
        this.element.addClass('ui-state-disabled').attr('aria-disabled', 'true');
      }

      this._on({
        // Prevent focus from sticking to links inside menu after clicking
        // them (focus should always stay on UL during navigation).
        'mousedown .ui-menu-item > a': function(event) {
          event.preventDefault();
        },
        'click .ui-state-disabled > a': function(event) {
          event.preventDefault();
        },
        'click .ui-menu-item:has(a)': function(event) {
          var target = $(event.target).closest('.ui-menu-item');
          if (!this.mouseHandled && target.not('.ui-state-disabled').length) {
            this.mouseHandled = true;

            this.select(event);
            // Open submenu on click
            if (target.has('.ui-menu').length) {
              this.expand(event);
            } else if (!this.element.is(':focus')) {
              // Redirect focus to the menu
              this.element.trigger('focus', [true]);

              // If the active item is on the top level, let it stay active.
              // Otherwise, blur the active item since it is no longer visible.
              if (this.active && this.active.parents('.ui-menu').length === 1) {
                clearTimeout(this.timer);
              }
            }
          }
        },
        'mouseenter .ui-menu-item': function(event) {
          var target = $(event.currentTarget);
          // Remove ui-state-active class from siblings of the newly focused menu item
          // to avoid a jump caused by adjacent elements both having a class with a border
          target
            .siblings()
            .children('.ui-state-active')
            .removeClass('ui-state-active');
          this.focus(event, target);
        },
        mouseleave: 'collapseAll',
        'mouseleave .ui-menu': 'collapseAll',
        focus: function(event, keepActiveItem) {
          // If there's already an active item, keep it active
          // If not, activate the first item
          var item = this.active || this.element.children('.ui-menu-item').eq(0);

          if (!keepActiveItem) {
            this.focus(event, item);
          }
        },
        blur: function(event) {
          this._delay(function() {
            if (!$.contains(this.element[0], this.document[0].activeElement)) {
              this.collapseAll(event);
            }
          });
        },
        keydown: '_keydown',
      });

      this.refresh();

      // Clicks outside of a menu collapse any open menus
      this._on(this.document, {
        click: function(event) {
          if (!$(event.target).closest('.ui-menu').length) {
            this.collapseAll(event);
          }

          // Reset the mouseHandled flag
          this.mouseHandled = false;
        },
      });
    },

    _destroy: function() {
      // Destroy (sub)menus
      this.element
        .removeAttr('aria-activedescendant')
        .find('.ui-menu')
        .addBack()
        .removeClass('ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons')
        .removeAttr('role')
        .removeAttr('tabIndex')
        .removeAttr('aria-labelledby')
        .removeAttr('aria-expanded')
        .removeAttr('aria-hidden')
        .removeAttr('aria-disabled')
        .removeUniqueId()
        .show();

      // Destroy menu items
      this.element
        .find('.ui-menu-item')
        .removeClass('ui-menu-item')
        .removeAttr('role')
        .removeAttr('aria-disabled')
        .children('a')
        .removeUniqueId()
        .removeClass('ui-corner-all ui-state-hover')
        .removeAttr('tabIndex')
        .removeAttr('role')
        .removeAttr('aria-haspopup')
        .children()
        .each(function() {
          var elem = $(this);
          if (elem.data('ui-menu-submenu-carat')) {
            elem.remove();
          }
        });

      // Destroy menu dividers
      this.element.find('.ui-menu-divider').removeClass('ui-menu-divider ui-widget-content');
    },

    _keydown: function(event) {
      /*jshint maxcomplexity:20*/
      var match,
        prev,
        character,
        skip,
        regex,
        preventDefault = true;

      function escape(value) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
      }

      switch (event.keyCode) {
        case $.ui.keyCode.PAGE_UP:
          this.previousPage(event);
          break;
        case $.ui.keyCode.PAGE_DOWN:
          this.nextPage(event);
          break;
        case $.ui.keyCode.HOME:
          this._move('first', 'first', event);
          break;
        case $.ui.keyCode.END:
          this._move('last', 'last', event);
          break;
        case $.ui.keyCode.UP:
          this.previous(event);
          break;
        case $.ui.keyCode.DOWN:
          this.next(event);
          break;
        case $.ui.keyCode.LEFT:
          this.collapse(event);
          break;
        case $.ui.keyCode.RIGHT:
          if (this.active && !this.active.is('.ui-state-disabled')) {
            this.expand(event);
          }
          break;
        case $.ui.keyCode.ENTER:
        case $.ui.keyCode.SPACE:
          this._activate(event);
          break;
        case $.ui.keyCode.ESCAPE:
          this.collapse(event);
          break;
        default:
          preventDefault = false;
          prev = this.previousFilter || '';
          character = String.fromCharCode(event.keyCode);
          skip = false;

          clearTimeout(this.filterTimer);

          if (character === prev) {
            skip = true;
          } else {
            character = prev + character;
          }

          regex = new RegExp('^' + escape(character), 'i');
          match = this.activeMenu.children('.ui-menu-item').filter(function() {
            return regex.test(
              $(this)
                .children('a')
                .text()
            );
          });
          match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll('.ui-menu-item') : match;

          // If no matches on the current filter, reset to the last character pressed
          // to move down the menu to the first item that starts with that character
          if (!match.length) {
            character = String.fromCharCode(event.keyCode);
            regex = new RegExp('^' + escape(character), 'i');
            match = this.activeMenu.children('.ui-menu-item').filter(function() {
              return regex.test(
                $(this)
                  .children('a')
                  .text()
              );
            });
          }

          if (match.length) {
            this.focus(event, match);
            if (match.length > 1) {
              this.previousFilter = character;
              this.filterTimer = this._delay(function() {
                delete this.previousFilter;
              }, 1000);
            } else {
              delete this.previousFilter;
            }
          } else {
            delete this.previousFilter;
          }
      }

      if (preventDefault) {
        event.preventDefault();
      }
    },

    _activate: function(event) {
      if (!this.active.is('.ui-state-disabled')) {
        if (this.active.children("a[aria-haspopup='true']").length) {
          this.expand(event);
        } else {
          this.select(event);
        }
      }
    },

    refresh: function() {
      var menus,
        icon = this.options.icons.submenu,
        submenus = this.element.find(this.options.menus);

      // Initialize nested menus
      submenus
        .filter(':not(.ui-menu)')
        .addClass('ui-menu ui-widget ui-widget-content ui-corner-all')
        .hide()
        .attr({
          role: this.options.role,
          'aria-hidden': 'true',
          'aria-expanded': 'false',
        })
        .each(function() {
          var menu = $(this),
            item = menu.prev('a'),
            submenuCarat = $('<span>')
              .addClass('ui-menu-icon ui-icon ' + icon)
              .data('ui-menu-submenu-carat', true);

          item.attr('aria-haspopup', 'true').prepend(submenuCarat);
          menu.attr('aria-labelledby', item.attr('id'));
        });

      menus = submenus.add(this.element);

      // Don't refresh list items that are already adapted
      menus
        .children(':not(.ui-menu-item):has(a)')
        .addClass('ui-menu-item')
        .attr('role', 'presentation')
        .children('a')
        .uniqueId()
        .addClass('ui-corner-all')
        .attr({
          tabIndex: -1,
          role: this._itemRole(),
        });

      // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
      menus.children(':not(.ui-menu-item)').each(function() {
        var item = $(this);
        // hyphen, em dash, en dash
        if (!/[^\-\u2014\u2013\s]/.test(item.text())) {
          item.addClass('ui-widget-content ui-menu-divider');
        }
      });

      // Add aria-disabled attribute to any disabled menu item
      menus.children('.ui-state-disabled').attr('aria-disabled', 'true');

      // If the active item has been removed, blur the menu
      if (this.active && !$.contains(this.element[0], this.active[0])) {
        this.blur();
      }
    },

    _itemRole: function() {
      return {
        menu: 'menuitem',
        listbox: 'option',
      }[this.options.role];
    },

    _setOption: function(key, value) {
      if (key === 'icons') {
        this.element
          .find('.ui-menu-icon')
          .removeClass(this.options.icons.submenu)
          .addClass(value.submenu);
      }
      this._super(key, value);
    },

    focus: function(event, item) {
      var nested, focused;
      this.blur(event, event && event.type === 'focus');

      this._scrollIntoView(item);

      this.active = item.first();
      focused = this.active.children('a').addClass('ui-state-focus');
      // Only update aria-activedescendant if there's a role
      // otherwise we assume focus is managed elsewhere
      if (this.options.role) {
        this.element.attr('aria-activedescendant', focused.attr('id'));
      }

      // Highlight active parent menu item, if any
      this.active
        .parent()
        .closest('.ui-menu-item')
        .children('a:first')
        .addClass('ui-state-active');

      if (event && event.type === 'keydown') {
        this._close();
      } else {
        this.timer = this._delay(function() {
          this._close();
        }, this.delay);
      }

      nested = item.children('.ui-menu');
      if (nested.length && /^mouse/.test(event.type)) {
        this._startOpening(nested);
      }
      this.activeMenu = item.parent();

      this._trigger('focus', event, { item: item });
    },

    _scrollIntoView: function(item) {
      var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
      if (this._hasScroll()) {
        borderTop = parseFloat($.css(this.activeMenu[0], 'borderTopWidth')) || 0;
        paddingTop = parseFloat($.css(this.activeMenu[0], 'paddingTop')) || 0;
        offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
        scroll = this.activeMenu.scrollTop();
        elementHeight = this.activeMenu.height();
        itemHeight = item.height();

        if (offset < 0) {
          this.activeMenu.scrollTop(scroll + offset);
        } else if (offset + itemHeight > elementHeight) {
          this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
        }
      }
    },

    blur: function(event, fromFocus) {
      if (!fromFocus) {
        clearTimeout(this.timer);
      }

      if (!this.active) {
        return;
      }

      this.active.children('a').removeClass('ui-state-focus');
      this.active = null;

      this._trigger('blur', event, { item: this.active });
    },

    _startOpening: function(submenu) {
      clearTimeout(this.timer);

      // Don't open if already open fixes a Firefox bug that caused a .5 pixel
      // shift in the submenu position when mousing over the carat icon
      if (submenu.attr('aria-hidden') !== 'true') {
        return;
      }

      this.timer = this._delay(function() {
        this._close();
        this._open(submenu);
      }, this.delay);
    },

    _open: function(submenu) {
      var position = $.extend(
        {
          of: this.active,
        },
        this.options.position
      );

      clearTimeout(this.timer);
      this.element
        .find('.ui-menu')
        .not(submenu.parents('.ui-menu'))
        .hide()
        .attr('aria-hidden', 'true');

      submenu
        .show()
        .removeAttr('aria-hidden')
        .attr('aria-expanded', 'true')
        .position(position);
    },

    collapseAll: function(event, all) {
      clearTimeout(this.timer);
      this.timer = this._delay(function() {
        // If we were passed an event, look for the submenu that contains the event
        var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find('.ui-menu'));

        // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
        if (!currentMenu.length) {
          currentMenu = this.element;
        }

        this._close(currentMenu);

        this.blur(event);
        this.activeMenu = currentMenu;
      }, this.delay);
    },

    // With no arguments, closes the currently active menu - if nothing is active
    // it closes all menus.  If passed an argument, it will search for menus BELOW
    _close: function(startMenu) {
      if (!startMenu) {
        startMenu = this.active ? this.active.parent() : this.element;
      }

      startMenu
        .find('.ui-menu')
        .hide()
        .attr('aria-hidden', 'true')
        .attr('aria-expanded', 'false')
        .end()
        .find('a.ui-state-active')
        .removeClass('ui-state-active');
    },

    collapse: function(event) {
      var newItem = this.active && this.active.parent().closest('.ui-menu-item', this.element);
      if (newItem && newItem.length) {
        this._close();
        this.focus(event, newItem);
      }
    },

    expand: function(event) {
      var newItem =
        this.active &&
        this.active
          .children('.ui-menu ')
          .children('.ui-menu-item')
          .first();

      if (newItem && newItem.length) {
        this._open(newItem.parent());

        // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
        this._delay(function() {
          this.focus(event, newItem);
        });
      }
    },

    next: function(event) {
      this._move('next', 'first', event);
    },

    previous: function(event) {
      this._move('prev', 'last', event);
    },

    isFirstItem: function() {
      return this.active && !this.active.prevAll('.ui-menu-item').length;
    },

    isLastItem: function() {
      return this.active && !this.active.nextAll('.ui-menu-item').length;
    },

    _move: function(direction, filter, event) {
      var next;
      if (this.active) {
        if (direction === 'first' || direction === 'last') {
          next = this.active[direction === 'first' ? 'prevAll' : 'nextAll']('.ui-menu-item').eq(-1);
        } else {
          next = this.active[direction + 'All']('.ui-menu-item').eq(0);
        }
      }
      if (!next || !next.length || !this.active) {
        next = this.activeMenu.children('.ui-menu-item')[filter]();
      }

      this.focus(event, next);
    },

    nextPage: function(event) {
      var item, base, height;

      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isLastItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.nextAll('.ui-menu-item').each(function() {
          item = $(this);
          return item.offset().top - base - height < 0;
        });

        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children('.ui-menu-item')[!this.active ? 'first' : 'last']());
      }
    },

    previousPage: function(event) {
      var item, base, height;
      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isFirstItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.prevAll('.ui-menu-item').each(function() {
          item = $(this);
          return item.offset().top - base + height > 0;
        });

        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children('.ui-menu-item').first());
      }
    },

    _hasScroll: function() {
      return this.element.outerHeight() < this.element.prop('scrollHeight');
    },

    select: function(event) {
      // TODO: It should never be possible to not have an active item at this
      // point, but the tests don't trigger mouseenter before click.
      this.active = this.active || $(event.target).closest('.ui-menu-item');
      var ui = { item: this.active };
      if (!this.active.has('.ui-menu').length) {
        this.collapseAll(event, true);
      }
      this._trigger('select', event, ui);
    },
  });
})(jQuery);

(function($, undefined) {
  $.ui = $.ui || {};

  var cachedScrollbarWidth,
    max = Math.max,
    abs = Math.abs,
    round = Math.round,
    rhorizontal = /left|center|right/,
    rvertical = /top|center|bottom/,
    roffset = /[\+\-]\d+(\.[\d]+)?%?/,
    rposition = /^\w+/,
    rpercent = /%$/,
    _position = $.fn.position;

  function getOffsets(offsets, width, height) {
    return [
      parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
      parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1),
    ];
  }

  function parseCss(element, property) {
    return parseInt($.css(element, property), 10) || 0;
  }

  function getDimensions(elem) {
    var raw = elem[0];
    if (raw.nodeType === 9) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: { top: 0, left: 0 },
      };
    }
    if ($.isWindow(raw)) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: { top: elem.scrollTop(), left: elem.scrollLeft() },
      };
    }
    if (raw.preventDefault) {
      return {
        width: 0,
        height: 0,
        offset: { top: raw.pageY, left: raw.pageX },
      };
    }
    return {
      width: elem.outerWidth(),
      height: elem.outerHeight(),
      offset: elem.offset(),
    };
  }

  $.position = {
    scrollbarWidth: function() {
      if (cachedScrollbarWidth !== undefined) {
        return cachedScrollbarWidth;
      }
      var w1,
        w2,
        div = $(
          "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"
        ),
        innerDiv = div.children()[0];

      $('body').append(div);
      w1 = innerDiv.offsetWidth;
      div.css('overflow', 'scroll');

      w2 = innerDiv.offsetWidth;

      if (w1 === w2) {
        w2 = div[0].clientWidth;
      }

      div.remove();

      return (cachedScrollbarWidth = w1 - w2);
    },
    getScrollInfo: function(within) {
      var overflowX = within.isWindow ? '' : within.element.css('overflow-x'),
        overflowY = within.isWindow ? '' : within.element.css('overflow-y'),
        hasOverflowX = overflowX === 'scroll' || (overflowX === 'auto' && within.width < within.element[0].scrollWidth),
        hasOverflowY =
          overflowY === 'scroll' || (overflowY === 'auto' && within.height < within.element[0].scrollHeight);
      return {
        width: hasOverflowY ? $.position.scrollbarWidth() : 0,
        height: hasOverflowX ? $.position.scrollbarWidth() : 0,
      };
    },
    getWithinInfo: function(element) {
      var withinElement = $(element || window),
        isWindow = $.isWindow(withinElement[0]);
      return {
        element: withinElement,
        isWindow: isWindow,
        offset: withinElement.offset() || { left: 0, top: 0 },
        scrollLeft: withinElement.scrollLeft(),
        scrollTop: withinElement.scrollTop(),
        width: isWindow ? withinElement.width() : withinElement.outerWidth(),
        height: isWindow ? withinElement.height() : withinElement.outerHeight(),
      };
    },
  };

  $.fn.position = function(options) {
    if (!options || !options.of) {
      return _position.apply(this, arguments);
    }

    // make a copy, we don't want to modify arguments
    options = $.extend({}, options);

    var atOffset,
      targetWidth,
      targetHeight,
      targetOffset,
      basePosition,
      dimensions,
      target = $(options.of),
      within = $.position.getWithinInfo(options.within),
      scrollInfo = $.position.getScrollInfo(within),
      collision = (options.collision || 'flip').split(' '),
      offsets = {};

    dimensions = getDimensions(target);
    if (target[0].preventDefault) {
      // force left top to allow flipping
      options.at = 'left top';
    }
    targetWidth = dimensions.width;
    targetHeight = dimensions.height;
    targetOffset = dimensions.offset;
    // clone to reuse original targetOffset later
    basePosition = $.extend({}, targetOffset);

    // force my and at to have valid horizontal and vertical positions
    // if a value is missing or invalid, it will be converted to center
    $.each(['my', 'at'], function() {
      var pos = (options[this] || '').split(' '),
        horizontalOffset,
        verticalOffset;

      if (pos.length === 1) {
        pos = rhorizontal.test(pos[0])
          ? pos.concat(['center'])
          : rvertical.test(pos[0])
          ? ['center'].concat(pos)
          : ['center', 'center'];
      }
      pos[0] = rhorizontal.test(pos[0]) ? pos[0] : 'center';
      pos[1] = rvertical.test(pos[1]) ? pos[1] : 'center';

      // calculate offsets
      horizontalOffset = roffset.exec(pos[0]);
      verticalOffset = roffset.exec(pos[1]);
      offsets[this] = [horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0];

      // reduce to just the positions without the offsets
      options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];
    });

    // normalize collision option
    if (collision.length === 1) {
      collision[1] = collision[0];
    }

    if (options.at[0] === 'right') {
      basePosition.left += targetWidth;
    } else if (options.at[0] === 'center') {
      basePosition.left += targetWidth / 2;
    }

    if (options.at[1] === 'bottom') {
      basePosition.top += targetHeight;
    } else if (options.at[1] === 'center') {
      basePosition.top += targetHeight / 2;
    }

    atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
    basePosition.left += atOffset[0];
    basePosition.top += atOffset[1];

    return this.each(function() {
      var collisionPosition,
        using,
        elem = $(this),
        elemWidth = elem.outerWidth(),
        elemHeight = elem.outerHeight(),
        marginLeft = parseCss(this, 'marginLeft'),
        marginTop = parseCss(this, 'marginTop'),
        collisionWidth = elemWidth + marginLeft + parseCss(this, 'marginRight') + scrollInfo.width,
        collisionHeight = elemHeight + marginTop + parseCss(this, 'marginBottom') + scrollInfo.height,
        position = $.extend({}, basePosition),
        myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());

      if (options.my[0] === 'right') {
        position.left -= elemWidth;
      } else if (options.my[0] === 'center') {
        position.left -= elemWidth / 2;
      }

      if (options.my[1] === 'bottom') {
        position.top -= elemHeight;
      } else if (options.my[1] === 'center') {
        position.top -= elemHeight / 2;
      }

      position.left += myOffset[0];
      position.top += myOffset[1];

      // if the browser doesn't support fractions, then round for consistent results
      if (!$.support.offsetFractions) {
        position.left = round(position.left);
        position.top = round(position.top);
      }

      collisionPosition = {
        marginLeft: marginLeft,
        marginTop: marginTop,
      };

      $.each(['left', 'top'], function(i, dir) {
        if ($.ui.position[collision[i]]) {
          $.ui.position[collision[i]][dir](position, {
            targetWidth: targetWidth,
            targetHeight: targetHeight,
            elemWidth: elemWidth,
            elemHeight: elemHeight,
            collisionPosition: collisionPosition,
            collisionWidth: collisionWidth,
            collisionHeight: collisionHeight,
            offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
            my: options.my,
            at: options.at,
            within: within,
            elem: elem,
          });
        }
      });

      if (options.using) {
        // adds feedback as second argument to using callback, if present
        using = function(props) {
          var left = targetOffset.left - position.left,
            right = left + targetWidth - elemWidth,
            top = targetOffset.top - position.top,
            bottom = top + targetHeight - elemHeight,
            feedback = {
              target: {
                element: target,
                left: targetOffset.left,
                top: targetOffset.top,
                width: targetWidth,
                height: targetHeight,
              },
              element: {
                element: elem,
                left: position.left,
                top: position.top,
                width: elemWidth,
                height: elemHeight,
              },
              horizontal: right < 0 ? 'left' : left > 0 ? 'right' : 'center',
              vertical: bottom < 0 ? 'top' : top > 0 ? 'bottom' : 'middle',
            };
          if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
            feedback.horizontal = 'center';
          }
          if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
            feedback.vertical = 'middle';
          }
          if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
            feedback.important = 'horizontal';
          } else {
            feedback.important = 'vertical';
          }
          options.using.call(this, props, feedback);
        };
      }

      elem.offset($.extend(position, { using: using }));
    });
  };

  $.ui.position = {
    fit: {
      left: function(position, data) {
        var within = data.within,
          withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
          outerWidth = within.width,
          collisionPosLeft = position.left - data.collisionPosition.marginLeft,
          overLeft = withinOffset - collisionPosLeft,
          overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
          newOverRight;

        // element is wider than within
        if (data.collisionWidth > outerWidth) {
          // element is initially over the left side of within
          if (overLeft > 0 && overRight <= 0) {
            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
            position.left += overLeft - newOverRight;
            // element is initially over right side of within
          } else if (overRight > 0 && overLeft <= 0) {
            position.left = withinOffset;
            // element is initially over both left and right sides of within
          } else {
            if (overLeft > overRight) {
              position.left = withinOffset + outerWidth - data.collisionWidth;
            } else {
              position.left = withinOffset;
            }
          }
          // too far left -> align with left edge
        } else if (overLeft > 0) {
          position.left += overLeft;
          // too far right -> align with right edge
        } else if (overRight > 0) {
          position.left -= overRight;
          // adjust based on position and margin
        } else {
          position.left = max(position.left - collisionPosLeft, position.left);
        }
      },
      top: function(position, data) {
        var within = data.within,
          withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
          outerHeight = data.within.height,
          collisionPosTop = position.top - data.collisionPosition.marginTop,
          overTop = withinOffset - collisionPosTop,
          overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
          newOverBottom;

        // element is taller than within
        if (data.collisionHeight > outerHeight) {
          // element is initially over the top of within
          if (overTop > 0 && overBottom <= 0) {
            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
            position.top += overTop - newOverBottom;
            // element is initially over bottom of within
          } else if (overBottom > 0 && overTop <= 0) {
            position.top = withinOffset;
            // element is initially over both top and bottom of within
          } else {
            if (overTop > overBottom) {
              position.top = withinOffset + outerHeight - data.collisionHeight;
            } else {
              position.top = withinOffset;
            }
          }
          // too far up -> align with top
        } else if (overTop > 0) {
          position.top += overTop;
          // too far down -> align with bottom edge
        } else if (overBottom > 0) {
          position.top -= overBottom;
          // adjust based on position and margin
        } else {
          position.top = max(position.top - collisionPosTop, position.top);
        }
      },
    },
    flip: {
      left: function(position, data) {
        var within = data.within,
          withinOffset = within.offset.left + within.scrollLeft,
          outerWidth = within.width,
          offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
          collisionPosLeft = position.left - data.collisionPosition.marginLeft,
          overLeft = collisionPosLeft - offsetLeft,
          overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
          myOffset = data.my[0] === 'left' ? -data.elemWidth : data.my[0] === 'right' ? data.elemWidth : 0,
          atOffset = data.at[0] === 'left' ? data.targetWidth : data.at[0] === 'right' ? -data.targetWidth : 0,
          offset = -2 * data.offset[0],
          newOverRight,
          newOverLeft;

        if (overLeft < 0) {
          newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
          if (newOverRight < 0 || newOverRight < abs(overLeft)) {
            position.left += myOffset + atOffset + offset;
          }
        } else if (overRight > 0) {
          newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
          if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
            position.left += myOffset + atOffset + offset;
          }
        }
      },
      top: function(position, data) {
        var within = data.within,
          withinOffset = within.offset.top + within.scrollTop,
          outerHeight = within.height,
          offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
          collisionPosTop = position.top - data.collisionPosition.marginTop,
          overTop = collisionPosTop - offsetTop,
          overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
          top = data.my[1] === 'top',
          myOffset = top ? -data.elemHeight : data.my[1] === 'bottom' ? data.elemHeight : 0,
          atOffset = data.at[1] === 'top' ? data.targetHeight : data.at[1] === 'bottom' ? -data.targetHeight : 0,
          offset = -2 * data.offset[1],
          newOverTop,
          newOverBottom;
        if (overTop < 0) {
          newOverBottom =
            position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
          if (
            position.top + myOffset + atOffset + offset > overTop &&
            (newOverBottom < 0 || newOverBottom < abs(overTop))
          ) {
            position.top += myOffset + atOffset + offset;
          }
        } else if (overBottom > 0) {
          newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
          if (
            position.top + myOffset + atOffset + offset > overBottom &&
            (newOverTop > 0 || abs(newOverTop) < overBottom)
          ) {
            position.top += myOffset + atOffset + offset;
          }
        }
      },
    },
    flipfit: {
      left: function() {
        $.ui.position.flip.left.apply(this, arguments);
        $.ui.position.fit.left.apply(this, arguments);
      },
      top: function() {
        $.ui.position.flip.top.apply(this, arguments);
        $.ui.position.fit.top.apply(this, arguments);
      },
    },
  };

  // fraction support test
  (function() {
    var testElement,
      testElementParent,
      testElementStyle,
      offsetLeft,
      i,
      body = document.getElementsByTagName('body')[0],
      div = document.createElement('div');

    //Create a "fake body" for testing based on method used in jQuery.support
    testElement = document.createElement(body ? 'div' : 'body');
    testElementStyle = {
      visibility: 'hidden',
      width: 0,
      height: 0,
      border: 0,
      margin: 0,
      background: 'none',
    };
    if (body) {
      $.extend(testElementStyle, {
        position: 'absolute',
        left: '-1000px',
        top: '-1000px',
      });
    }
    for (i in testElementStyle) {
      testElement.style[i] = testElementStyle[i];
    }
    testElement.appendChild(div);
    testElementParent = body || document.documentElement;
    testElementParent.insertBefore(testElement, testElementParent.firstChild);

    div.style.cssText = 'position: absolute; left: 10.7432222px;';

    offsetLeft = $(div).offset().left;
    $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

    testElement.innerHTML = '';
    testElementParent.removeChild(testElement);
  })();
})(jQuery);

(function($, undefined) {
  $.widget('ui.progressbar', {
    version: '1.10.3',
    options: {
      max: 100,
      value: 0,

      change: null,
      complete: null,
    },

    min: 0,

    _create: function() {
      // Constrain initial value
      this.oldValue = this.options.value = this._constrainedValue();

      this.element.addClass('ui-progressbar ui-widget ui-widget-content ui-corner-all').attr({
        // Only set static values, aria-valuenow and aria-valuemax are
        // set inside _refreshValue()
        role: 'progressbar',
        'aria-valuemin': this.min,
      });

      this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(
        this.element
      );

      this._refreshValue();
    },

    _destroy: function() {
      this.element
        .removeClass('ui-progressbar ui-widget ui-widget-content ui-corner-all')
        .removeAttr('role')
        .removeAttr('aria-valuemin')
        .removeAttr('aria-valuemax')
        .removeAttr('aria-valuenow');

      this.valueDiv.remove();
    },

    value: function(newValue) {
      if (newValue === undefined) {
        return this.options.value;
      }

      this.options.value = this._constrainedValue(newValue);
      this._refreshValue();
    },

    _constrainedValue: function(newValue) {
      if (newValue === undefined) {
        newValue = this.options.value;
      }

      this.indeterminate = newValue === false;

      // sanitize value
      if (typeof newValue !== 'number') {
        newValue = 0;
      }

      return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
    },

    _setOptions: function(options) {
      // Ensure "value" option is set after other values (like max)
      var value = options.value;
      delete options.value;

      this._super(options);

      this.options.value = this._constrainedValue(value);
      this._refreshValue();
    },

    _setOption: function(key, value) {
      if (key === 'max') {
        // Don't allow a max less than min
        value = Math.max(this.min, value);
      }

      this._super(key, value);
    },

    _percentage: function() {
      return this.indeterminate ? 100 : (100 * (this.options.value - this.min)) / (this.options.max - this.min);
    },

    _refreshValue: function() {
      var value = this.options.value,
        percentage = this._percentage();

      this.valueDiv
        .toggle(this.indeterminate || value > this.min)
        .toggleClass('ui-corner-right', value === this.options.max)
        .width(percentage.toFixed(0) + '%');

      this.element.toggleClass('ui-progressbar-indeterminate', this.indeterminate);

      if (this.indeterminate) {
        this.element.removeAttr('aria-valuenow');
        if (!this.overlayDiv) {
          this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv);
        }
      } else {
        this.element.attr({
          'aria-valuemax': this.options.max,
          'aria-valuenow': value,
        });
        if (this.overlayDiv) {
          this.overlayDiv.remove();
          this.overlayDiv = null;
        }
      }

      if (this.oldValue !== value) {
        this.oldValue = value;
        this._trigger('change');
      }
      if (value === this.options.max) {
        this._trigger('complete');
      }
    },
  });
})(jQuery);

(function($, undefined) {
  // number of pages in a slider
  // (how many times can you page up/down to go through the whole range)
  var numPages = 5;

  $.widget('ui.slider', $.ui.mouse, {
    version: '1.10.3',
    widgetEventPrefix: 'slide',

    options: {
      animate: false,
      distance: 0,
      max: 100,
      min: 0,
      orientation: 'horizontal',
      range: false,
      step: 1,
      value: 0,
      values: null,

      // callbacks
      change: null,
      slide: null,
      start: null,
      stop: null,
    },

    _create: function() {
      this._keySliding = false;
      this._mouseSliding = false;
      this._animateOff = true;
      this._handleIndex = null;
      this._detectOrientation();
      this._mouseInit();

      this.element.addClass(
        'ui-slider' + ' ui-slider-' + this.orientation + ' ui-widget' + ' ui-widget-content' + ' ui-corner-all'
      );

      this._refresh();
      this._setOption('disabled', this.options.disabled);

      this._animateOff = false;
    },

    _refresh: function() {
      this._createRange();
      this._createHandles();
      this._setupEvents();
      this._refreshValue();
    },

    _createHandles: function() {
      var i,
        handleCount,
        options = this.options,
        existingHandles = this.element.find('.ui-slider-handle').addClass('ui-state-default ui-corner-all'),
        handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
        handles = [];

      handleCount = (options.values && options.values.length) || 1;

      if (existingHandles.length > handleCount) {
        existingHandles.slice(handleCount).remove();
        existingHandles = existingHandles.slice(0, handleCount);
      }

      for (i = existingHandles.length; i < handleCount; i++) {
        handles.push(handle);
      }

      this.handles = existingHandles.add($(handles.join('')).appendTo(this.element));

      this.handle = this.handles.eq(0);

      this.handles.each(function(i) {
        $(this).data('ui-slider-handle-index', i);
      });
    },

    _createRange: function() {
      var options = this.options,
        classes = '';

      if (options.range) {
        if (options.range === true) {
          if (!options.values) {
            options.values = [this._valueMin(), this._valueMin()];
          } else if (options.values.length && options.values.length !== 2) {
            options.values = [options.values[0], options.values[0]];
          } else if ($.isArray(options.values)) {
            options.values = options.values.slice(0);
          }
        }

        if (!this.range || !this.range.length) {
          this.range = $('<div></div>').appendTo(this.element);

          classes =
            'ui-slider-range' +
            // note: this isn't the most fittingly semantic framework class for this element,
            // but worked best visually with a variety of themes
            ' ui-widget-header ui-corner-all';
        } else {
          this.range
            .removeClass('ui-slider-range-min ui-slider-range-max')
            // Handle range switching from true to min/max
            .css({
              left: '',
              bottom: '',
            });
        }

        this.range.addClass(
          classes + (options.range === 'min' || options.range === 'max' ? ' ui-slider-range-' + options.range : '')
        );
      } else {
        this.range = $([]);
      }
    },

    _setupEvents: function() {
      var elements = this.handles.add(this.range).filter('a');
      this._off(elements);
      this._on(elements, this._handleEvents);
      this._hoverable(elements);
      this._focusable(elements);
    },

    _destroy: function() {
      this.handles.remove();
      this.range.remove();

      this.element.removeClass(
        'ui-slider' +
          ' ui-slider-horizontal' +
          ' ui-slider-vertical' +
          ' ui-widget' +
          ' ui-widget-content' +
          ' ui-corner-all'
      );

      this._mouseDestroy();
    },

    _mouseCapture: function(event) {
      var position,
        normValue,
        distance,
        closestHandle,
        index,
        allowed,
        offset,
        mouseOverHandle,
        that = this,
        o = this.options;

      if (o.disabled) {
        return false;
      }

      this.elementSize = {
        width: this.element.outerWidth(),
        height: this.element.outerHeight(),
      };
      this.elementOffset = this.element.offset();

      position = { x: event.pageX, y: event.pageY };
      normValue = this._normValueFromMouse(position);
      distance = this._valueMax() - this._valueMin() + 1;
      this.handles.each(function(i) {
        var thisDistance = Math.abs(normValue - that.values(i));
        if (
          distance > thisDistance ||
          (distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min))
        ) {
          distance = thisDistance;
          closestHandle = $(this);
          index = i;
        }
      });

      allowed = this._start(event, index);
      if (allowed === false) {
        return false;
      }
      this._mouseSliding = true;

      this._handleIndex = index;

      closestHandle.addClass('ui-state-active').focus();

      offset = closestHandle.offset();
      mouseOverHandle = !$(event.target)
        .parents()
        .addBack()
        .is('.ui-slider-handle');
      this._clickOffset = mouseOverHandle
        ? { left: 0, top: 0 }
        : {
            left: event.pageX - offset.left - closestHandle.width() / 2,
            top:
              event.pageY -
              offset.top -
              closestHandle.height() / 2 -
              (parseInt(closestHandle.css('borderTopWidth'), 10) || 0) -
              (parseInt(closestHandle.css('borderBottomWidth'), 10) || 0) +
              (parseInt(closestHandle.css('marginTop'), 10) || 0),
          };

      if (!this.handles.hasClass('ui-state-hover')) {
        this._slide(event, index, normValue);
      }
      this._animateOff = true;
      return true;
    },

    _mouseStart: function() {
      return true;
    },

    _mouseDrag: function(event) {
      var position = { x: event.pageX, y: event.pageY },
        normValue = this._normValueFromMouse(position);

      this._slide(event, this._handleIndex, normValue);

      return false;
    },

    _mouseStop: function(event) {
      this.handles.removeClass('ui-state-active');
      this._mouseSliding = false;

      this._stop(event, this._handleIndex);
      this._change(event, this._handleIndex);

      this._handleIndex = null;
      this._clickOffset = null;
      this._animateOff = false;

      return false;
    },

    _detectOrientation: function() {
      this.orientation = this.options.orientation === 'vertical' ? 'vertical' : 'horizontal';
    },

    _normValueFromMouse: function(position) {
      var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;

      if (this.orientation === 'horizontal') {
        pixelTotal = this.elementSize.width;
        pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
      } else {
        pixelTotal = this.elementSize.height;
        pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
      }

      percentMouse = pixelMouse / pixelTotal;
      if (percentMouse > 1) {
        percentMouse = 1;
      }
      if (percentMouse < 0) {
        percentMouse = 0;
      }
      if (this.orientation === 'vertical') {
        percentMouse = 1 - percentMouse;
      }

      valueTotal = this._valueMax() - this._valueMin();
      valueMouse = this._valueMin() + percentMouse * valueTotal;

      return this._trimAlignValue(valueMouse);
    },

    _start: function(event, index) {
      var uiHash = {
        handle: this.handles[index],
        value: this.value(),
      };
      if (this.options.values && this.options.values.length) {
        uiHash.value = this.values(index);
        uiHash.values = this.values();
      }
      return this._trigger('start', event, uiHash);
    },

    _slide: function(event, index, newVal) {
      var otherVal, newValues, allowed;

      if (this.options.values && this.options.values.length) {
        otherVal = this.values(index ? 0 : 1);

        if (
          this.options.values.length === 2 &&
          this.options.range === true &&
          ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))
        ) {
          newVal = otherVal;
        }

        if (newVal !== this.values(index)) {
          newValues = this.values();
          newValues[index] = newVal;
          // A slide can be canceled by returning false from the slide callback
          allowed = this._trigger('slide', event, {
            handle: this.handles[index],
            value: newVal,
            values: newValues,
          });
          otherVal = this.values(index ? 0 : 1);
          if (allowed !== false) {
            this.values(index, newVal, true);
          }
        }
      } else {
        if (newVal !== this.value()) {
          // A slide can be canceled by returning false from the slide callback
          allowed = this._trigger('slide', event, {
            handle: this.handles[index],
            value: newVal,
          });
          if (allowed !== false) {
            this.value(newVal);
          }
        }
      }
    },

    _stop: function(event, index) {
      var uiHash = {
        handle: this.handles[index],
        value: this.value(),
      };
      if (this.options.values && this.options.values.length) {
        uiHash.value = this.values(index);
        uiHash.values = this.values();
      }

      this._trigger('stop', event, uiHash);
    },

    _change: function(event, index) {
      if (!this._keySliding && !this._mouseSliding) {
        var uiHash = {
          handle: this.handles[index],
          value: this.value(),
        };
        if (this.options.values && this.options.values.length) {
          uiHash.value = this.values(index);
          uiHash.values = this.values();
        }

        //store the last changed value index for reference when handles overlap
        this._lastChangedValue = index;

        this._trigger('change', event, uiHash);
      }
    },

    value: function(newValue) {
      if (arguments.length) {
        this.options.value = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, 0);
        return;
      }

      return this._value();
    },

    values: function(index, newValue) {
      var vals, newValues, i;

      if (arguments.length > 1) {
        this.options.values[index] = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, index);
        return;
      }

      if (arguments.length) {
        if ($.isArray(arguments[0])) {
          vals = this.options.values;
          newValues = arguments[0];
          for (i = 0; i < vals.length; i += 1) {
            vals[i] = this._trimAlignValue(newValues[i]);
            this._change(null, i);
          }
          this._refreshValue();
        } else {
          if (this.options.values && this.options.values.length) {
            return this._values(index);
          } else {
            return this.value();
          }
        }
      } else {
        return this._values();
      }
    },

    _setOption: function(key, value) {
      var i,
        valsLength = 0;

      if (key === 'range' && this.options.range === true) {
        if (value === 'min') {
          this.options.value = this._values(0);
          this.options.values = null;
        } else if (value === 'max') {
          this.options.value = this._values(this.options.values.length - 1);
          this.options.values = null;
        }
      }

      if ($.isArray(this.options.values)) {
        valsLength = this.options.values.length;
      }

      $.Widget.prototype._setOption.apply(this, arguments);

      switch (key) {
        case 'orientation':
          this._detectOrientation();
          this.element.removeClass('ui-slider-horizontal ui-slider-vertical').addClass('ui-slider-' + this.orientation);
          this._refreshValue();
          break;
        case 'value':
          this._animateOff = true;
          this._refreshValue();
          this._change(null, 0);
          this._animateOff = false;
          break;
        case 'values':
          this._animateOff = true;
          this._refreshValue();
          for (i = 0; i < valsLength; i += 1) {
            this._change(null, i);
          }
          this._animateOff = false;
          break;
        case 'min':
        case 'max':
          this._animateOff = true;
          this._refreshValue();
          this._animateOff = false;
          break;
        case 'range':
          this._animateOff = true;
          this._refresh();
          this._animateOff = false;
          break;
      }
    },

    //internal value getter
    // _value() returns value trimmed by min and max, aligned by step
    _value: function() {
      var val = this.options.value;
      val = this._trimAlignValue(val);

      return val;
    },

    //internal values getter
    // _values() returns array of values trimmed by min and max, aligned by step
    // _values( index ) returns single value trimmed by min and max, aligned by step
    _values: function(index) {
      var val, vals, i;

      if (arguments.length) {
        val = this.options.values[index];
        val = this._trimAlignValue(val);

        return val;
      } else if (this.options.values && this.options.values.length) {
        // .slice() creates a copy of the array
        // this copy gets trimmed by min and max and then returned
        vals = this.options.values.slice();
        for (i = 0; i < vals.length; i += 1) {
          vals[i] = this._trimAlignValue(vals[i]);
        }

        return vals;
      } else {
        return [];
      }
    },

    // returns the step-aligned value that val is closest to, between (inclusive) min and max
    _trimAlignValue: function(val) {
      if (val <= this._valueMin()) {
        return this._valueMin();
      }
      if (val >= this._valueMax()) {
        return this._valueMax();
      }
      var step = this.options.step > 0 ? this.options.step : 1,
        valModStep = (val - this._valueMin()) % step,
        alignValue = val - valModStep;

      if (Math.abs(valModStep) * 2 >= step) {
        alignValue += valModStep > 0 ? step : -step;
      }

      // Since JavaScript has problems with large floats, round
      // the final value to 5 digits after the decimal point (see #4124)
      return parseFloat(alignValue.toFixed(5));
    },

    _valueMin: function() {
      return this.options.min;
    },

    _valueMax: function() {
      return this.options.max;
    },

    _refreshValue: function() {
      var lastValPercent,
        valPercent,
        value,
        valueMin,
        valueMax,
        oRange = this.options.range,
        o = this.options,
        that = this,
        animate = !this._animateOff ? o.animate : false,
        _set = {};

      if (this.options.values && this.options.values.length) {
        this.handles.each(function(i) {
          valPercent = ((that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin())) * 100;
          _set[that.orientation === 'horizontal' ? 'left' : 'bottom'] = valPercent + '%';
          $(this)
            .stop(1, 1)
            [animate ? 'animate' : 'css'](_set, o.animate);
          if (that.options.range === true) {
            if (that.orientation === 'horizontal') {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? 'animate' : 'css']({ left: valPercent + '%' }, o.animate);
              }
              if (i === 1) {
                that.range[animate ? 'animate' : 'css'](
                  { width: valPercent - lastValPercent + '%' },
                  { queue: false, duration: o.animate }
                );
              }
            } else {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? 'animate' : 'css']({ bottom: valPercent + '%' }, o.animate);
              }
              if (i === 1) {
                that.range[animate ? 'animate' : 'css'](
                  { height: valPercent - lastValPercent + '%' },
                  { queue: false, duration: o.animate }
                );
              }
            }
          }
          lastValPercent = valPercent;
        });
      } else {
        value = this.value();
        valueMin = this._valueMin();
        valueMax = this._valueMax();
        valPercent = valueMax !== valueMin ? ((value - valueMin) / (valueMax - valueMin)) * 100 : 0;
        _set[this.orientation === 'horizontal' ? 'left' : 'bottom'] = valPercent + '%';
        this.handle.stop(1, 1)[animate ? 'animate' : 'css'](_set, o.animate);

        if (oRange === 'min' && this.orientation === 'horizontal') {
          this.range.stop(1, 1)[animate ? 'animate' : 'css']({ width: valPercent + '%' }, o.animate);
        }
        if (oRange === 'max' && this.orientation === 'horizontal') {
          this.range[animate ? 'animate' : 'css'](
            { width: 100 - valPercent + '%' },
            { queue: false, duration: o.animate }
          );
        }
        if (oRange === 'min' && this.orientation === 'vertical') {
          this.range.stop(1, 1)[animate ? 'animate' : 'css']({ height: valPercent + '%' }, o.animate);
        }
        if (oRange === 'max' && this.orientation === 'vertical') {
          this.range[animate ? 'animate' : 'css'](
            { height: 100 - valPercent + '%' },
            { queue: false, duration: o.animate }
          );
        }
      }
    },

    _handleEvents: {
      keydown: function(event) {
        /*jshint maxcomplexity:25*/
        var allowed,
          curVal,
          newVal,
          step,
          index = $(event.target).data('ui-slider-handle-index');

        switch (event.keyCode) {
          case $.ui.keyCode.HOME:
          case $.ui.keyCode.END:
          case $.ui.keyCode.PAGE_UP:
          case $.ui.keyCode.PAGE_DOWN:
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            event.preventDefault();
            if (!this._keySliding) {
              this._keySliding = true;
              $(event.target).addClass('ui-state-active');
              allowed = this._start(event, index);
              if (allowed === false) {
                return;
              }
            }
            break;
        }

        step = this.options.step;
        if (this.options.values && this.options.values.length) {
          curVal = newVal = this.values(index);
        } else {
          curVal = newVal = this.value();
        }

        switch (event.keyCode) {
          case $.ui.keyCode.HOME:
            newVal = this._valueMin();
            break;
          case $.ui.keyCode.END:
            newVal = this._valueMax();
            break;
          case $.ui.keyCode.PAGE_UP:
            newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / numPages);
            break;
          case $.ui.keyCode.PAGE_DOWN:
            newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / numPages);
            break;
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
            if (curVal === this._valueMax()) {
              return;
            }
            newVal = this._trimAlignValue(curVal + step);
            break;
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            if (curVal === this._valueMin()) {
              return;
            }
            newVal = this._trimAlignValue(curVal - step);
            break;
        }

        this._slide(event, index, newVal);
      },
      click: function(event) {
        event.preventDefault();
      },
      keyup: function(event) {
        var index = $(event.target).data('ui-slider-handle-index');

        if (this._keySliding) {
          this._keySliding = false;
          this._stop(event, index);
          this._change(event, index);
          $(event.target).removeClass('ui-state-active');
        }
      },
    },
  });
})(jQuery);

(function($) {
  function modifier(fn) {
    return function() {
      var previous = this.element.val();
      fn.apply(this, arguments);
      this._refresh();
      if (previous !== this.element.val()) {
        this._trigger('change');
      }
    };
  }

  $.widget('ui.spinner', {
    version: '1.10.3',
    defaultElement: '<input>',
    widgetEventPrefix: 'spin',
    options: {
      culture: null,
      icons: {
        down: 'ui-icon-triangle-1-s',
        up: 'ui-icon-triangle-1-n',
      },
      incremental: true,
      max: null,
      min: null,
      numberFormat: null,
      page: 10,
      step: 1,

      change: null,
      spin: null,
      start: null,
      stop: null,
    },

    _create: function() {
      // handle string values that need to be parsed
      this._setOption('max', this.options.max);
      this._setOption('min', this.options.min);
      this._setOption('step', this.options.step);

      // format the value, but don't constrain
      this._value(this.element.val(), true);

      this._draw();
      this._on(this._events);
      this._refresh();

      // turning off autocomplete prevents the browser from remembering the
      // value when navigating through history, so we re-enable autocomplete
      // if the page is unloaded before the widget is destroyed. #7790
      this._on(this.window, {
        beforeunload: function() {
          this.element.removeAttr('autocomplete');
        },
      });
    },

    _getCreateOptions: function() {
      var options = {},
        element = this.element;

      $.each(['min', 'max', 'step'], function(i, option) {
        var value = element.attr(option);
        if (value !== undefined && value.length) {
          options[option] = value;
        }
      });

      return options;
    },

    _events: {
      keydown: function(event) {
        if (this._start(event) && this._keydown(event)) {
          event.preventDefault();
        }
      },
      keyup: '_stop',
      focus: function() {
        this.previous = this.element.val();
      },
      blur: function(event) {
        if (this.cancelBlur) {
          delete this.cancelBlur;
          return;
        }

        this._stop();
        this._refresh();
        if (this.previous !== this.element.val()) {
          this._trigger('change', event);
        }
      },
      mousewheel: function(event, delta) {
        if (!delta) {
          return;
        }
        if (!this.spinning && !this._start(event)) {
          return false;
        }

        this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
        clearTimeout(this.mousewheelTimer);
        this.mousewheelTimer = this._delay(function() {
          if (this.spinning) {
            this._stop(event);
          }
        }, 100);
        event.preventDefault();
      },
      'mousedown .ui-spinner-button': function(event) {
        var previous;

        // We never want the buttons to have focus; whenever the user is
        // interacting with the spinner, the focus should be on the input.
        // If the input is focused then this.previous is properly set from
        // when the input first received focus. If the input is not focused
        // then we need to set this.previous based on the value before spinning.
        previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();
        function checkFocus() {
          var isActive = this.element[0] === this.document[0].activeElement;
          if (!isActive) {
            this.element.focus();
            this.previous = previous;
            // support: IE
            // IE sets focus asynchronously, so we need to check if focus
            // moved off of the input because the user clicked on the button.
            this._delay(function() {
              this.previous = previous;
            });
          }
        }

        // ensure focus is on (or stays on) the text field
        event.preventDefault();
        checkFocus.call(this);

        // support: IE
        // IE doesn't prevent moving focus even with event.preventDefault()
        // so we set a flag to know when we should ignore the blur event
        // and check (again) if focus moved off of the input.
        this.cancelBlur = true;
        this._delay(function() {
          delete this.cancelBlur;
          checkFocus.call(this);
        });

        if (this._start(event) === false) {
          return;
        }

        this._repeat(null, $(event.currentTarget).hasClass('ui-spinner-up') ? 1 : -1, event);
      },
      'mouseup .ui-spinner-button': '_stop',
      'mouseenter .ui-spinner-button': function(event) {
        // button will add ui-state-active if mouse was down while mouseleave and kept down
        if (!$(event.currentTarget).hasClass('ui-state-active')) {
          return;
        }

        if (this._start(event) === false) {
          return false;
        }
        this._repeat(null, $(event.currentTarget).hasClass('ui-spinner-up') ? 1 : -1, event);
      },
      // TODO: do we really want to consider this a stop?
      // shouldn't we just stop the repeater and wait until mouseup before
      // we trigger the stop event?
      'mouseleave .ui-spinner-button': '_stop',
    },

    _draw: function() {
      var uiSpinner = (this.uiSpinner = this.element
        .addClass('ui-spinner-input')
        .attr('autocomplete', 'off')
        .wrap(this._uiSpinnerHtml())
        .parent()
        // add buttons
        .append(this._buttonHtml()));

      this.element.attr('role', 'spinbutton');

      // button bindings
      this.buttons = uiSpinner
        .find('.ui-spinner-button')
        .attr('tabIndex', -1)
        .button()
        .removeClass('ui-corner-all');

      // IE 6 doesn't understand height: 50% for the buttons
      // unless the wrapper has an explicit height
      if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) && uiSpinner.height() > 0) {
        uiSpinner.height(uiSpinner.height());
      }

      // disable spinner if element was already disabled
      if (this.options.disabled) {
        this.disable();
      }
    },

    _keydown: function(event) {
      var options = this.options,
        keyCode = $.ui.keyCode;

      switch (event.keyCode) {
        case keyCode.UP:
          this._repeat(null, 1, event);
          return true;
        case keyCode.DOWN:
          this._repeat(null, -1, event);
          return true;
        case keyCode.PAGE_UP:
          this._repeat(null, options.page, event);
          return true;
        case keyCode.PAGE_DOWN:
          this._repeat(null, -options.page, event);
          return true;
      }

      return false;
    },

    _uiSpinnerHtml: function() {
      return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
    },

    _buttonHtml: function() {
      return (
        '' +
        "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
        "<span class='ui-icon " +
        this.options.icons.up +
        "'>&#9650;</span>" +
        '</a>' +
        "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
        "<span class='ui-icon " +
        this.options.icons.down +
        "'>&#9660;</span>" +
        '</a>'
      );
    },

    _start: function(event) {
      if (!this.spinning && this._trigger('start', event) === false) {
        return false;
      }

      if (!this.counter) {
        this.counter = 1;
      }
      this.spinning = true;
      return true;
    },

    _repeat: function(i, steps, event) {
      i = i || 500;

      clearTimeout(this.timer);
      this.timer = this._delay(function() {
        this._repeat(40, steps, event);
      }, i);

      this._spin(steps * this.options.step, event);
    },

    _spin: function(step, event) {
      var value = this.value() || 0;

      if (!this.counter) {
        this.counter = 1;
      }

      value = this._adjustValue(value + step * this._increment(this.counter));

      if (!this.spinning || this._trigger('spin', event, { value: value }) !== false) {
        this._value(value);
        this.counter++;
      }
    },

    _increment: function(i) {
      var incremental = this.options.incremental;

      if (incremental) {
        return $.isFunction(incremental)
          ? incremental(i)
          : Math.floor((i * i * i) / 50000 - (i * i) / 500 + (17 * i) / 200 + 1);
      }

      return 1;
    },

    _precision: function() {
      var precision = this._precisionOf(this.options.step);
      if (this.options.min !== null) {
        precision = Math.max(precision, this._precisionOf(this.options.min));
      }
      return precision;
    },

    _precisionOf: function(num) {
      var str = num.toString(),
        decimal = str.indexOf('.');
      return decimal === -1 ? 0 : str.length - decimal - 1;
    },

    _adjustValue: function(value) {
      var base,
        aboveMin,
        options = this.options;

      // make sure we're at a valid step
      // - find out where we are relative to the base (min or 0)
      base = options.min !== null ? options.min : 0;
      aboveMin = value - base;
      // - round to the nearest step
      aboveMin = Math.round(aboveMin / options.step) * options.step;
      // - rounding is based on 0, so adjust back to our base
      value = base + aboveMin;

      // fix precision from bad JS floating point math
      value = parseFloat(value.toFixed(this._precision()));

      // clamp the value
      if (options.max !== null && value > options.max) {
        return options.max;
      }
      if (options.min !== null && value < options.min) {
        return options.min;
      }

      return value;
    },

    _stop: function(event) {
      if (!this.spinning) {
        return;
      }

      clearTimeout(this.timer);
      clearTimeout(this.mousewheelTimer);
      this.counter = 0;
      this.spinning = false;
      this._trigger('stop', event);
    },

    _setOption: function(key, value) {
      if (key === 'culture' || key === 'numberFormat') {
        var prevValue = this._parse(this.element.val());
        this.options[key] = value;
        this.element.val(this._format(prevValue));
        return;
      }

      if (key === 'max' || key === 'min' || key === 'step') {
        if (typeof value === 'string') {
          value = this._parse(value);
        }
      }
      if (key === 'icons') {
        this.buttons
          .first()
          .find('.ui-icon')
          .removeClass(this.options.icons.up)
          .addClass(value.up);
        this.buttons
          .last()
          .find('.ui-icon')
          .removeClass(this.options.icons.down)
          .addClass(value.down);
      }

      this._super(key, value);

      if (key === 'disabled') {
        if (value) {
          this.element.prop('disabled', true);
          this.buttons.button('disable');
        } else {
          this.element.prop('disabled', false);
          this.buttons.button('enable');
        }
      }
    },

    _setOptions: modifier(function(options) {
      this._super(options);
      this._value(this.element.val());
    }),

    _parse: function(val) {
      if (typeof val === 'string' && val !== '') {
        val =
          window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
      }
      return val === '' || isNaN(val) ? null : val;
    },

    _format: function(value) {
      if (value === '') {
        return '';
      }
      return window.Globalize && this.options.numberFormat
        ? Globalize.format(value, this.options.numberFormat, this.options.culture)
        : value;
    },

    _refresh: function() {
      this.element.attr({
        'aria-valuemin': this.options.min,
        'aria-valuemax': this.options.max,
        // TODO: what should we do with values that can't be parsed?
        'aria-valuenow': this._parse(this.element.val()),
      });
    },

    // update the value without triggering change
    _value: function(value, allowAny) {
      var parsed;
      if (value !== '') {
        parsed = this._parse(value);
        if (parsed !== null) {
          if (!allowAny) {
            parsed = this._adjustValue(parsed);
          }
          value = this._format(parsed);
        }
      }
      this.element.val(value);
      this._refresh();
    },

    _destroy: function() {
      this.element
        .removeClass('ui-spinner-input')
        .prop('disabled', false)
        .removeAttr('autocomplete')
        .removeAttr('role')
        .removeAttr('aria-valuemin')
        .removeAttr('aria-valuemax')
        .removeAttr('aria-valuenow');
      this.uiSpinner.replaceWith(this.element);
    },

    stepUp: modifier(function(steps) {
      this._stepUp(steps);
    }),
    _stepUp: function(steps) {
      if (this._start()) {
        this._spin((steps || 1) * this.options.step);
        this._stop();
      }
    },

    stepDown: modifier(function(steps) {
      this._stepDown(steps);
    }),
    _stepDown: function(steps) {
      if (this._start()) {
        this._spin((steps || 1) * -this.options.step);
        this._stop();
      }
    },

    pageUp: modifier(function(pages) {
      this._stepUp((pages || 1) * this.options.page);
    }),

    pageDown: modifier(function(pages) {
      this._stepDown((pages || 1) * this.options.page);
    }),

    value: function(newVal) {
      if (!arguments.length) {
        return this._parse(this.element.val());
      }
      modifier(this._value).call(this, newVal);
    },

    widget: function() {
      return this.uiSpinner;
    },
  });
})(jQuery);

(function($, undefined) {
  var tabId = 0,
    rhash = /#.*$/;

  function getNextTabId() {
    return ++tabId;
  }

  function isLocal(anchor) {
    return (
      anchor.hash.length > 1 &&
      decodeURIComponent(anchor.href.replace(rhash, '')) === decodeURIComponent(location.href.replace(rhash, ''))
    );
  }

  $.widget('ui.tabs', {
    version: '1.10.3',
    delay: 300,
    options: {
      active: null,
      collapsible: false,
      event: 'click',
      heightStyle: 'content',
      hide: null,
      show: null,

      // callbacks
      activate: null,
      beforeActivate: null,
      beforeLoad: null,
      load: null,
    },

    _create: function() {
      var that = this,
        options = this.options;

      this.running = false;

      this.element
        .addClass('ui-tabs ui-widget ui-widget-content ui-corner-all')
        .toggleClass('ui-tabs-collapsible', options.collapsible)
        // Prevent users from focusing disabled tabs via click
        .delegate('.ui-tabs-nav > li', 'mousedown' + this.eventNamespace, function(event) {
          if ($(this).is('.ui-state-disabled')) {
            event.preventDefault();
          }
        })
        // support: IE <9
        // Preventing the default action in mousedown doesn't prevent IE
        // from focusing the element, so if the anchor gets focused, blur.
        // We don't have to worry about focusing the previously focused
        // element since clicking on a non-focusable element should focus
        // the body anyway.
        .delegate('.ui-tabs-anchor', 'focus' + this.eventNamespace, function() {
          if (
            $(this)
              .closest('li')
              .is('.ui-state-disabled')
          ) {
            this.blur();
          }
        });

      this._processTabs();
      options.active = this._initialActive();

      // Take disabling tabs via class attribute from HTML
      // into account and update option properly.
      if ($.isArray(options.disabled)) {
        options.disabled = $.unique(
          options.disabled.concat(
            $.map(this.tabs.filter('.ui-state-disabled'), function(li) {
              return that.tabs.index(li);
            })
          )
        ).sort();
      }

      // check for length avoids error when initializing empty list
      if (this.options.active !== false && this.anchors.length) {
        this.active = this._findActive(options.active);
      } else {
        this.active = $();
      }

      this._refresh();

      if (this.active.length) {
        this.load(options.active);
      }
    },

    _initialActive: function() {
      var active = this.options.active,
        collapsible = this.options.collapsible,
        locationHash = location.hash.substring(1);

      if (active === null) {
        // check the fragment identifier in the URL
        if (locationHash) {
          this.tabs.each(function(i, tab) {
            if ($(tab).attr('aria-controls') === locationHash) {
              active = i;
              return false;
            }
          });
        }

        // check for a tab marked active via a class
        if (active === null) {
          active = this.tabs.index(this.tabs.filter('.ui-tabs-active'));
        }

        // no active tab, set to false
        if (active === null || active === -1) {
          active = this.tabs.length ? 0 : false;
        }
      }

      // handle numbers: negative, out of range
      if (active !== false) {
        active = this.tabs.index(this.tabs.eq(active));
        if (active === -1) {
          active = collapsible ? false : 0;
        }
      }

      // don't allow collapsible: false and active: false
      if (!collapsible && active === false && this.anchors.length) {
        active = 0;
      }

      return active;
    },

    _getCreateEventData: function() {
      return {
        tab: this.active,
        panel: !this.active.length ? $() : this._getPanelForTab(this.active),
      };
    },

    _tabKeydown: function(event) {
      /*jshint maxcomplexity:15*/
      var focusedTab = $(this.document[0].activeElement).closest('li'),
        selectedIndex = this.tabs.index(focusedTab),
        goingForward = true;

      if (this._handlePageNav(event)) {
        return;
      }

      switch (event.keyCode) {
        case $.ui.keyCode.RIGHT:
        case $.ui.keyCode.DOWN:
          selectedIndex++;
          break;
        case $.ui.keyCode.UP:
        case $.ui.keyCode.LEFT:
          goingForward = false;
          selectedIndex--;
          break;
        case $.ui.keyCode.END:
          selectedIndex = this.anchors.length - 1;
          break;
        case $.ui.keyCode.HOME:
          selectedIndex = 0;
          break;
        case $.ui.keyCode.SPACE:
          // Activate only, no collapsing
          event.preventDefault();
          clearTimeout(this.activating);
          this._activate(selectedIndex);
          return;
        case $.ui.keyCode.ENTER:
          // Toggle (cancel delayed activation, allow collapsing)
          event.preventDefault();
          clearTimeout(this.activating);
          // Determine if we should collapse or activate
          this._activate(selectedIndex === this.options.active ? false : selectedIndex);
          return;
        default:
          return;
      }

      // Focus the appropriate tab, based on which key was pressed
      event.preventDefault();
      clearTimeout(this.activating);
      selectedIndex = this._focusNextTab(selectedIndex, goingForward);

      // Navigating with control key will prevent automatic activation
      if (!event.ctrlKey) {
        // Update aria-selected immediately so that AT think the tab is already selected.
        // Otherwise AT may confuse the user by stating that they need to activate the tab,
        // but the tab will already be activated by the time the announcement finishes.
        focusedTab.attr('aria-selected', 'false');
        this.tabs.eq(selectedIndex).attr('aria-selected', 'true');

        this.activating = this._delay(function() {
          this.option('active', selectedIndex);
        }, this.delay);
      }
    },

    _panelKeydown: function(event) {
      if (this._handlePageNav(event)) {
        return;
      }

      // Ctrl+up moves focus to the current tab
      if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
        event.preventDefault();
        this.active.focus();
      }
    },

    // Alt+page up/down moves focus to the previous/next tab (and activates)
    _handlePageNav: function(event) {
      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
        this._activate(this._focusNextTab(this.options.active - 1, false));
        return true;
      }
      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
        this._activate(this._focusNextTab(this.options.active + 1, true));
        return true;
      }
    },

    _findNextTab: function(index, goingForward) {
      var lastTabIndex = this.tabs.length - 1;

      function constrain() {
        if (index > lastTabIndex) {
          index = 0;
        }
        if (index < 0) {
          index = lastTabIndex;
        }
        return index;
      }

      while ($.inArray(constrain(), this.options.disabled) !== -1) {
        index = goingForward ? index + 1 : index - 1;
      }

      return index;
    },

    _focusNextTab: function(index, goingForward) {
      index = this._findNextTab(index, goingForward);
      this.tabs.eq(index).focus();
      return index;
    },

    _setOption: function(key, value) {
      if (key === 'active') {
        // _activate() will handle invalid values and update this.options
        this._activate(value);
        return;
      }

      if (key === 'disabled') {
        // don't use the widget factory's disabled handling
        this._setupDisabled(value);
        return;
      }

      this._super(key, value);

      if (key === 'collapsible') {
        this.element.toggleClass('ui-tabs-collapsible', value);
        // Setting collapsible: false while collapsed; open first panel
        if (!value && this.options.active === false) {
          this._activate(0);
        }
      }

      if (key === 'event') {
        this._setupEvents(value);
      }

      if (key === 'heightStyle') {
        this._setupHeightStyle(value);
      }
    },

    _tabId: function(tab) {
      return tab.attr('aria-controls') || 'ui-tabs-' + getNextTabId();
    },

    _sanitizeSelector: function(hash) {
      return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, '\\$&') : '';
    },

    refresh: function() {
      var options = this.options,
        lis = this.tablist.children(':has(a[href])');

      // get disabled tabs from class attribute from HTML
      // this will get converted to a boolean if needed in _refresh()
      options.disabled = $.map(lis.filter('.ui-state-disabled'), function(tab) {
        return lis.index(tab);
      });

      this._processTabs();

      // was collapsed or no tabs
      if (options.active === false || !this.anchors.length) {
        options.active = false;
        this.active = $();
        // was active, but active tab is gone
      } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
        // all remaining tabs are disabled
        if (this.tabs.length === options.disabled.length) {
          options.active = false;
          this.active = $();
          // activate previous tab
        } else {
          this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
        }
        // was active, active tab still exists
      } else {
        // make sure active index is correct
        options.active = this.tabs.index(this.active);
      }

      this._refresh();
    },

    _refresh: function() {
      this._setupDisabled(this.options.disabled);
      this._setupEvents(this.options.event);
      this._setupHeightStyle(this.options.heightStyle);

      this.tabs.not(this.active).attr({
        'aria-selected': 'false',
        tabIndex: -1,
      });
      this.panels
        .not(this._getPanelForTab(this.active))
        .hide()
        .attr({
          'aria-expanded': 'false',
          'aria-hidden': 'true',
        });

      // Make sure one tab is in the tab order
      if (!this.active.length) {
        this.tabs.eq(0).attr('tabIndex', 0);
      } else {
        this.active.addClass('ui-tabs-active ui-state-active').attr({
          'aria-selected': 'true',
          tabIndex: 0,
        });
        this._getPanelForTab(this.active)
          .show()
          .attr({
            'aria-expanded': 'true',
            'aria-hidden': 'false',
          });
      }
    },

    _processTabs: function() {
      var that = this;

      this.tablist = this._getList()
        .addClass('ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all')
        .attr('role', 'tablist');

      this.tabs = this.tablist
        .find('> li:has(a[href])')
        .addClass('ui-state-default ui-corner-top')
        .attr({
          role: 'tab',
          tabIndex: -1,
        });

      this.anchors = this.tabs
        .map(function() {
          return $('a', this)[0];
        })
        .addClass('ui-tabs-anchor')
        .attr({
          role: 'presentation',
          tabIndex: -1,
        });

      this.panels = $();

      this.anchors.each(function(i, anchor) {
        var selector,
          panel,
          panelId,
          anchorId = $(anchor)
            .uniqueId()
            .attr('id'),
          tab = $(anchor).closest('li'),
          originalAriaControls = tab.attr('aria-controls');

        // inline tab
        if (isLocal(anchor)) {
          selector = anchor.hash;
          panel = that.element.find(that._sanitizeSelector(selector));
          // remote tab
        } else {
          panelId = that._tabId(tab);
          selector = '#' + panelId;
          panel = that.element.find(selector);
          if (!panel.length) {
            panel = that._createPanel(panelId);
            panel.insertAfter(that.panels[i - 1] || that.tablist);
          }
          panel.attr('aria-live', 'polite');
        }

        if (panel.length) {
          that.panels = that.panels.add(panel);
        }
        if (originalAriaControls) {
          tab.data('ui-tabs-aria-controls', originalAriaControls);
        }
        tab.attr({
          'aria-controls': selector.substring(1),
          'aria-labelledby': anchorId,
        });
        panel.attr('aria-labelledby', anchorId);
      });

      this.panels.addClass('ui-tabs-panel ui-widget-content ui-corner-bottom').attr('role', 'tabpanel');
    },

    // allow overriding how to find the list for rare usage scenarios (#7715)
    _getList: function() {
      return this.element.find('ol,ul').eq(0);
    },

    _createPanel: function(id) {
      return $('<div>')
        .attr('id', id)
        .addClass('ui-tabs-panel ui-widget-content ui-corner-bottom')
        .data('ui-tabs-destroy', true);
    },

    _setupDisabled: function(disabled) {
      if ($.isArray(disabled)) {
        if (!disabled.length) {
          disabled = false;
        } else if (disabled.length === this.anchors.length) {
          disabled = true;
        }
      }

      // disable tabs
      for (var i = 0, li; (li = this.tabs[i]); i++) {
        if (disabled === true || $.inArray(i, disabled) !== -1) {
          $(li)
            .addClass('ui-state-disabled')
            .attr('aria-disabled', 'true');
        } else {
          $(li)
            .removeClass('ui-state-disabled')
            .removeAttr('aria-disabled');
        }
      }

      this.options.disabled = disabled;
    },

    _setupEvents: function(event) {
      var events = {
        click: function(event) {
          event.preventDefault();
        },
      };
      if (event) {
        $.each(event.split(' '), function(index, eventName) {
          events[eventName] = '_eventHandler';
        });
      }

      this._off(this.anchors.add(this.tabs).add(this.panels));
      this._on(this.anchors, events);
      this._on(this.tabs, { keydown: '_tabKeydown' });
      this._on(this.panels, { keydown: '_panelKeydown' });

      this._focusable(this.tabs);
      this._hoverable(this.tabs);
    },

    _setupHeightStyle: function(heightStyle) {
      var maxHeight,
        parent = this.element.parent();

      if (heightStyle === 'fill') {
        maxHeight = parent.height();
        maxHeight -= this.element.outerHeight() - this.element.height();

        this.element.siblings(':visible').each(function() {
          var elem = $(this),
            position = elem.css('position');

          if (position === 'absolute' || position === 'fixed') {
            return;
          }
          maxHeight -= elem.outerHeight(true);
        });

        this.element
          .children()
          .not(this.panels)
          .each(function() {
            maxHeight -= $(this).outerHeight(true);
          });

        this.panels
          .each(function() {
            $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
          })
          .css('overflow', 'auto');
      } else if (heightStyle === 'auto') {
        maxHeight = 0;
        this.panels
          .each(function() {
            maxHeight = Math.max(
              maxHeight,
              $(this)
                .height('')
                .height()
            );
          })
          .height(maxHeight);
      }
    },

    _eventHandler: function(event) {
      var options = this.options,
        active = this.active,
        anchor = $(event.currentTarget),
        tab = anchor.closest('li'),
        clickedIsActive = tab[0] === active[0],
        collapsing = clickedIsActive && options.collapsible,
        toShow = collapsing ? $() : this._getPanelForTab(tab),
        toHide = !active.length ? $() : this._getPanelForTab(active),
        eventData = {
          oldTab: active,
          oldPanel: toHide,
          newTab: collapsing ? $() : tab,
          newPanel: toShow,
        };

      event.preventDefault();

      if (
        tab.hasClass('ui-state-disabled') ||
        // tab is already loading
        tab.hasClass('ui-tabs-loading') ||
        // can't switch durning an animation
        this.running ||
        // click on active header, but not collapsible
        (clickedIsActive && !options.collapsible) ||
        // allow canceling activation
        this._trigger('beforeActivate', event, eventData) === false
      ) {
        return;
      }

      options.active = collapsing ? false : this.tabs.index(tab);

      this.active = clickedIsActive ? $() : tab;
      if (this.xhr) {
        this.xhr.abort();
      }

      if (!toHide.length && !toShow.length) {
        $.error('jQuery UI Tabs: Mismatching fragment identifier.');
      }

      if (toShow.length) {
        this.load(this.tabs.index(tab), event);
      }
      this._toggle(event, eventData);
    },

    // handles show/hide for selecting tabs
    _toggle: function(event, eventData) {
      var that = this,
        toShow = eventData.newPanel,
        toHide = eventData.oldPanel;

      this.running = true;

      function complete() {
        that.running = false;
        that._trigger('activate', event, eventData);
      }

      function show() {
        eventData.newTab.closest('li').addClass('ui-tabs-active ui-state-active');

        if (toShow.length && that.options.show) {
          that._show(toShow, that.options.show, complete);
        } else {
          toShow.show();
          complete();
        }
      }

      // start out by hiding, then showing, then completing
      if (toHide.length && this.options.hide) {
        this._hide(toHide, this.options.hide, function() {
          eventData.oldTab.closest('li').removeClass('ui-tabs-active ui-state-active');
          show();
        });
      } else {
        eventData.oldTab.closest('li').removeClass('ui-tabs-active ui-state-active');
        toHide.hide();
        show();
      }

      toHide.attr({
        'aria-expanded': 'false',
        'aria-hidden': 'true',
      });
      eventData.oldTab.attr('aria-selected', 'false');
      // If we're switching tabs, remove the old tab from the tab order.
      // If we're opening from collapsed state, remove the previous tab from the tab order.
      // If we're collapsing, then keep the collapsing tab in the tab order.
      if (toShow.length && toHide.length) {
        eventData.oldTab.attr('tabIndex', -1);
      } else if (toShow.length) {
        this.tabs
          .filter(function() {
            return $(this).attr('tabIndex') === 0;
          })
          .attr('tabIndex', -1);
      }

      toShow.attr({
        'aria-expanded': 'true',
        'aria-hidden': 'false',
      });
      eventData.newTab.attr({
        'aria-selected': 'true',
        tabIndex: 0,
      });
    },

    _activate: function(index) {
      var anchor,
        active = this._findActive(index);

      // trying to activate the already active panel
      if (active[0] === this.active[0]) {
        return;
      }

      // trying to collapse, simulate a click on the current active header
      if (!active.length) {
        active = this.active;
      }

      anchor = active.find('.ui-tabs-anchor')[0];
      this._eventHandler({
        target: anchor,
        currentTarget: anchor,
        preventDefault: $.noop,
      });
    },

    _findActive: function(index) {
      return index === false ? $() : this.tabs.eq(index);
    },

    _getIndex: function(index) {
      // meta-function to give users option to provide a href string instead of a numerical index.
      if (typeof index === 'string') {
        index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
      }

      return index;
    },

    _destroy: function() {
      if (this.xhr) {
        this.xhr.abort();
      }

      this.element.removeClass('ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible');

      this.tablist
        .removeClass('ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all')
        .removeAttr('role');

      this.anchors
        .removeClass('ui-tabs-anchor')
        .removeAttr('role')
        .removeAttr('tabIndex')
        .removeUniqueId();

      this.tabs.add(this.panels).each(function() {
        if ($.data(this, 'ui-tabs-destroy')) {
          $(this).remove();
        } else {
          $(this)
            .removeClass(
              'ui-state-default ui-state-active ui-state-disabled ' +
                'ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel'
            )
            .removeAttr('tabIndex')
            .removeAttr('aria-live')
            .removeAttr('aria-busy')
            .removeAttr('aria-selected')
            .removeAttr('aria-labelledby')
            .removeAttr('aria-hidden')
            .removeAttr('aria-expanded')
            .removeAttr('role');
        }
      });

      this.tabs.each(function() {
        var li = $(this),
          prev = li.data('ui-tabs-aria-controls');
        if (prev) {
          li.attr('aria-controls', prev).removeData('ui-tabs-aria-controls');
        } else {
          li.removeAttr('aria-controls');
        }
      });

      this.panels.show();

      if (this.options.heightStyle !== 'content') {
        this.panels.css('height', '');
      }
    },

    enable: function(index) {
      var disabled = this.options.disabled;
      if (disabled === false) {
        return;
      }

      if (index === undefined) {
        disabled = false;
      } else {
        index = this._getIndex(index);
        if ($.isArray(disabled)) {
          disabled = $.map(disabled, function(num) {
            return num !== index ? num : null;
          });
        } else {
          disabled = $.map(this.tabs, function(li, num) {
            return num !== index ? num : null;
          });
        }
      }
      this._setupDisabled(disabled);
    },

    disable: function(index) {
      var disabled = this.options.disabled;
      if (disabled === true) {
        return;
      }

      if (index === undefined) {
        disabled = true;
      } else {
        index = this._getIndex(index);
        if ($.inArray(index, disabled) !== -1) {
          return;
        }
        if ($.isArray(disabled)) {
          disabled = $.merge([index], disabled).sort();
        } else {
          disabled = [index];
        }
      }
      this._setupDisabled(disabled);
    },

    load: function(index, event) {
      index = this._getIndex(index);
      var that = this,
        tab = this.tabs.eq(index),
        anchor = tab.find('.ui-tabs-anchor'),
        panel = this._getPanelForTab(tab),
        eventData = {
          tab: tab,
          panel: panel,
        };

      // not remote
      if (isLocal(anchor[0])) {
        return;
      }

      this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));

      // support: jQuery <1.8
      // jQuery <1.8 returns false if the request is canceled in beforeSend,
      // but as of 1.8, $.ajax() always returns a jqXHR object.
      if (this.xhr && this.xhr.statusText !== 'canceled') {
        tab.addClass('ui-tabs-loading');
        panel.attr('aria-busy', 'true');

        this.xhr
          .success(function(response) {
            // support: jQuery <1.8
            // http://bugs.jquery.com/ticket/11778
            setTimeout(function() {
              panel.html(response);
              that._trigger('load', event, eventData);
            }, 1);
          })
          .complete(function(jqXHR, status) {
            // support: jQuery <1.8
            // http://bugs.jquery.com/ticket/11778
            setTimeout(function() {
              if (status === 'abort') {
                that.panels.stop(false, true);
              }

              tab.removeClass('ui-tabs-loading');
              panel.removeAttr('aria-busy');

              if (jqXHR === that.xhr) {
                delete that.xhr;
              }
            }, 1);
          });
      }
    },

    _ajaxSettings: function(anchor, event, eventData) {
      var that = this;
      return {
        url: anchor.attr('href'),
        beforeSend: function(jqXHR, settings) {
          return that._trigger('beforeLoad', event, $.extend({ jqXHR: jqXHR, ajaxSettings: settings }, eventData));
        },
      };
    },

    _getPanelForTab: function(tab) {
      var id = $(tab).attr('aria-controls');
      return this.element.find(this._sanitizeSelector('#' + id));
    },
  });
})(jQuery);

(function($) {
  var increments = 0;

  function addDescribedBy(elem, id) {
    var describedby = (elem.attr('aria-describedby') || '').split(/\s+/);
    describedby.push(id);
    elem.data('ui-tooltip-id', id).attr('aria-describedby', $.trim(describedby.join(' ')));
  }

  function removeDescribedBy(elem) {
    var id = elem.data('ui-tooltip-id'),
      describedby = (elem.attr('aria-describedby') || '').split(/\s+/),
      index = $.inArray(id, describedby);
    if (index !== -1) {
      describedby.splice(index, 1);
    }

    elem.removeData('ui-tooltip-id');
    describedby = $.trim(describedby.join(' '));
    if (describedby) {
      elem.attr('aria-describedby', describedby);
    } else {
      elem.removeAttr('aria-describedby');
    }
  }

  $.widget('ui.tooltip', {
    version: '1.10.3',
    options: {
      content: function() {
        // support: IE<9, Opera in jQuery <1.7
        // .text() can't accept undefined, so coerce to a string
        var title = $(this).attr('title') || '';
        // Escape title, since we're going from an attribute to raw HTML
        return $('<a>')
          .text(title)
          .html();
      },
      hide: true,
      // Disabled elements have inconsistent behavior across browsers (#8661)
      items: '[title]:not([disabled])',
      position: {
        my: 'left top+15',
        at: 'left bottom',
        collision: 'flipfit flip',
      },
      show: true,
      tooltipClass: null,
      track: false,

      // callbacks
      close: null,
      open: null,
    },

    _create: function() {
      this._on({
        mouseover: 'open',
        focusin: 'open',
      });

      // IDs of generated tooltips, needed for destroy
      this.tooltips = {};
      // IDs of parent tooltips where we removed the title attribute
      this.parents = {};

      if (this.options.disabled) {
        this._disable();
      }
    },

    _setOption: function(key, value) {
      var that = this;

      if (key === 'disabled') {
        this[value ? '_disable' : '_enable']();
        this.options[key] = value;
        // disable element style changes
        return;
      }

      this._super(key, value);

      if (key === 'content') {
        $.each(this.tooltips, function(id, element) {
          that._updateContent(element);
        });
      }
    },

    _disable: function() {
      var that = this;

      // close open tooltips
      $.each(this.tooltips, function(id, element) {
        var event = $.Event('blur');
        event.target = event.currentTarget = element[0];
        that.close(event, true);
      });

      // remove title attributes to prevent native tooltips
      this.element
        .find(this.options.items)
        .addBack()
        .each(function() {
          var element = $(this);
          if (element.is('[title]')) {
            element.data('ui-tooltip-title', element.attr('title')).attr('title', '');
          }
        });
    },

    _enable: function() {
      // restore title attributes
      this.element
        .find(this.options.items)
        .addBack()
        .each(function() {
          var element = $(this);
          if (element.data('ui-tooltip-title')) {
            element.attr('title', element.data('ui-tooltip-title'));
          }
        });
    },

    open: function(event) {
      var that = this,
        target = $(event ? event.target : this.element)
          // we need closest here due to mouseover bubbling,
          // but always pointing at the same event target
          .closest(this.options.items);

      // No element to show a tooltip for or the tooltip is already open
      if (!target.length || target.data('ui-tooltip-id')) {
        return;
      }

      if (target.attr('title')) {
        target.data('ui-tooltip-title', target.attr('title'));
      }

      target.data('ui-tooltip-open', true);

      // kill parent tooltips, custom or native, for hover
      if (event && event.type === 'mouseover') {
        target.parents().each(function() {
          var parent = $(this),
            blurEvent;
          if (parent.data('ui-tooltip-open')) {
            blurEvent = $.Event('blur');
            blurEvent.target = blurEvent.currentTarget = this;
            that.close(blurEvent, true);
          }
          if (parent.attr('title')) {
            parent.uniqueId();
            that.parents[this.id] = {
              element: this,
              title: parent.attr('title'),
            };
            parent.attr('title', '');
          }
        });
      }

      this._updateContent(target, event);
    },

    _updateContent: function(target, event) {
      var content,
        contentOption = this.options.content,
        that = this,
        eventType = event ? event.type : null;

      if (typeof contentOption === 'string') {
        return this._open(event, target, contentOption);
      }

      content = contentOption.call(target[0], function(response) {
        // ignore async response if tooltip was closed already
        if (!target.data('ui-tooltip-open')) {
          return;
        }
        // IE may instantly serve a cached response for ajax requests
        // delay this call to _open so the other call to _open runs first
        that._delay(function() {
          // jQuery creates a special event for focusin when it doesn't
          // exist natively. To improve performance, the native event
          // object is reused and the type is changed. Therefore, we can't
          // rely on the type being correct after the event finished
          // bubbling, so we set it back to the previous value. (#8740)
          if (event) {
            event.type = eventType;
          }
          this._open(event, target, response);
        });
      });
      if (content) {
        this._open(event, target, content);
      }
    },

    _open: function(event, target, content) {
      var tooltip,
        events,
        delayedShow,
        positionOption = $.extend({}, this.options.position);

      if (!content) {
        return;
      }

      // Content can be updated multiple times. If the tooltip already
      // exists, then just update the content and bail.
      tooltip = this._find(target);
      if (tooltip.length) {
        tooltip.find('.ui-tooltip-content').html(content);
        return;
      }

      // if we have a title, clear it to prevent the native tooltip
      // we have to check first to avoid defining a title if none exists
      // (we don't want to cause an element to start matching [title])
      //
      // We use removeAttr only for key events, to allow IE to export the correct
      // accessible attributes. For mouse events, set to empty string to avoid
      // native tooltip showing up (happens only when removing inside mouseover).
      if (target.is('[title]')) {
        if (event && event.type === 'mouseover') {
          target.attr('title', '');
        } else {
          target.removeAttr('title');
        }
      }

      tooltip = this._tooltip(target);
      addDescribedBy(target, tooltip.attr('id'));
      tooltip.find('.ui-tooltip-content').html(content);

      function position(event) {
        positionOption.of = event;
        if (tooltip.is(':hidden')) {
          return;
        }
        tooltip.position(positionOption);
      }
      if (this.options.track && event && /^mouse/.test(event.type)) {
        this._on(this.document, {
          mousemove: position,
        });
        // trigger once to override element-relative positioning
        position(event);
      } else {
        tooltip.position(
          $.extend(
            {
              of: target,
            },
            this.options.position
          )
        );
      }

      tooltip.hide();

      this._show(tooltip, this.options.show);
      // Handle tracking tooltips that are shown with a delay (#8644). As soon
      // as the tooltip is visible, position the tooltip using the most recent
      // event.
      if (this.options.show && this.options.show.delay) {
        delayedShow = this.delayedShow = setInterval(function() {
          if (tooltip.is(':visible')) {
            position(positionOption.of);
            clearInterval(delayedShow);
          }
        }, $.fx.interval);
      }

      this._trigger('open', event, { tooltip: tooltip });

      events = {
        keyup: function(event) {
          if (event.keyCode === $.ui.keyCode.ESCAPE) {
            var fakeEvent = $.Event(event);
            fakeEvent.currentTarget = target[0];
            this.close(fakeEvent, true);
          }
        },
        remove: function() {
          this._removeTooltip(tooltip);
        },
      };
      if (!event || event.type === 'mouseover') {
        events.mouseleave = 'close';
      }
      if (!event || event.type === 'focusin') {
        events.focusout = 'close';
      }
      this._on(true, target, events);
    },

    close: function(event) {
      var that = this,
        target = $(event ? event.currentTarget : this.element),
        tooltip = this._find(target);

      // disabling closes the tooltip, so we need to track when we're closing
      // to avoid an infinite loop in case the tooltip becomes disabled on close
      if (this.closing) {
        return;
      }

      // Clear the interval for delayed tracking tooltips
      clearInterval(this.delayedShow);

      // only set title if we had one before (see comment in _open())
      if (target.data('ui-tooltip-title')) {
        target.attr('title', target.data('ui-tooltip-title'));
      }

      removeDescribedBy(target);

      tooltip.stop(true);
      this._hide(tooltip, this.options.hide, function() {
        that._removeTooltip($(this));
      });

      target.removeData('ui-tooltip-open');
      this._off(target, 'mouseleave focusout keyup');
      // Remove 'remove' binding only on delegated targets
      if (target[0] !== this.element[0]) {
        this._off(target, 'remove');
      }
      this._off(this.document, 'mousemove');

      if (event && event.type === 'mouseleave') {
        $.each(this.parents, function(id, parent) {
          $(parent.element).attr('title', parent.title);
          delete that.parents[id];
        });
      }

      this.closing = true;
      this._trigger('close', event, { tooltip: tooltip });
      this.closing = false;
    },

    _tooltip: function(element) {
      var id = 'ui-tooltip-' + increments++,
        tooltip = $('<div>')
          .attr({
            id: id,
            role: 'tooltip',
          })
          .addClass('ui-tooltip ui-widget ui-corner-all ui-widget-content ' + (this.options.tooltipClass || ''));
      $('<div>')
        .addClass('ui-tooltip-content')
        .appendTo(tooltip);
      tooltip.appendTo(this.document[0].body);
      this.tooltips[id] = element;
      return tooltip;
    },

    _find: function(target) {
      var id = target.data('ui-tooltip-id');
      return id ? $('#' + id) : $();
    },

    _removeTooltip: function(tooltip) {
      tooltip.remove();
      delete this.tooltips[tooltip.attr('id')];
    },

    _destroy: function() {
      var that = this;

      // close open tooltips
      $.each(this.tooltips, function(id, element) {
        // Delegate to close method to handle common cleanup
        var event = $.Event('blur');
        event.target = event.currentTarget = element[0];
        that.close(event, true);

        // Remove immediately; destroying an open tooltip doesn't use the
        // hide animation
        $('#' + id).remove();

        // Restore the title
        if (element.data('ui-tooltip-title')) {
          element.attr('title', element.data('ui-tooltip-title'));
          element.removeData('ui-tooltip-title');
        }
      });
    },
  });
})(jQuery);

/*! jQuery Validation Plugin - v1.15.0 - 2/24/2016
 * http://jqueryvalidation.org/
 * Copyright (c) 2016 Jörn Zaefferer; Licensed MIT */
!(function(a) {
  'function' == typeof define && define.amd
    ? define(['jquery'], a)
    : 'object' == typeof module && module.exports
    ? (module.exports = a(require('jquery')))
    : a(jQuery);
})(function(a) {
  a.extend(a.fn, {
    validate: function(b) {
      if (!this.length)
        return void (
          b &&
          b.debug &&
          window.console &&
          console.warn("Nothing selected, can't validate, returning nothing.")
        );
      var c = a.data(this[0], 'validator');
      return c
        ? c
        : (this.attr('novalidate', 'novalidate'),
          (c = new a.validator(b, this[0])),
          a.data(this[0], 'validator', c),
          c.settings.onsubmit &&
            (this.on('click.validate', ':submit', function(b) {
              c.settings.submitHandler && (c.submitButton = b.target),
                a(this).hasClass('cancel') && (c.cancelSubmit = !0),
                void 0 !== a(this).attr('formnovalidate') && (c.cancelSubmit = !0);
            }),
            this.on('submit.validate', function(b) {
              function d() {
                var d, e;
                return c.settings.submitHandler
                  ? (c.submitButton &&
                      (d = a("<input type='hidden'/>")
                        .attr('name', c.submitButton.name)
                        .val(a(c.submitButton).val())
                        .appendTo(c.currentForm)),
                    (e = c.settings.submitHandler.call(c, c.currentForm, b)),
                    c.submitButton && d.remove(),
                    void 0 !== e ? e : !1)
                  : !0;
              }
              return (
                c.settings.debug && b.preventDefault(),
                c.cancelSubmit
                  ? ((c.cancelSubmit = !1), d())
                  : c.form()
                  ? c.pendingRequest
                    ? ((c.formSubmitted = !0), !1)
                    : d()
                  : (c.focusInvalid(), !1)
              );
            })),
          c);
    },
    valid: function() {
      var b, c, d;
      return (
        a(this[0]).is('form')
          ? (b = this.validate().form())
          : ((d = []),
            (b = !0),
            (c = a(this[0].form).validate()),
            this.each(function() {
              (b = c.element(this) && b), b || (d = d.concat(c.errorList));
            }),
            (c.errorList = d)),
        b
      );
    },
    rules: function(b, c) {
      if (this.length) {
        var d,
          e,
          f,
          g,
          h,
          i,
          j = this[0];
        if (b)
          switch (((d = a.data(j.form, 'validator').settings), (e = d.rules), (f = a.validator.staticRules(j)), b)) {
            case 'add':
              a.extend(f, a.validator.normalizeRule(c)),
                delete f.messages,
                (e[j.name] = f),
                c.messages && (d.messages[j.name] = a.extend(d.messages[j.name], c.messages));
              break;
            case 'remove':
              return c
                ? ((i = {}),
                  a.each(c.split(/\s/), function(b, c) {
                    (i[c] = f[c]), delete f[c], 'required' === c && a(j).removeAttr('aria-required');
                  }),
                  i)
                : (delete e[j.name], f);
          }
        return (
          (g = a.validator.normalizeRules(
            a.extend(
              {},
              a.validator.classRules(j),
              a.validator.attributeRules(j),
              a.validator.dataRules(j),
              a.validator.staticRules(j)
            ),
            j
          )),
          g.required &&
            ((h = g.required),
            delete g.required,
            (g = a.extend({ required: h }, g)),
            a(j).attr('aria-required', 'true')),
          g.remote && ((h = g.remote), delete g.remote, (g = a.extend(g, { remote: h }))),
          g
        );
      }
    },
  }),
    a.extend(a.expr[':'], {
      blank: function(b) {
        return !a.trim('' + a(b).val());
      },
      filled: function(b) {
        var c = a(b).val();
        return null !== c && !!a.trim('' + c);
      },
      unchecked: function(b) {
        return !a(b).prop('checked');
      },
    }),
    (a.validator = function(b, c) {
      (this.settings = a.extend(!0, {}, a.validator.defaults, b)), (this.currentForm = c), this.init();
    }),
    (a.validator.format = function(b, c) {
      return 1 === arguments.length
        ? function() {
            var c = a.makeArray(arguments);
            return c.unshift(b), a.validator.format.apply(this, c);
          }
        : void 0 === c
        ? b
        : (arguments.length > 2 && c.constructor !== Array && (c = a.makeArray(arguments).slice(1)),
          c.constructor !== Array && (c = [c]),
          a.each(c, function(a, c) {
            b = b.replace(new RegExp('\\{' + a + '\\}', 'g'), function() {
              return c;
            });
          }),
          b);
    }),
    a.extend(a.validator, {
      defaults: {
        messages: {},
        groups: {},
        rules: {},
        errorClass: 'error',
        pendingClass: 'pending',
        validClass: 'valid',
        errorElement: 'label',
        focusCleanup: !1,
        focusInvalid: !0,
        errorContainer: a([]),
        errorLabelContainer: a([]),
        onsubmit: !0,
        ignore: ':hidden',
        ignoreTitle: !1,
        onfocusin: function(a) {
          (this.lastActive = a),
            this.settings.focusCleanup &&
              (this.settings.unhighlight &&
                this.settings.unhighlight.call(this, a, this.settings.errorClass, this.settings.validClass),
              this.hideThese(this.errorsFor(a)));
        },
        onfocusout: function(a) {
          this.checkable(a) || (!(a.name in this.submitted) && this.optional(a)) || this.element(a);
        },
        onkeyup: function(b, c) {
          var d = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225];
          (9 === c.which && '' === this.elementValue(b)) ||
            -1 !== a.inArray(c.keyCode, d) ||
            ((b.name in this.submitted || b.name in this.invalid) && this.element(b));
        },
        onclick: function(a) {
          a.name in this.submitted
            ? this.element(a)
            : a.parentNode.name in this.submitted && this.element(a.parentNode);
        },
        highlight: function(b, c, d) {
          'radio' === b.type
            ? this.findByName(b.name)
                .addClass(c)
                .removeClass(d)
            : a(b)
                .addClass(c)
                .removeClass(d);
        },
        unhighlight: function(b, c, d) {
          'radio' === b.type
            ? this.findByName(b.name)
                .removeClass(c)
                .addClass(d)
            : a(b)
                .removeClass(c)
                .addClass(d);
        },
      },
      setDefaults: function(b) {
        a.extend(a.validator.defaults, b);
      },
      messages: {
        required: 'This field is required.',
        remote: 'Please fix this field.',
        email: 'Please enter a valid email address.',
        url: 'Please enter a valid URL.',
        date: 'Please enter a valid date.',
        dateISO: 'Please enter a valid date ( ISO ).',
        number: 'Please enter a valid number.',
        digits: 'Please enter only digits.',
        equalTo: 'Please enter the same value again.',
        maxlength: a.validator.format('Please enter no more than {0} characters.'),
        minlength: a.validator.format('Please enter at least {0} characters.'),
        rangelength: a.validator.format('Please enter a value between {0} and {1} characters long.'),
        range: a.validator.format('Please enter a value between {0} and {1}.'),
        max: a.validator.format('Please enter a value less than or equal to {0}.'),
        min: a.validator.format('Please enter a value greater than or equal to {0}.'),
        step: a.validator.format('Please enter a multiple of {0}.'),
      },
      autoCreateRanges: !1,
      prototype: {
        init: function() {
          function b(b) {
            var c = a.data(this.form, 'validator'),
              d = 'on' + b.type.replace(/^validate/, ''),
              e = c.settings;
            e[d] && !a(this).is(e.ignore) && e[d].call(c, this, b);
          }
          (this.labelContainer = a(this.settings.errorLabelContainer)),
            (this.errorContext = (this.labelContainer.length && this.labelContainer) || a(this.currentForm)),
            (this.containers = a(this.settings.errorContainer).add(this.settings.errorLabelContainer)),
            (this.submitted = {}),
            (this.valueCache = {}),
            (this.pendingRequest = 0),
            (this.pending = {}),
            (this.invalid = {}),
            this.reset();
          var c,
            d = (this.groups = {});
          a.each(this.settings.groups, function(b, c) {
            'string' == typeof c && (c = c.split(/\s/)),
              a.each(c, function(a, c) {
                d[c] = b;
              });
          }),
            (c = this.settings.rules),
            a.each(c, function(b, d) {
              c[b] = a.validator.normalizeRule(d);
            }),
            a(this.currentForm)
              .on(
                'focusin.validate focusout.validate keyup.validate',
                ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable]",
                b
              )
              .on('click.validate', "select, option, [type='radio'], [type='checkbox']", b),
            this.settings.invalidHandler &&
              a(this.currentForm).on('invalid-form.validate', this.settings.invalidHandler),
            a(this.currentForm)
              .find('[required], [data-rule-required], .required')
              .attr('aria-required', 'true');
        },
        form: function() {
          return (
            this.checkForm(),
            a.extend(this.submitted, this.errorMap),
            (this.invalid = a.extend({}, this.errorMap)),
            this.valid() || a(this.currentForm).triggerHandler('invalid-form', [this]),
            this.showErrors(),
            this.valid()
          );
        },
        checkForm: function() {
          this.prepareForm();
          for (var a = 0, b = (this.currentElements = this.elements()); b[a]; a++) this.check(b[a]);
          return this.valid();
        },
        element: function(b) {
          var c,
            d,
            e = this.clean(b),
            f = this.validationTargetFor(e),
            g = this,
            h = !0;
          return (
            void 0 === f
              ? delete this.invalid[e.name]
              : (this.prepareElement(f),
                (this.currentElements = a(f)),
                (d = this.groups[f.name]),
                d &&
                  a.each(this.groups, function(a, b) {
                    b === d &&
                      a !== f.name &&
                      ((e = g.validationTargetFor(g.clean(g.findByName(a)))),
                      e && e.name in g.invalid && (g.currentElements.push(e), (h = h && g.check(e))));
                  }),
                (c = this.check(f) !== !1),
                (h = h && c),
                c ? (this.invalid[f.name] = !1) : (this.invalid[f.name] = !0),
                this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)),
                this.showErrors(),
                a(b).attr('aria-invalid', !c)),
            h
          );
        },
        showErrors: function(b) {
          if (b) {
            var c = this;
            a.extend(this.errorMap, b),
              (this.errorList = a.map(this.errorMap, function(a, b) {
                return { message: a, element: c.findByName(b)[0] };
              })),
              (this.successList = a.grep(this.successList, function(a) {
                return !(a.name in b);
              }));
          }
          this.settings.showErrors
            ? this.settings.showErrors.call(this, this.errorMap, this.errorList)
            : this.defaultShowErrors();
        },
        resetForm: function() {
          a.fn.resetForm && a(this.currentForm).resetForm(),
            (this.invalid = {}),
            (this.submitted = {}),
            this.prepareForm(),
            this.hideErrors();
          var b = this.elements()
            .removeData('previousValue')
            .removeAttr('aria-invalid');
          this.resetElements(b);
        },
        resetElements: function(a) {
          var b;
          if (this.settings.unhighlight)
            for (b = 0; a[b]; b++)
              this.settings.unhighlight.call(this, a[b], this.settings.errorClass, ''),
                this.findByName(a[b].name).removeClass(this.settings.validClass);
          else a.removeClass(this.settings.errorClass).removeClass(this.settings.validClass);
        },
        numberOfInvalids: function() {
          return this.objectLength(this.invalid);
        },
        objectLength: function(a) {
          var b,
            c = 0;
          for (b in a) a[b] && c++;
          return c;
        },
        hideErrors: function() {
          this.hideThese(this.toHide);
        },
        hideThese: function(a) {
          a.not(this.containers).text(''), this.addWrapper(a).hide();
        },
        valid: function() {
          return 0 === this.size();
        },
        size: function() {
          return this.errorList.length;
        },
        focusInvalid: function() {
          if (this.settings.focusInvalid)
            try {
              a(this.findLastActive() || (this.errorList.length && this.errorList[0].element) || [])
                .filter(':visible')
                .focus()
                .trigger('focusin');
            } catch (b) {}
        },
        findLastActive: function() {
          var b = this.lastActive;
          return (
            b &&
            1 ===
              a.grep(this.errorList, function(a) {
                return a.element.name === b.name;
              }).length &&
            b
          );
        },
        elements: function() {
          var b = this,
            c = {};
          return a(this.currentForm)
            .find('input, select, textarea, [contenteditable]')
            .not(':submit, :reset, :image, :disabled')
            .not(this.settings.ignore)
            .filter(function() {
              var d = this.name || a(this).attr('name');
              return (
                !d && b.settings.debug && window.console && console.error('%o has no name assigned', this),
                this.hasAttribute('contenteditable') && (this.form = a(this).closest('form')[0]),
                d in c || !b.objectLength(a(this).rules()) ? !1 : ((c[d] = !0), !0)
              );
            });
        },
        clean: function(b) {
          return a(b)[0];
        },
        errors: function() {
          var b = this.settings.errorClass.split(' ').join('.');
          return a(this.settings.errorElement + '.' + b, this.errorContext);
        },
        resetInternals: function() {
          (this.successList = []),
            (this.errorList = []),
            (this.errorMap = {}),
            (this.toShow = a([])),
            (this.toHide = a([]));
        },
        reset: function() {
          this.resetInternals(), (this.currentElements = a([]));
        },
        prepareForm: function() {
          this.reset(), (this.toHide = this.errors().add(this.containers));
        },
        prepareElement: function(a) {
          this.reset(), (this.toHide = this.errorsFor(a));
        },
        elementValue: function(b) {
          var c,
            d,
            e = a(b),
            f = b.type;
          return 'radio' === f || 'checkbox' === f
            ? this.findByName(b.name)
                .filter(':checked')
                .val()
            : 'number' === f && 'undefined' != typeof b.validity
            ? b.validity.badInput
              ? 'NaN'
              : e.val()
            : ((c = b.hasAttribute('contenteditable') ? e.text() : e.val()),
              'file' === f
                ? 'C:\\fakepath\\' === c.substr(0, 12)
                  ? c.substr(12)
                  : ((d = c.lastIndexOf('/')),
                    d >= 0 ? c.substr(d + 1) : ((d = c.lastIndexOf('\\')), d >= 0 ? c.substr(d + 1) : c))
                : 'string' == typeof c
                ? c.replace(/\r/g, '')
                : c);
        },
        check: function(b) {
          b = this.validationTargetFor(this.clean(b));
          var c,
            d,
            e,
            f = a(b).rules(),
            g = a.map(f, function(a, b) {
              return b;
            }).length,
            h = !1,
            i = this.elementValue(b);
          if ('function' == typeof f.normalizer) {
            if (((i = f.normalizer.call(b, i)), 'string' != typeof i))
              throw new TypeError('The normalizer should return a string value.');
            delete f.normalizer;
          }
          for (d in f) {
            e = { method: d, parameters: f[d] };
            try {
              if (
                ((c = a.validator.methods[d].call(this, i, b, e.parameters)), 'dependency-mismatch' === c && 1 === g)
              ) {
                h = !0;
                continue;
              }
              if (((h = !1), 'pending' === c)) return void (this.toHide = this.toHide.not(this.errorsFor(b)));
              if (!c) return this.formatAndAdd(b, e), !1;
            } catch (j) {
              throw (this.settings.debug &&
                window.console &&
                console.log(
                  'Exception occurred when checking element ' + b.id + ", check the '" + e.method + "' method.",
                  j
                ),
              j instanceof TypeError &&
                (j.message +=
                  '.  Exception occurred when checking element ' + b.id + ", check the '" + e.method + "' method."),
              j);
            }
          }
          if (!h) return this.objectLength(f) && this.successList.push(b), !0;
        },
        customDataMessage: function(b, c) {
          return a(b).data('msg' + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase()) || a(b).data('msg');
        },
        customMessage: function(a, b) {
          var c = this.settings.messages[a];
          return c && (c.constructor === String ? c : c[b]);
        },
        findDefined: function() {
          for (var a = 0; a < arguments.length; a++) if (void 0 !== arguments[a]) return arguments[a];
        },
        defaultMessage: function(b, c) {
          var d = this.findDefined(
              this.customMessage(b.name, c.method),
              this.customDataMessage(b, c.method),
              (!this.settings.ignoreTitle && b.title) || void 0,
              a.validator.messages[c.method],
              '<strong>Warning: No message defined for ' + b.name + '</strong>'
            ),
            e = /\$?\{(\d+)\}/g;
          return (
            'function' == typeof d
              ? (d = d.call(this, c.parameters, b))
              : e.test(d) && (d = a.validator.format(d.replace(e, '{$1}'), c.parameters)),
            d
          );
        },
        formatAndAdd: function(a, b) {
          var c = this.defaultMessage(a, b);
          this.errorList.push({ message: c, element: a, method: b.method }),
            (this.errorMap[a.name] = c),
            (this.submitted[a.name] = c);
        },
        addWrapper: function(a) {
          return this.settings.wrapper && (a = a.add(a.parent(this.settings.wrapper))), a;
        },
        defaultShowErrors: function() {
          var a, b, c;
          for (a = 0; this.errorList[a]; a++)
            (c = this.errorList[a]),
              this.settings.highlight &&
                this.settings.highlight.call(this, c.element, this.settings.errorClass, this.settings.validClass),
              this.showLabel(c.element, c.message);
          if ((this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success))
            for (a = 0; this.successList[a]; a++) this.showLabel(this.successList[a]);
          if (this.settings.unhighlight)
            for (a = 0, b = this.validElements(); b[a]; a++)
              this.settings.unhighlight.call(this, b[a], this.settings.errorClass, this.settings.validClass);
          (this.toHide = this.toHide.not(this.toShow)), this.hideErrors(), this.addWrapper(this.toShow).show();
        },
        validElements: function() {
          return this.currentElements.not(this.invalidElements());
        },
        invalidElements: function() {
          return a(this.errorList).map(function() {
            return this.element;
          });
        },
        showLabel: function(b, c) {
          var d,
            e,
            f,
            g,
            h = this.errorsFor(b),
            i = this.idOrName(b),
            j = a(b).attr('aria-describedby');
          h.length
            ? (h.removeClass(this.settings.validClass).addClass(this.settings.errorClass), h.html(c))
            : ((h = a('<' + this.settings.errorElement + '>')
                .attr('id', i + '-error')
                .addClass(this.settings.errorClass)
                .html(c || '')),
              (d = h),
              this.settings.wrapper &&
                (d = h
                  .hide()
                  .show()
                  .wrap('<' + this.settings.wrapper + '/>')
                  .parent()),
              this.labelContainer.length
                ? this.labelContainer.append(d)
                : this.settings.errorPlacement
                ? this.settings.errorPlacement(d, a(b))
                : d.insertAfter(b),
              h.is('label')
                ? h.attr('for', i)
                : 0 === h.parents("label[for='" + this.escapeCssMeta(i) + "']").length &&
                  ((f = h.attr('id')),
                  j ? j.match(new RegExp('\\b' + this.escapeCssMeta(f) + '\\b')) || (j += ' ' + f) : (j = f),
                  a(b).attr('aria-describedby', j),
                  (e = this.groups[b.name]),
                  e &&
                    ((g = this),
                    a.each(g.groups, function(b, c) {
                      c === e &&
                        a("[name='" + g.escapeCssMeta(b) + "']", g.currentForm).attr('aria-describedby', h.attr('id'));
                    })))),
            !c &&
              this.settings.success &&
              (h.text(''),
              'string' == typeof this.settings.success
                ? h.addClass(this.settings.success)
                : this.settings.success(h, b)),
            (this.toShow = this.toShow.add(h));
        },
        errorsFor: function(b) {
          var c = this.escapeCssMeta(this.idOrName(b)),
            d = a(b).attr('aria-describedby'),
            e = "label[for='" + c + "'], label[for='" + c + "'] *";
          return d && (e = e + ', #' + this.escapeCssMeta(d).replace(/\s+/g, ', #')), this.errors().filter(e);
        },
        escapeCssMeta: function(a) {
          return a.replace(/([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, '\\$1');
        },
        idOrName: function(a) {
          return this.groups[a.name] || (this.checkable(a) ? a.name : a.id || a.name);
        },
        validationTargetFor: function(b) {
          return this.checkable(b) && (b = this.findByName(b.name)), a(b).not(this.settings.ignore)[0];
        },
        checkable: function(a) {
          return /radio|checkbox/i.test(a.type);
        },
        findByName: function(b) {
          return a(this.currentForm).find("[name='" + this.escapeCssMeta(b) + "']");
        },
        getLength: function(b, c) {
          switch (c.nodeName.toLowerCase()) {
            case 'select':
              return a('option:selected', c).length;
            case 'input':
              if (this.checkable(c)) return this.findByName(c.name).filter(':checked').length;
          }
          return b.length;
        },
        depend: function(a, b) {
          return this.dependTypes[typeof a] ? this.dependTypes[typeof a](a, b) : !0;
        },
        dependTypes: {
          boolean: function(a) {
            return a;
          },
          string: function(b, c) {
            return !!a(b, c.form).length;
          },
          function: function(a, b) {
            return a(b);
          },
        },
        optional: function(b) {
          var c = this.elementValue(b);
          return !a.validator.methods.required.call(this, c, b) && 'dependency-mismatch';
        },
        startRequest: function(b) {
          this.pending[b.name] ||
            (this.pendingRequest++, a(b).addClass(this.settings.pendingClass), (this.pending[b.name] = !0));
        },
        stopRequest: function(b, c) {
          this.pendingRequest--,
            this.pendingRequest < 0 && (this.pendingRequest = 0),
            delete this.pending[b.name],
            a(b).removeClass(this.settings.pendingClass),
            c && 0 === this.pendingRequest && this.formSubmitted && this.form()
              ? (a(this.currentForm).submit(), (this.formSubmitted = !1))
              : !c &&
                0 === this.pendingRequest &&
                this.formSubmitted &&
                (a(this.currentForm).triggerHandler('invalid-form', [this]), (this.formSubmitted = !1));
        },
        previousValue: function(b, c) {
          return (
            a.data(b, 'previousValue') ||
            a.data(b, 'previousValue', { old: null, valid: !0, message: this.defaultMessage(b, { method: c }) })
          );
        },
        destroy: function() {
          this.resetForm(),
            a(this.currentForm)
              .off('.validate')
              .removeData('validator')
              .find('.validate-equalTo-blur')
              .off('.validate-equalTo')
              .removeClass('validate-equalTo-blur');
        },
      },
      classRuleSettings: {
        required: { required: !0 },
        email: { email: !0 },
        url: { url: !0 },
        date: { date: !0 },
        dateISO: { dateISO: !0 },
        number: { number: !0 },
        digits: { digits: !0 },
        creditcard: { creditcard: !0 },
      },
      addClassRules: function(b, c) {
        b.constructor === String ? (this.classRuleSettings[b] = c) : a.extend(this.classRuleSettings, b);
      },
      classRules: function(b) {
        var c = {},
          d = a(b).attr('class');
        return (
          d &&
            a.each(d.split(' '), function() {
              this in a.validator.classRuleSettings && a.extend(c, a.validator.classRuleSettings[this]);
            }),
          c
        );
      },
      normalizeAttributeRule: function(a, b, c, d) {
        /min|max|step/.test(c) &&
          (null === b || /number|range|text/.test(b)) &&
          ((d = Number(d)), isNaN(d) && (d = void 0)),
          d || 0 === d ? (a[c] = d) : b === c && 'range' !== b && (a[c] = !0);
      },
      attributeRules: function(b) {
        var c,
          d,
          e = {},
          f = a(b),
          g = b.getAttribute('type');
        for (c in a.validator.methods)
          'required' === c ? ((d = b.getAttribute(c)), '' === d && (d = !0), (d = !!d)) : (d = f.attr(c)),
            this.normalizeAttributeRule(e, g, c, d);
        return e.maxlength && /-1|2147483647|524288/.test(e.maxlength) && delete e.maxlength, e;
      },
      dataRules: function(b) {
        var c,
          d,
          e = {},
          f = a(b),
          g = b.getAttribute('type');
        for (c in a.validator.methods)
          (d = f.data('rule' + c.charAt(0).toUpperCase() + c.substring(1).toLowerCase())),
            this.normalizeAttributeRule(e, g, c, d);
        return e;
      },
      staticRules: function(b) {
        var c = {},
          d = a.data(b.form, 'validator');
        return d.settings.rules && (c = a.validator.normalizeRule(d.settings.rules[b.name]) || {}), c;
      },
      normalizeRules: function(b, c) {
        return (
          a.each(b, function(d, e) {
            if (e === !1) return void delete b[d];
            if (e.param || e.depends) {
              var f = !0;
              switch (typeof e.depends) {
                case 'string':
                  f = !!a(e.depends, c.form).length;
                  break;
                case 'function':
                  f = e.depends.call(c, c);
              }
              f
                ? (b[d] = void 0 !== e.param ? e.param : !0)
                : (a.data(c.form, 'validator').resetElements(a(c)), delete b[d]);
            }
          }),
          a.each(b, function(d, e) {
            b[d] = a.isFunction(e) && 'normalizer' !== d ? e(c) : e;
          }),
          a.each(['minlength', 'maxlength'], function() {
            b[this] && (b[this] = Number(b[this]));
          }),
          a.each(['rangelength', 'range'], function() {
            var c;
            b[this] &&
              (a.isArray(b[this])
                ? (b[this] = [Number(b[this][0]), Number(b[this][1])])
                : 'string' == typeof b[this] &&
                  ((c = b[this].replace(/[\[\]]/g, '').split(/[\s,]+/)), (b[this] = [Number(c[0]), Number(c[1])])));
          }),
          a.validator.autoCreateRanges &&
            (null != b.min && null != b.max && ((b.range = [b.min, b.max]), delete b.min, delete b.max),
            null != b.minlength &&
              null != b.maxlength &&
              ((b.rangelength = [b.minlength, b.maxlength]), delete b.minlength, delete b.maxlength)),
          b
        );
      },
      normalizeRule: function(b) {
        if ('string' == typeof b) {
          var c = {};
          a.each(b.split(/\s/), function() {
            c[this] = !0;
          }),
            (b = c);
        }
        return b;
      },
      addMethod: function(b, c, d) {
        (a.validator.methods[b] = c),
          (a.validator.messages[b] = void 0 !== d ? d : a.validator.messages[b]),
          c.length < 3 && a.validator.addClassRules(b, a.validator.normalizeRule(b));
      },
      methods: {
        required: function(b, c, d) {
          if (!this.depend(d, c)) return 'dependency-mismatch';
          if ('select' === c.nodeName.toLowerCase()) {
            var e = a(c).val();
            return e && e.length > 0;
          }
          return this.checkable(c) ? this.getLength(b, c) > 0 : b.length > 0;
        },
        email: function(a, b) {
          return (
            this.optional(b) ||
            /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(
              a
            )
          );
        },
        url: function(a, b) {
          return (
            this.optional(b) ||
            /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(
              a
            )
          );
        },
        date: function(a, b) {
          return this.optional(b) || !/Invalid|NaN/.test(new Date(a).toString());
        },
        dateISO: function(a, b) {
          return this.optional(b) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(a);
        },
        number: function(a, b) {
          return this.optional(b) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(a);
        },
        digits: function(a, b) {
          return this.optional(b) || /^\d+$/.test(a);
        },
        minlength: function(b, c, d) {
          var e = a.isArray(b) ? b.length : this.getLength(b, c);
          return this.optional(c) || e >= d;
        },
        maxlength: function(b, c, d) {
          var e = a.isArray(b) ? b.length : this.getLength(b, c);
          return this.optional(c) || d >= e;
        },
        rangelength: function(b, c, d) {
          var e = a.isArray(b) ? b.length : this.getLength(b, c);
          return this.optional(c) || (e >= d[0] && e <= d[1]);
        },
        min: function(a, b, c) {
          return this.optional(b) || a >= c;
        },
        max: function(a, b, c) {
          return this.optional(b) || c >= a;
        },
        range: function(a, b, c) {
          return this.optional(b) || (a >= c[0] && a <= c[1]);
        },
        step: function(b, c, d) {
          var e = a(c).attr('type'),
            f = 'Step attribute on input type ' + e + ' is not supported.',
            g = ['text', 'number', 'range'],
            h = new RegExp('\\b' + e + '\\b'),
            i = e && !h.test(g.join());
          if (i) throw new Error(f);
          return this.optional(c) || b % d === 0;
        },
        equalTo: function(b, c, d) {
          var e = a(d);
          return (
            this.settings.onfocusout &&
              e.not('.validate-equalTo-blur').length &&
              e.addClass('validate-equalTo-blur').on('blur.validate-equalTo', function() {
                a(c).valid();
              }),
            b === e.val()
          );
        },
        remote: function(b, c, d, e) {
          if (this.optional(c)) return 'dependency-mismatch';
          e = ('string' == typeof e && e) || 'remote';
          var f,
            g,
            h,
            i = this.previousValue(c, e);
          return (
            this.settings.messages[c.name] || (this.settings.messages[c.name] = {}),
            (i.originalMessage = i.originalMessage || this.settings.messages[c.name][e]),
            (this.settings.messages[c.name][e] = i.message),
            (d = ('string' == typeof d && { url: d }) || d),
            (h = a.param(a.extend({ data: b }, d.data))),
            i.old === h
              ? i.valid
              : ((i.old = h),
                (f = this),
                this.startRequest(c),
                (g = {}),
                (g[c.name] = b),
                a.ajax(
                  a.extend(
                    !0,
                    {
                      mode: 'abort',
                      port: 'validate' + c.name,
                      dataType: 'json',
                      data: g,
                      context: f.currentForm,
                      success: function(a) {
                        var d,
                          g,
                          h,
                          j = a === !0 || 'true' === a;
                        (f.settings.messages[c.name][e] = i.originalMessage),
                          j
                            ? ((h = f.formSubmitted),
                              f.resetInternals(),
                              (f.toHide = f.errorsFor(c)),
                              (f.formSubmitted = h),
                              f.successList.push(c),
                              (f.invalid[c.name] = !1),
                              f.showErrors())
                            : ((d = {}),
                              (g = a || f.defaultMessage(c, { method: e, parameters: b })),
                              (d[c.name] = i.message = g),
                              (f.invalid[c.name] = !0),
                              f.showErrors(d)),
                          (i.valid = j),
                          f.stopRequest(c, j);
                      },
                    },
                    d
                  )
                ),
                'pending')
          );
        },
      },
    });
  var b,
    c = {};
  a.ajaxPrefilter
    ? a.ajaxPrefilter(function(a, b, d) {
        var e = a.port;
        'abort' === a.mode && (c[e] && c[e].abort(), (c[e] = d));
      })
    : ((b = a.ajax),
      (a.ajax = function(d) {
        var e = ('mode' in d ? d : a.ajaxSettings).mode,
          f = ('port' in d ? d : a.ajaxSettings).port;
        return 'abort' === e
          ? (c[f] && c[f].abort(), (c[f] = b.apply(this, arguments)), c[f])
          : b.apply(this, arguments);
      }));
});

/*! jQuery Validation Plugin - v1.15.0 - 2/24/2016
 * http://jqueryvalidation.org/
 * Copyright (c) 2016 Jörn Zaefferer; Licensed MIT */
!(function(a) {
  'function' == typeof define && define.amd
    ? define(['jquery', './jquery.validate.min'], a)
    : 'object' == typeof module && module.exports
    ? (module.exports = a(require('jquery')))
    : a(jQuery);
})(function(a) {
  !(function() {
    function b(a) {
      return a
        .replace(/<.[^<>]*?>/g, ' ')
        .replace(/&nbsp;|&#160;/gi, ' ')
        .replace(/[.(),;:!?%#$'\"_+=\/\-“”’]*/g, '');
    }
    a.validator.addMethod(
      'maxWords',
      function(a, c, d) {
        return this.optional(c) || b(a).match(/\b\w+\b/g).length <= d;
      },
      a.validator.format('Please enter {0} words or less.')
    ),
      a.validator.addMethod(
        'minWords',
        function(a, c, d) {
          return this.optional(c) || b(a).match(/\b\w+\b/g).length >= d;
        },
        a.validator.format('Please enter at least {0} words.')
      ),
      a.validator.addMethod(
        'rangeWords',
        function(a, c, d) {
          var e = b(a),
            f = /\b\w+\b/g;
          return this.optional(c) || (e.match(f).length >= d[0] && e.match(f).length <= d[1]);
        },
        a.validator.format('Please enter between {0} and {1} words.')
      );
  })(),
    a.validator.addMethod(
      'accept',
      function(b, c, d) {
        var e,
          f,
          g,
          h = 'string' == typeof d ? d.replace(/\s/g, '') : 'image/*',
          i = this.optional(c);
        if (i) return i;
        if (
          'file' === a(c).attr('type') &&
          ((h = h
            .replace(/[\-\[\]\/\{\}\(\)\+\?\.\\\^\$\|]/g, '\\$&')
            .replace(/,/g, '|')
            .replace('/*', '/.*')),
          c.files && c.files.length)
        )
          for (g = new RegExp('.?(' + h + ')$', 'i'), e = 0; e < c.files.length; e++)
            if (((f = c.files[e]), !f.type.match(g))) return !1;
        return !0;
      },
      a.validator.format('Please enter a value with a valid mimetype.')
    ),
    a.validator.addMethod(
      'alphanumeric',
      function(a, b) {
        return this.optional(b) || /^\w+$/i.test(a);
      },
      'Letters, numbers, and underscores only please'
    ),
    a.validator.addMethod(
      'bankaccountNL',
      function(a, b) {
        if (this.optional(b)) return !0;
        if (!/^[0-9]{9}|([0-9]{2} ){3}[0-9]{3}$/.test(a)) return !1;
        var c,
          d,
          e,
          f = a.replace(/ /g, ''),
          g = 0,
          h = f.length;
        for (c = 0; h > c; c++) (d = h - c), (e = f.substring(c, c + 1)), (g += d * e);
        return g % 11 === 0;
      },
      'Please specify a valid bank account number'
    ),
    a.validator.addMethod(
      'bankorgiroaccountNL',
      function(b, c) {
        return (
          this.optional(c) ||
          a.validator.methods.bankaccountNL.call(this, b, c) ||
          a.validator.methods.giroaccountNL.call(this, b, c)
        );
      },
      'Please specify a valid bank or giro account number'
    ),
    a.validator.addMethod(
      'bic',
      function(a, b) {
        return (
          this.optional(b) || /^([A-Z]{6}[A-Z2-9][A-NP-Z1-9])(X{3}|[A-WY-Z0-9][A-Z0-9]{2})?$/.test(a.toUpperCase())
        );
      },
      'Please specify a valid BIC code'
    ),
    a.validator.addMethod(
      'cifES',
      function(a) {
        'use strict';
        var b,
          c,
          d,
          e,
          f,
          g,
          h = [];
        if (
          ((a = a.toUpperCase()), !a.match('((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)'))
        )
          return !1;
        for (d = 0; 9 > d; d++) h[d] = parseInt(a.charAt(d), 10);
        for (c = h[2] + h[4] + h[6], e = 1; 8 > e; e += 2)
          (f = (2 * h[e]).toString()),
            (g = f.charAt(1)),
            (c += parseInt(f.charAt(0), 10) + ('' === g ? 0 : parseInt(g, 10)));
        return /^[ABCDEFGHJNPQRSUVW]{1}/.test(a)
          ? ((c += ''),
            (b = 10 - parseInt(c.charAt(c.length - 1), 10)),
            (a += b),
            h[8].toString() === String.fromCharCode(64 + b) || h[8].toString() === a.charAt(a.length - 1))
          : !1;
      },
      'Please specify a valid CIF number.'
    ),
    a.validator.addMethod(
      'cpfBR',
      function(a) {
        if (((a = a.replace(/([~!@#$%^&*()_+=`{}\[\]\-|\\:;'<>,.\/? ])+/g, '')), 11 !== a.length)) return !1;
        var b,
          c,
          d,
          e,
          f = 0;
        if (
          ((b = parseInt(a.substring(9, 10), 10)),
          (c = parseInt(a.substring(10, 11), 10)),
          (d = function(a, b) {
            var c = (10 * a) % 11;
            return (10 !== c && 11 !== c) || (c = 0), c === b;
          }),
          '' === a ||
            '00000000000' === a ||
            '11111111111' === a ||
            '22222222222' === a ||
            '33333333333' === a ||
            '44444444444' === a ||
            '55555555555' === a ||
            '66666666666' === a ||
            '77777777777' === a ||
            '88888888888' === a ||
            '99999999999' === a)
        )
          return !1;
        for (e = 1; 9 >= e; e++) f += parseInt(a.substring(e - 1, e), 10) * (11 - e);
        if (d(f, b)) {
          for (f = 0, e = 1; 10 >= e; e++) f += parseInt(a.substring(e - 1, e), 10) * (12 - e);
          return d(f, c);
        }
        return !1;
      },
      'Please specify a valid CPF number'
    ),
    a.validator.addMethod(
      'creditcard',
      function(a, b) {
        if (this.optional(b)) return 'dependency-mismatch';
        if (/[^0-9 \-]+/.test(a)) return !1;
        var c,
          d,
          e = 0,
          f = 0,
          g = !1;
        if (((a = a.replace(/\D/g, '')), a.length < 13 || a.length > 19)) return !1;
        for (c = a.length - 1; c >= 0; c--)
          (d = a.charAt(c)), (f = parseInt(d, 10)), g && (f *= 2) > 9 && (f -= 9), (e += f), (g = !g);
        return e % 10 === 0;
      },
      'Please enter a valid credit card number.'
    ),
    a.validator.addMethod(
      'creditcardtypes',
      function(a, b, c) {
        if (/[^0-9\-]+/.test(a)) return !1;
        a = a.replace(/\D/g, '');
        var d = 0;
        return (
          c.mastercard && (d |= 1),
          c.visa && (d |= 2),
          c.amex && (d |= 4),
          c.dinersclub && (d |= 8),
          c.enroute && (d |= 16),
          c.discover && (d |= 32),
          c.jcb && (d |= 64),
          c.unknown && (d |= 128),
          c.all && (d = 255),
          1 & d && /^(5[12345])/.test(a)
            ? 16 === a.length
            : 2 & d && /^(4)/.test(a)
            ? 16 === a.length
            : 4 & d && /^(3[47])/.test(a)
            ? 15 === a.length
            : 8 & d && /^(3(0[012345]|[68]))/.test(a)
            ? 14 === a.length
            : 16 & d && /^(2(014|149))/.test(a)
            ? 15 === a.length
            : 32 & d && /^(6011)/.test(a)
            ? 16 === a.length
            : 64 & d && /^(3)/.test(a)
            ? 16 === a.length
            : 64 & d && /^(2131|1800)/.test(a)
            ? 15 === a.length
            : !!(128 & d)
        );
      },
      'Please enter a valid credit card number.'
    ),
    a.validator.addMethod(
      'currency',
      function(a, b, c) {
        var d,
          e = 'string' == typeof c,
          f = e ? c : c[0],
          g = e ? !0 : c[1];
        return (
          (f = f.replace(/,/g, '')),
          (f = g ? f + ']' : f + ']?'),
          (d =
            '^[' +
            f +
            '([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$'),
          (d = new RegExp(d)),
          this.optional(b) || d.test(a)
        );
      },
      'Please specify a valid currency'
    ),
    a.validator.addMethod(
      'dateFA',
      function(a, b) {
        return (
          this.optional(b) ||
          /^[1-4]\d{3}\/((0?[1-6]\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\/(30|([1-2][0-9])|(0?[1-9]))))$/.test(
            a
          )
        );
      },
      a.validator.messages.date
    ),
    a.validator.addMethod(
      'dateITA',
      function(a, b) {
        var c,
          d,
          e,
          f,
          g,
          h = !1,
          i = /^\d{1,2}\/\d{1,2}\/\d{4}$/;
        return (
          i.test(a)
            ? ((c = a.split('/')),
              (d = parseInt(c[0], 10)),
              (e = parseInt(c[1], 10)),
              (f = parseInt(c[2], 10)),
              (g = new Date(Date.UTC(f, e - 1, d, 12, 0, 0, 0))),
              (h = g.getUTCFullYear() === f && g.getUTCMonth() === e - 1 && g.getUTCDate() === d))
            : (h = !1),
          this.optional(b) || h
        );
      },
      a.validator.messages.date
    ),
    a.validator.addMethod(
      'dateNL',
      function(a, b) {
        return this.optional(b) || /^(0?[1-9]|[12]\d|3[01])[\.\/\-](0?[1-9]|1[012])[\.\/\-]([12]\d)?(\d\d)$/.test(a);
      },
      a.validator.messages.date
    ),
    a.validator.addMethod(
      'extension',
      function(a, b, c) {
        return (
          (c = 'string' == typeof c ? c.replace(/,/g, '|') : 'png|jpe?g|gif'),
          this.optional(b) || a.match(new RegExp('\\.(' + c + ')$', 'i'))
        );
      },
      a.validator.format('Please enter a value with a valid extension.')
    ),
    a.validator.addMethod(
      'giroaccountNL',
      function(a, b) {
        return this.optional(b) || /^[0-9]{1,7}$/.test(a);
      },
      'Please specify a valid giro account number'
    ),
    a.validator.addMethod(
      'iban',
      function(a, b) {
        if (this.optional(b)) return !0;
        var c,
          d,
          e,
          f,
          g,
          h,
          i,
          j,
          k,
          l = a.replace(/ /g, '').toUpperCase(),
          m = '',
          n = !0,
          o = '',
          p = '';
        if (
          ((c = l.substring(0, 2)),
          (h = {
            AL: '\\d{8}[\\dA-Z]{16}',
            AD: '\\d{8}[\\dA-Z]{12}',
            AT: '\\d{16}',
            AZ: '[\\dA-Z]{4}\\d{20}',
            BE: '\\d{12}',
            BH: '[A-Z]{4}[\\dA-Z]{14}',
            BA: '\\d{16}',
            BR: '\\d{23}[A-Z][\\dA-Z]',
            BG: '[A-Z]{4}\\d{6}[\\dA-Z]{8}',
            CR: '\\d{17}',
            HR: '\\d{17}',
            CY: '\\d{8}[\\dA-Z]{16}',
            CZ: '\\d{20}',
            DK: '\\d{14}',
            DO: '[A-Z]{4}\\d{20}',
            EE: '\\d{16}',
            FO: '\\d{14}',
            FI: '\\d{14}',
            FR: '\\d{10}[\\dA-Z]{11}\\d{2}',
            GE: '[\\dA-Z]{2}\\d{16}',
            DE: '\\d{18}',
            GI: '[A-Z]{4}[\\dA-Z]{15}',
            GR: '\\d{7}[\\dA-Z]{16}',
            GL: '\\d{14}',
            GT: '[\\dA-Z]{4}[\\dA-Z]{20}',
            HU: '\\d{24}',
            IS: '\\d{22}',
            IE: '[\\dA-Z]{4}\\d{14}',
            IL: '\\d{19}',
            IT: '[A-Z]\\d{10}[\\dA-Z]{12}',
            KZ: '\\d{3}[\\dA-Z]{13}',
            KW: '[A-Z]{4}[\\dA-Z]{22}',
            LV: '[A-Z]{4}[\\dA-Z]{13}',
            LB: '\\d{4}[\\dA-Z]{20}',
            LI: '\\d{5}[\\dA-Z]{12}',
            LT: '\\d{16}',
            LU: '\\d{3}[\\dA-Z]{13}',
            MK: '\\d{3}[\\dA-Z]{10}\\d{2}',
            MT: '[A-Z]{4}\\d{5}[\\dA-Z]{18}',
            MR: '\\d{23}',
            MU: '[A-Z]{4}\\d{19}[A-Z]{3}',
            MC: '\\d{10}[\\dA-Z]{11}\\d{2}',
            MD: '[\\dA-Z]{2}\\d{18}',
            ME: '\\d{18}',
            NL: '[A-Z]{4}\\d{10}',
            NO: '\\d{11}',
            PK: '[\\dA-Z]{4}\\d{16}',
            PS: '[\\dA-Z]{4}\\d{21}',
            PL: '\\d{24}',
            PT: '\\d{21}',
            RO: '[A-Z]{4}[\\dA-Z]{16}',
            SM: '[A-Z]\\d{10}[\\dA-Z]{12}',
            SA: '\\d{2}[\\dA-Z]{18}',
            RS: '\\d{18}',
            SK: '\\d{20}',
            SI: '\\d{15}',
            ES: '\\d{20}',
            SE: '\\d{20}',
            CH: '\\d{5}[\\dA-Z]{12}',
            TN: '\\d{20}',
            TR: '\\d{5}[\\dA-Z]{17}',
            AE: '\\d{3}\\d{16}',
            GB: '[A-Z]{4}\\d{14}',
            VG: '[\\dA-Z]{4}\\d{16}',
          }),
          (g = h[c]),
          'undefined' != typeof g && ((i = new RegExp('^[A-Z]{2}\\d{2}' + g + '$', '')), !i.test(l)))
        )
          return !1;
        for (d = l.substring(4, l.length) + l.substring(0, 4), j = 0; j < d.length; j++)
          (e = d.charAt(j)), '0' !== e && (n = !1), n || (m += '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(e));
        for (k = 0; k < m.length; k++) (f = m.charAt(k)), (p = '' + o + f), (o = p % 97);
        return 1 === o;
      },
      'Please specify a valid IBAN'
    ),
    a.validator.addMethod(
      'integer',
      function(a, b) {
        return this.optional(b) || /^-?\d+$/.test(a);
      },
      'A positive or negative non-decimal number please'
    ),
    a.validator.addMethod(
      'ipv4',
      function(a, b) {
        return (
          this.optional(b) ||
          /^(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)$/i.test(
            a
          )
        );
      },
      'Please enter a valid IP v4 address.'
    ),
    a.validator.addMethod(
      'ipv6',
      function(a, b) {
        return (
          this.optional(b) ||
          /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test(
            a
          )
        );
      },
      'Please enter a valid IP v6 address.'
    ),
    a.validator.addMethod(
      'lettersonly',
      function(a, b) {
        return this.optional(b) || /^[a-z]+$/i.test(a);
      },
      'Letters only please'
    ),
    a.validator.addMethod(
      'letterswithbasicpunc',
      function(a, b) {
        return this.optional(b) || /^[a-z\-.,()'"\s]+$/i.test(a);
      },
      'Letters or punctuation only please'
    ),
    a.validator.addMethod(
      'mobileNL',
      function(a, b) {
        return (
          this.optional(b) ||
          /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)6((\s|\s?\-\s?)?[0-9]){8}$/.test(a)
        );
      },
      'Please specify a valid mobile number'
    ),
    a.validator.addMethod(
      'mobileUK',
      function(a, b) {
        return (
          (a = a.replace(/\(|\)|\s+|-/g, '')),
          this.optional(b) ||
            (a.length > 9 && a.match(/^(?:(?:(?:00\s?|\+)44\s?|0)7(?:[1345789]\d{2}|624)\s?\d{3}\s?\d{3})$/))
        );
      },
      'Please specify a valid mobile number'
    ),
    a.validator.addMethod(
      'nieES',
      function(a) {
        'use strict';
        return (
          (a = a.toUpperCase()),
          a.match('((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)')
            ? /^[T]{1}/.test(a)
              ? a[8] === /^[T]{1}[A-Z0-9]{8}$/.test(a)
              : /^[XYZ]{1}/.test(a)
              ? a[8] ===
                'TRWAGMYFPDXBNJZSQVHLCKE'.charAt(
                  a
                    .replace('X', '0')
                    .replace('Y', '1')
                    .replace('Z', '2')
                    .substring(0, 8) % 23
                )
              : !1
            : !1
        );
      },
      'Please specify a valid NIE number.'
    ),
    a.validator.addMethod(
      'nifES',
      function(a) {
        'use strict';
        return (
          (a = a.toUpperCase()),
          a.match('((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)')
            ? /^[0-9]{8}[A-Z]{1}$/.test(a)
              ? 'TRWAGMYFPDXBNJZSQVHLCKE'.charAt(a.substring(8, 0) % 23) === a.charAt(8)
              : /^[KLM]{1}/.test(a)
              ? a[8] === String.fromCharCode(64)
              : !1
            : !1
        );
      },
      'Please specify a valid NIF number.'
    ),
    jQuery.validator.addMethod(
      'notEqualTo',
      function(b, c, d) {
        return this.optional(c) || !a.validator.methods.equalTo.call(this, b, c, d);
      },
      'Please enter a different value, values must not be the same.'
    ),
    a.validator.addMethod(
      'nowhitespace',
      function(a, b) {
        return this.optional(b) || /^\S+$/i.test(a);
      },
      'No white space please'
    ),
    a.validator.addMethod(
      'pattern',
      function(a, b, c) {
        return this.optional(b) ? !0 : ('string' == typeof c && (c = new RegExp('^(?:' + c + ')$')), c.test(a));
      },
      'Invalid format.'
    ),
    a.validator.addMethod(
      'phoneNL',
      function(a, b) {
        return (
          this.optional(b) ||
          /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)[1-9]((\s|\s?\-\s?)?[0-9]){8}$/.test(a)
        );
      },
      'Please specify a valid phone number.'
    ),
    a.validator.addMethod(
      'phoneUK',
      function(a, b) {
        return (
          (a = a.replace(/\(|\)|\s+|-/g, '')),
          this.optional(b) ||
            (a.length > 9 &&
              a.match(
                /^(?:(?:(?:00\s?|\+)44\s?)|(?:\(?0))(?:\d{2}\)?\s?\d{4}\s?\d{4}|\d{3}\)?\s?\d{3}\s?\d{3,4}|\d{4}\)?\s?(?:\d{5}|\d{3}\s?\d{3})|\d{5}\)?\s?\d{4,5})$/
              ))
        );
      },
      'Please specify a valid phone number'
    ),
    a.validator.addMethod(
      'phoneUS',
      function(a, b) {
        return (
          (a = a.replace(/\s+/g, '')),
          this.optional(b) ||
            (a.length > 9 &&
              a.match(
                /^(\+?1-?)?(\([2-9]([02-9]\d|1[02-9])\)|[2-9]([02-9]\d|1[02-9]))-?[2-9]([02-9]\d|1[02-9])-?\d{4}$/
              ))
        );
      },
      'Please specify a valid phone number'
    ),
    a.validator.addMethod(
      'phonesUK',
      function(a, b) {
        return (
          (a = a.replace(/\(|\)|\s+|-/g, '')),
          this.optional(b) ||
            (a.length > 9 &&
              a.match(/^(?:(?:(?:00\s?|\+)44\s?|0)(?:1\d{8,9}|[23]\d{9}|7(?:[1345789]\d{8}|624\d{6})))$/))
        );
      },
      'Please specify a valid uk phone number'
    ),
    a.validator.addMethod(
      'postalCodeCA',
      function(a, b) {
        return (
          this.optional(b) || /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ] *\d[ABCEGHJKLMNPRSTVWXYZ]\d$/i.test(a)
        );
      },
      'Please specify a valid postal code'
    ),
    a.validator.addMethod(
      'postalcodeBR',
      function(a, b) {
        return this.optional(b) || /^\d{2}.\d{3}-\d{3}?$|^\d{5}-?\d{3}?$/.test(a);
      },
      'Informe um CEP válido.'
    ),
    a.validator.addMethod(
      'postalcodeIT',
      function(a, b) {
        return this.optional(b) || /^\d{5}$/.test(a);
      },
      'Please specify a valid postal code'
    ),
    a.validator.addMethod(
      'postalcodeNL',
      function(a, b) {
        return this.optional(b) || /^[1-9][0-9]{3}\s?[a-zA-Z]{2}$/.test(a);
      },
      'Please specify a valid postal code'
    ),
    a.validator.addMethod(
      'postcodeUK',
      function(a, b) {
        return (
          this.optional(b) ||
          /^((([A-PR-UWYZ][0-9])|([A-PR-UWYZ][0-9][0-9])|([A-PR-UWYZ][A-HK-Y][0-9])|([A-PR-UWYZ][A-HK-Y][0-9][0-9])|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\s?([0-9][ABD-HJLNP-UW-Z]{2})|(GIR)\s?(0AA))$/i.test(
            a
          )
        );
      },
      'Please specify a valid UK postcode'
    ),
    a.validator.addMethod(
      'require_from_group',
      function(b, c, d) {
        var e = a(d[1], c.form),
          f = e.eq(0),
          g = f.data('valid_req_grp') ? f.data('valid_req_grp') : a.extend({}, this),
          h =
            e.filter(function() {
              return g.elementValue(this);
            }).length >= d[0];
        return (
          f.data('valid_req_grp', g),
          a(c).data('being_validated') ||
            (e.data('being_validated', !0),
            e.each(function() {
              g.element(this);
            }),
            e.data('being_validated', !1)),
          h
        );
      },
      a.validator.format('Please fill at least {0} of these fields.')
    ),
    a.validator.addMethod(
      'skip_or_fill_minimum',
      function(b, c, d) {
        var e = a(d[1], c.form),
          f = e.eq(0),
          g = f.data('valid_skip') ? f.data('valid_skip') : a.extend({}, this),
          h = e.filter(function() {
            return g.elementValue(this);
          }).length,
          i = 0 === h || h >= d[0];
        return (
          f.data('valid_skip', g),
          a(c).data('being_validated') ||
            (e.data('being_validated', !0),
            e.each(function() {
              g.element(this);
            }),
            e.data('being_validated', !1)),
          i
        );
      },
      a.validator.format('Please either skip these fields or fill at least {0} of them.')
    ),
    a.validator.addMethod(
      'stateUS',
      function(a, b, c) {
        var d,
          e = 'undefined' == typeof c,
          f = e || 'undefined' == typeof c.caseSensitive ? !1 : c.caseSensitive,
          g = e || 'undefined' == typeof c.includeTerritories ? !1 : c.includeTerritories,
          h = e || 'undefined' == typeof c.includeMilitary ? !1 : c.includeMilitary;
        return (
          (d =
            g || h
              ? g && h
                ? '^(A[AEKLPRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$'
                : g
                ? '^(A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$'
                : '^(A[AEKLPRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$'
              : '^(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$'),
          (d = f ? new RegExp(d) : new RegExp(d, 'i')),
          this.optional(b) || d.test(a)
        );
      },
      'Please specify a valid state'
    ),
    a.validator.addMethod(
      'strippedminlength',
      function(b, c, d) {
        return a(b).text().length >= d;
      },
      a.validator.format('Please enter at least {0} characters')
    ),
    a.validator.addMethod(
      'time',
      function(a, b) {
        return this.optional(b) || /^([01]\d|2[0-3]|[0-9])(:[0-5]\d){1,2}$/.test(a);
      },
      'Please enter a valid time, between 00:00 and 23:59'
    ),
    a.validator.addMethod(
      'time12h',
      function(a, b) {
        return this.optional(b) || /^((0?[1-9]|1[012])(:[0-5]\d){1,2}(\ ?[AP]M))$/i.test(a);
      },
      'Please enter a valid time in 12-hour am/pm format'
    ),
    a.validator.addMethod(
      'url2',
      function(a, b) {
        return (
          this.optional(b) ||
          /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)*(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(
            a
          )
        );
      },
      a.validator.messages.url
    ),
    a.validator.addMethod(
      'vinUS',
      function(a) {
        if (17 !== a.length) return !1;
        var b,
          c,
          d,
          e,
          f,
          g,
          h = [
            'A',
            'B',
            'C',
            'D',
            'E',
            'F',
            'G',
            'H',
            'J',
            'K',
            'L',
            'M',
            'N',
            'P',
            'R',
            'S',
            'T',
            'U',
            'V',
            'W',
            'X',
            'Y',
            'Z',
          ],
          i = [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 7, 9, 2, 3, 4, 5, 6, 7, 8, 9],
          j = [8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2],
          k = 0;
        for (b = 0; 17 > b; b++) {
          if (((e = j[b]), (d = a.slice(b, b + 1)), 8 === b && (g = d), isNaN(d))) {
            for (c = 0; c < h.length; c++)
              if (d.toUpperCase() === h[c]) {
                (d = i[c]), (d *= e), isNaN(g) && 8 === c && (g = h[c]);
                break;
              }
          } else d *= e;
          k += d;
        }
        return (f = k % 11), 10 === f && (f = 'X'), f === g;
      },
      'The specified vehicle identification number (VIN) is invalid.'
    ),
    a.validator.addMethod(
      'zipcodeUS',
      function(a, b) {
        return this.optional(b) || /^\d{5}(-\d{4})?$/.test(a);
      },
      'The specified US ZIP Code is invalid'
    ),
    a.validator.addMethod(
      'ziprange',
      function(a, b) {
        return this.optional(b) || /^90[2-5]\d\{2\}-\d{4}$/.test(a);
      },
      'Your ZIP-code must be in the range 902xx-xxxx to 905xx-xxxx'
    );
});

/*
 * backgroundSize: A jQuery cssHook adding support for "cover" and "contain" to IE6,7,8
 *
 * Requirements:
 * - jQuery 1.7.0+
 *
 * Limitations:
 * - doesn't work with multiple backgrounds (use the :after trick)
 * - doesn't work with the "4 values syntax" of background-position
 * - doesn't work with lengths in background-position (only percentages and keywords)
 * - doesn't work with "background-repeat: repeat;"
 * - doesn't work with non-default values of background-clip/origin/attachment/scroll
 * - you should still test your website in IE!
 *
 * latest version and complete README available on Github:
 * https://github.com/louisremi/jquery.backgroundSize.js
 *
 * Copyright 2012 @louis_remi
 * Licensed under the MIT license.
 *
 * This saved you an hour of work?
 * Send me music http://www.amazon.co.uk/wishlist/HNTU0468LQON
 *
 */
(function($, window, document, Math, undefined) {
  var div = $('<div>')[0],
    rsrc = /url\(["']?(.*?)["']?\)/,
    watched = [],
    positions = {
      top: 0,
      left: 0,
      bottom: 1,
      right: 1,
      center: 0.5,
    };

  // feature detection
  if ('backgroundSize' in div.style && !$.debugBGS) {
    return;
  }

  $.cssHooks.backgroundSize = {
    set: function(elem, value) {
      var firstTime = !$.data(elem, 'bgsImg'),
        pos,
        $wrapper,
        $img;

      $.data(elem, 'bgsValue', value);

      if (firstTime) {
        // add this element to the 'watched' list so that it's updated on resize
        watched.push(elem);

        $.refreshBackgroundDimensions(elem, true);

        // create wrapper and img
        $wrapper = $('<div>').css({
          position: 'absolute',
          zIndex: -1,
          top: 0,
          right: 0,
          left: 0,
          bottom: 0,
          overflow: 'hidden',
        });

        ($img = $('<img>')
          .css({
            position: 'absolute',
          })
          .appendTo($wrapper)),
          $wrapper.prependTo(elem);

        $.data(elem, 'bgsImg', $img[0]);

        pos = // Firefox, Chrome (for debug)
        (
          $.css(elem, 'backgroundPosition') ||
          // IE8
          $.css(elem, 'backgroundPositionX') + ' ' + $.css(elem, 'backgroundPositionY')
        ).split(' ');

        // Only compatible with 1 or 2 percentage or keyword values,
        // Not yet compatible with length values and 4 values.
        $.data(elem, 'bgsPos', [
          positions[pos[0]] || parseFloat(pos[0]) / 100,
          positions[pos[1]] || parseFloat(pos[1]) / 100,
        ]);

        // This is the part where we mess with the existing DOM
        // to make sure that the background image is correctly zIndexed
        $.css(elem, 'zIndex') == 'auto' && (elem.style.zIndex = 0);
        $.css(elem, 'position') == 'static' && (elem.style.position = 'relative');

        $.refreshBackgroundImage(elem);
      } else {
        $.refreshBackground(elem);
      }
    },

    get: function(elem) {
      return $.data(elem, 'bgsValue') || '';
    },
  };

  // The background should refresh automatically when changing the background-image
  $.cssHooks.backgroundImage = {
    set: function(elem, value) {
      // if the element has a backgroundSize, refresh its background
      return $.data(elem, 'bgsImg')
        ? $.refreshBackgroundImage(elem, value)
        : // otherwise set the background-image normally
          value;
    },
  };

  $.refreshBackgroundDimensions = function(elem, noBgRefresh) {
    var $elem = $(elem),
      currDim = {
        width: $elem.innerWidth(),
        height: $elem.innerHeight(),
      },
      prevDim = $.data(elem, 'bgsDim'),
      changed = !prevDim || currDim.width != prevDim.width || currDim.height != prevDim.height;

    $.data(elem, 'bgsDim', currDim);

    if (changed && !noBgRefresh) {
      $.refreshBackground(elem);
    }
  };

  $.refreshBackgroundImage = function(elem, value) {
    var img = $.data(elem, 'bgsImg'),
      currSrc = (rsrc.exec(value || $.css(elem, 'backgroundImage')) || [])[1],
      prevSrc = img && img.src,
      changed = currSrc != prevSrc,
      imgWidth,
      imgHeight;

    if (changed) {
      img.style.height = img.style.width = 'auto';

      img.onload = function() {
        var dim = {
          width: img.width,
          height: img.height,
        };

        // ignore onload on the proxy image
        if (dim.width == 1 && dim.height == 1) {
          return;
        }

        $.data(elem, 'bgsImgDim', dim);
        $.data(elem, 'bgsConstrain', false);

        $.refreshBackground(elem);

        img.style.visibility = 'visible';

        img.onload = null;
      };

      img.style.visibility = 'hidden';
      img.src = currSrc;

      if (img.readyState || img.complete) {
        img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
        img.src = currSrc;
      }

      elem.style.backgroundImage = 'none';
    }
  };

  $.refreshBackground = function(elem) {
    var value = $.data(elem, 'bgsValue'),
      elemDim = $.data(elem, 'bgsDim'),
      imgDim = $.data(elem, 'bgsImgDim'),
      $img = $($.data(elem, 'bgsImg')),
      pos = $.data(elem, 'bgsPos'),
      prevConstrain = $.data(elem, 'bgsConstrain'),
      currConstrain,
      delta;
    var elemRatio = elemDim.width / elemDim.height;
    if (typeof imgDim == 'undefined') {
      var imgRatio = 1;
    } else {
      var imgRatio = imgDim.width / imgDim.height;
    }

    if (value == 'contain') {
      if (imgRatio > elemRatio) {
        $.data(elem, 'bgsConstrain', (currConstrain = 'width'));

        delta = Math.floor((elemDim.height - elemDim.width / imgRatio) * pos[1]);

        $img.css({
          top: delta,
        });

        // when switchin from height to with constraint,
        // make sure to release contraint on height and reset left
        if (currConstrain != prevConstrain) {
          $img.css({
            width: '100%',
            height: 'auto',
            left: 0,
          });
        }
      } else {
        $.data(elem, 'bgsConstrain', (currConstrain = 'height'));

        delta = Math.floor((elemDim.width - elemDim.height * imgRatio) * pos[0]);

        $img.css({
          left: delta,
        });

        if (currConstrain != prevConstrain) {
          $img.css({
            height: '100%',
            width: 'auto',
            top: 0,
          });
        }
      }
    } else if (value == 'cover') {
      if (imgRatio > elemRatio) {
        $.data(elem, 'bgsConstrain', (currConstrain = 'height'));

        delta = Math.floor((elemDim.height * imgRatio - elemDim.width) * pos[0]);

        $img.css({
          left: -delta,
        });

        if (currConstrain != prevConstrain) {
          $img.css({
            height: '100%',
            width: 'auto',
            top: 0,
          });
        }
      } else {
        $.data(elem, 'bgsConstrain', (currConstrain = 'width'));

        delta = Math.floor((elemDim.width / imgRatio - elemDim.height) * pos[1]);

        $img.css({
          top: -delta,
        });

        if (currConstrain != prevConstrain) {
          $img.css({
            width: '100%',
            height: 'auto',
            left: 0,
          });
        }
      }
    }
  };

  // Built-in throttledresize
  var $event = $.event,
    $special,
    dummy = { _: 0 },
    frame = 0,
    wasResized,
    animRunning;

  $special = $event.special.throttledresize = {
    setup: function() {
      $(this).on('resize', $special.handler);
    },
    teardown: function() {
      $(this).off('resize', $special.handler);
    },
    handler: function(event, execAsap) {
      // Save the context
      var context = this,
        args = arguments;

      wasResized = true;

      if (!animRunning) {
        $(dummy).animate(dummy, {
          duration: Infinity,
          step: function() {
            frame++;

            if ((frame > $special.threshold && wasResized) || execAsap) {
              // set correct event type
              event.type = 'throttledresize';
              $event.dispatch.apply(context, args);
              wasResized = false;
              frame = 0;
            }
            if (frame > 9) {
              $(dummy).stop();
              animRunning = false;
              frame = 0;
            }
          },
        });
        animRunning = true;
      }
    },
    threshold: 1,
  };

  // All backgrounds should refresh automatically when the window is resized
  $(window).on('throttledresize', function() {
    $(watched).each(function() {
      $.refreshBackgroundDimensions(this);
    });
  });
})(jQuery, window, document, Math);

/**
 * Copyright (c) 2007-2012 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 * @author Ariel Flesler
 * @version 1.4.3.1
 */
(function($) {
  var h = ($.scrollTo = function(a, b, c) {
    $(window).scrollTo(a, b, c);
  });
  h.defaults = { axis: 'xy', duration: parseFloat($.fn.jquery) >= 1.3 ? 0 : 1, limit: true };
  h.window = function(a) {
    return $(window)._scrollable();
  };
  $.fn._scrollable = function() {
    return this.map(function() {
      var a = this,
        isWin = !a.nodeName || $.inArray(a.nodeName.toLowerCase(), ['iframe', '#document', 'html', 'body']) != -1;
      if (!isWin) return a;
      var b = (a.contentWindow || a).document || a.ownerDocument || a;
      return /webkit/i.test(navigator.userAgent) || b.compatMode == 'BackCompat' ? b.body : b.documentElement;
    });
  };
  $.fn.scrollTo = function(e, f, g) {
    if (typeof f == 'object') {
      g = f;
      f = 0;
    }
    if (typeof g == 'function') g = { onAfter: g };
    if (e == 'max') e = 9e9;
    g = $.extend({}, h.defaults, g);
    f = f || g.duration;
    g.queue = g.queue && g.axis.length > 1;
    if (g.queue) f /= 2;
    g.offset = both(g.offset);
    g.over = both(g.over);
    return this._scrollable()
      .each(function() {
        if (e == null) return;
        var d = this,
          $elem = $(d),
          targ = e,
          toff,
          attr = {},
          win = $elem.is('html,body');
        switch (typeof targ) {
          case 'number':
          case 'string':
            if (/^([+-]=)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
              targ = both(targ);
              break;
            }
            targ = $(targ, this);
            if (!targ.length) return;
          case 'object':
            if (targ.is || targ.style) toff = (targ = $(targ)).offset();
        }
        $.each(g.axis.split(''), function(i, a) {
          var b = a == 'x' ? 'Left' : 'Top',
            pos = b.toLowerCase(),
            key = 'scroll' + b,
            old = d[key],
            max = h.max(d, a);
          if (toff) {
            attr[key] = toff[pos] + (win ? 0 : old - $elem.offset()[pos]);
            if (g.margin) {
              attr[key] -= parseInt(targ.css('margin' + b)) || 0;
              attr[key] -= parseInt(targ.css('border' + b + 'Width')) || 0;
            }
            attr[key] += g.offset[pos] || 0;
            if (g.over[pos]) attr[key] += targ[a == 'x' ? 'width' : 'height']() * g.over[pos];
          } else {
            var c = targ[pos];
            attr[key] = c.slice && c.slice(-1) == '%' ? (parseFloat(c) / 100) * max : c;
          }
          if (g.limit && /^\d+$/.test(attr[key])) attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
          if (!i && g.queue) {
            if (old != attr[key]) animate(g.onAfterFirst);
            delete attr[key];
          }
        });
        animate(g.onAfter);
        function animate(a) {
          $elem.animate(
            attr,
            f,
            g.easing,
            a &&
              function() {
                a.call(this, e, g);
              }
          );
        }
      })
      .end();
  };
  h.max = function(a, b) {
    var c = b == 'x' ? 'Width' : 'Height',
      scroll = 'scroll' + c;
    if (!$(a).is('html,body')) return a[scroll] - $(a)[c.toLowerCase()]();
    var d = 'client' + c,
      html = a.ownerDocument.documentElement,
      body = a.ownerDocument.body;
    return Math.max(html[scroll], body[scroll]) - Math.min(html[d], body[d]);
  };
  function both(a) {
    return typeof a == 'object' ? a : { top: a, left: a };
  }
})(jQuery);

/*
 * jQuery outside events - v1.1 - 3/16/2010
 * http://benalman.com/projects/jquery-outside-events-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function($, c, b) {
  $.map(
    'click dblclick mousemove mousedown mouseup mouseover mouseout change select submit keydown keypress keyup'.split(
      ' '
    ),
    function(d) {
      a(d);
    }
  );
  a('focusin', 'focus' + b);
  a('focusout', 'blur' + b);
  $.addOutsideEvent = a;
  function a(g, e) {
    e = e || g + b;
    var d = $(),
      h = g + '.' + e + '-special-event';
    $.event.special[e] = {
      setup: function() {
        d = d.add(this);
        if (d.length === 1) {
          $(c).bind(h, f);
        }
      },
      teardown: function() {
        d = d.not(this);
        if (d.length === 0) {
          $(c).unbind(h);
        }
      },
      add: function(i) {
        var j = i.handler;
        i.handler = function(l, k) {
          l.target = k;
          j.apply(this, arguments);
        };
      },
    };
    function f(i) {
      $(d).each(function() {
        var j = $(this);
        if (this !== i.target && !j.has(i.target).length) {
          j.triggerHandler(e, [i.target]);
        }
      });
    }
  }
})(jQuery, document, 'outside');

/*
 * TipTip
 * Copyright 2010 Drew Wilson
 * www.drewwilson.com
 * code.drewwilson.com/entry/tiptip-jquery-plugin
 *
 * Version 1.3   -   Updated: Mar. 23, 2010
 *
 * This Plug-In will create a custom tooltip to replace the default
 * browser tooltip. It is extremely lightweight and very smart in
 * that it detects the edges of the browser window and will make sure
 * the tooltip stays within the current window size. As a result the
 * tooltip will adjust itself to be displayed above, below, to the left
 * or to the right depending on what is necessary to stay within the
 * browser window. It is completely customizable as well via CSS.
 *
 * This TipTip jQuery plug-in is dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

(function($) {
  $.fn.tipTip = function(options) {
    var defaults = {
      activation: 'hover',
      keepAlive: false,
      maxWidth: '200px',
      edgeOffset: 3,
      defaultPosition: 'bottom',
      delay: 400,
      fadeIn: 200,
      fadeOut: 200,
      attribute: 'title',
      content: false, // HTML or String to fill TipTIp with
      enter: function() {},
      exit: function() {},
    };
    var opts = $.extend(defaults, options);

    // Setup tip tip elements and render them to the DOM
    if ($('#tiptip_holder').length <= 0) {
      var tiptip_holder = $('<div id="tiptip_holder" style="max-width:' + opts.maxWidth + ';"></div>');
      $('body').append(
        tiptip_holder.html(
          '<div id="tiptip_content" class="tiptip-content"><div id="tiptip_middle" class="tiptip-middle"></div></div>'
        )
      );
    } else {
      var tiptip_holder = $('#tiptip_holder');
    }
    var tiptip_content = $('#tiptip_content');

    return this.each(function() {
      var org_elem = $(this);
      if (opts.content) {
        var org_title = opts.content;
      } else {
        var org_title = org_elem.attr(opts.attribute);
      }
      if (org_title != '') {
        if (!opts.content) {
          org_elem.removeAttr(opts.attribute); //remove original Attribute
        }
        var timeout = false;

        if (opts.activation == 'hover') {
          org_elem.hover(
            function() {
              active_tiptip_responsive();
            },
            function() {
              if (!opts.keepAlive) {
                deactive_tiptip();
              }
            }
          );
          if (opts.keepAlive) {
            tiptip_holder.hover(
              function() {},
              function() {
                deactive_tiptip();
              }
            );
          }
        } else if (opts.activation == 'focus') {
          org_elem
            .focus(function() {
              active_tiptip_responsive();
            })
            .blur(function() {
              deactive_tiptip();
            });
        } else if (opts.activation == 'click') {
          org_elem
            .click(function() {
              active_tiptip_responsive();
              return false;
            })
            .hover(
              function() {},
              function() {
                if (!opts.keepAlive) {
                  deactive_tiptip();
                }
              }
            );
          if (opts.keepAlive) {
            tiptip_holder.hover(
              function() {},
              function() {
                deactive_tiptip();
              }
            );
          }
        }

        function active_tiptip_responsive() {
          active_tiptip();
          window.addEventListener('orientationchange', active_tiptip);
        }

        function active_tiptip() {
          opts.enter.call(this);
          tiptip_content.children('#tiptip_middle').html(org_title);
          tiptip_holder
            .hide()
            .removeAttr('class')
            .css('margin', '0');

          var top = parseInt(org_elem.offset()['top']);
          var left = parseInt(org_elem.offset()['left']);
          var org_width = parseInt(org_elem.outerWidth());
          var org_height = parseInt(org_elem.outerHeight());
          var tip_w = tiptip_holder.outerWidth();
          var tip_h = tiptip_holder.outerHeight();
          var w_compare = Math.round((org_width - tip_w) / 2);
          var h_compare = Math.round((org_height - tip_h) / 2);
          var marg_left = Math.round(left + w_compare);
          var marg_top = Math.round(top + org_height + opts.edgeOffset);
          var t_class = '';

          if (opts.defaultPosition == 'bottom') {
            t_class = '_bottom';
          } else if (opts.defaultPosition == 'top') {
            t_class = '_top';
          } else if (opts.defaultPosition == 'left') {
            t_class = '_left';
          } else if (opts.defaultPosition == 'right') {
            t_class = '_right';
          }

          var right_compare = w_compare + left < parseInt($(window).scrollLeft());
          var left_compare = tip_w + left > parseInt($(window).width());

          if (
            (right_compare && w_compare < 0) ||
            (t_class == '_right' && !left_compare) ||
            (t_class == '_left' && left < tip_w + opts.edgeOffset + 5)
          ) {
            t_class = '_right';
            marg_left = Math.round(left + org_width + opts.edgeOffset);
            marg_top = Math.round(top + h_compare);
          } else if ((left_compare && w_compare < 0) || (t_class == '_left' && !right_compare)) {
            t_class = '_left';
            marg_left = Math.round(left - (tip_w + opts.edgeOffset + 5));
            marg_top = Math.round(top + h_compare);
          }

          var top_compare =
            top + org_height + opts.edgeOffset + tip_h + 8 > parseInt($(window).height() + $(window).scrollTop());
          var bottom_compare = top + org_height - (opts.edgeOffset + tip_h + 8) < 0;

          if (top_compare || (t_class == '_bottom' && top_compare) || (t_class == '_top' && !bottom_compare)) {
            if (t_class == '_top' || t_class == '_bottom') {
              t_class = '_top';
            } else {
              t_class = t_class + '_top';
            }
            marg_top = Math.round(top - (tip_h + 5 + opts.edgeOffset));
          } else if (bottom_compare | (t_class == '_top' && bottom_compare) || (t_class == '_bottom' && !top_compare)) {
            if (t_class == '_top' || t_class == '_bottom') {
              t_class = '_bottom';
            } else {
              t_class = t_class + '_bottom';
            }
            marg_top = Math.round(top + org_height + opts.edgeOffset);
          }

          if (t_class == '_right_top' || t_class == '_left_top') {
            marg_top = marg_top + 5;
          } else if (t_class == '_right_bottom' || t_class == '_left_bottom') {
            marg_top = marg_top - 5;
          }
          if (t_class == '_left_top' || t_class == '_left_bottom') {
            marg_left = marg_left + 5;
          }
          tiptip_holder
            .css({ 'margin-left': marg_left + 'px', 'margin-top': marg_top + 'px' })
            .attr('class', 'tip' + t_class);

          if (timeout) {
            clearTimeout(timeout);
          }
          timeout = setTimeout(function() {
            tiptip_holder.stop(true, true).fadeIn(opts.fadeIn);
          }, opts.delay);
        }

        function deactive_tiptip() {
          opts.exit.call(this);
          if (timeout) {
            clearTimeout(timeout);
          }
          tiptip_holder.fadeOut(opts.fadeOut);
        }
      }
    });
  };
})(jQuery);

/* jquery.nicescroll 3.2.0 InuYaksa*2013 MIT http://areaaperta.com/nicescroll */ (function(e) {
  var y = !1,
    D = !1,
    J = 5e3,
    K = 2e3,
    x = 0,
    L = (function() {
      var e = document.getElementsByTagName('script'),
        e = e[e.length - 1].src.split('?')[0];
      return 0 < e.split('/').length
        ? e
            .split('/')
            .slice(0, -1)
            .join('/') + '/'
        : '';
    })();
  Array.prototype.forEach ||
    (Array.prototype.forEach = function(e, c) {
      for (var h = 0, l = this.length; h < l; ++h) e.call(c, this[h], h, this);
    });
  var v = window.requestAnimationFrame || !1,
    w = window.cancelAnimationFrame || !1;
  ['ms', 'moz', 'webkit', 'o'].forEach(function(e) {
    v || (v = window[e + 'RequestAnimationFrame']);
    w || (w = window[e + 'CancelAnimationFrame'] || window[e + 'CancelRequestAnimationFrame']);
  });
  var z = window.MutationObserver || window.WebKitMutationObserver || !1,
    F = {
      zindex: 'auto',
      cursoropacitymin: 0,
      cursoropacitymax: 1,
      cursorcolor: '#424242',
      cursorwidth: '5px',
      cursorborder: '1px solid #fff',
      cursorborderradius: '5px',
      scrollspeed: 60,
      mousescrollstep: 24,
      touchbehavior: !1,
      hwacceleration: !0,
      usetransition: !0,
      boxzoom: !1,
      dblclickzoom: !0,
      gesturezoom: !0,
      grabcursorenabled: !0,
      autohidemode: !0,
      background: '',
      iframeautoresize: !0,
      cursorminheight: 32,
      preservenativescrolling: !0,
      railoffset: !1,
      bouncescroll: !0,
      spacebarenabled: !0,
      railpadding: { top: 0, right: 0, left: 0, bottom: 0 },
      disableoutline: !0,
      horizrailenabled: !0,
      railalign: 'right',
      railvalign: 'bottom',
      enabletranslate3d: !0,
      enablemousewheel: !0,
      enablekeyboard: !0,
      smoothscroll: !0,
      sensitiverail: !0,
      enablemouselockapi: !0,
      cursorfixedheight: !1,
      directionlockdeadzone: 6,
      hidecursordelay: 400,
      nativeparentscrolling: !0,
      enablescrollonselection: !0,
      overflowx: !0,
      overflowy: !0,
      cursordragspeed: 0.3,
      rtlmode: !1,
      cursordragontouch: !1,
    },
    E = !1,
    M = function() {
      if (E) return E;
      var e = document.createElement('DIV'),
        c = {
          haspointerlock:
            'pointerLockElement' in document ||
            'mozPointerLockElement' in document ||
            'webkitPointerLockElement' in document,
        };
      c.isopera = 'opera' in window;
      c.isopera12 = c.isopera && 'getUserMedia' in navigator;
      c.isie = 'all' in document && 'attachEvent' in e && !c.isopera;
      c.isieold = c.isie && !('msInterpolationMode' in e.style);
      c.isie7 = c.isie && !c.isieold && (!('documentMode' in document) || 7 == document.documentMode);
      c.isie8 = c.isie && 'documentMode' in document && 8 == document.documentMode;
      c.isie9 = c.isie && 'performance' in window && 9 <= document.documentMode;
      c.isie10 = c.isie && 'performance' in window && 10 <= document.documentMode;
      c.isie9mobile = /iemobile.9/i.test(navigator.userAgent);
      c.isie9mobile && (c.isie9 = !1);
      c.isie7mobile = !c.isie9mobile && c.isie7 && /iemobile/i.test(navigator.userAgent);
      c.ismozilla = 'MozAppearance' in e.style;
      c.iswebkit = 'WebkitAppearance' in e.style;
      c.ischrome = 'chrome' in window;
      c.ischrome22 = c.ischrome && c.haspointerlock;
      c.ischrome26 = c.ischrome && 'transition' in e.style;
      c.cantouch = 'ontouchstart' in document.documentElement || 'ontouchstart' in window;
      c.hasmstouch = window.navigator.msPointerEnabled || !1;
      c.ismac = /^mac$/i.test(navigator.platform);
      c.isios = c.cantouch && /iphone|ipad|ipod/i.test(navigator.platform);
      c.isios4 = c.isios && !('seal' in Object);
      c.isandroid = /android/i.test(navigator.userAgent);
      c.trstyle = !1;
      c.hastransform = !1;
      c.hastranslate3d = !1;
      c.transitionstyle = !1;
      c.hastransition = !1;
      c.transitionend = !1;
      for (
        var h = ['transform', 'msTransform', 'webkitTransform', 'MozTransform', 'OTransform'], l = 0;
        l < h.length;
        l++
      )
        if ('undefined' != typeof e.style[h[l]]) {
          c.trstyle = h[l];
          break;
        }
      c.hastransform = !1 != c.trstyle;
      c.hastransform &&
        ((e.style[c.trstyle] = 'translate3d(1px,2px,3px)'),
        (c.hastranslate3d = /translate3d/.test(e.style[c.trstyle])));
      c.transitionstyle = !1;
      c.prefixstyle = '';
      c.transitionend = !1;
      for (
        var h = 'transition webkitTransition MozTransition OTransition OTransition msTransition KhtmlTransition'.split(
            ' '
          ),
          n = ' -webkit- -moz- -o- -o -ms- -khtml-'.split(' '),
          t = 'transitionend webkitTransitionEnd transitionend otransitionend oTransitionEnd msTransitionEnd KhtmlTransitionEnd'.split(
            ' '
          ),
          l = 0;
        l < h.length;
        l++
      )
        if (h[l] in e.style) {
          c.transitionstyle = h[l];
          c.prefixstyle = n[l];
          c.transitionend = t[l];
          break;
        }
      c.ischrome26 && (c.prefixstyle = n[1]);
      c.hastransition = c.transitionstyle;
      a: {
        h = ['-moz-grab', '-webkit-grab', 'grab'];
        if ((c.ischrome && !c.ischrome22) || c.isie) h = [];
        for (l = 0; l < h.length; l++)
          if (((n = h[l]), (e.style.cursor = n), e.style.cursor == n)) {
            h = n;
            break a;
          }
        h = 'url(http://www.google.com/intl/en_ALL/mapfiles/openhand.cur),n-resize';
      }
      c.cursorgrabvalue = h;
      c.hasmousecapture = 'setCapture' in e;
      c.hasMutationObserver = !1 !== z;
      return (E = c);
    },
    N = function(k, c) {
      function h() {
        var d = b.win;
        if ('zIndex' in d) return d.zIndex();
        for (; 0 < d.length && 9 != d[0].nodeType; ) {
          var c = d.css('zIndex');
          if (!isNaN(c) && 0 != c) return parseInt(c);
          d = d.parent();
        }
        return !1;
      }
      function l(d, c, g) {
        c = d.css(c);
        d = parseFloat(c);
        return isNaN(d)
          ? ((d = u[c] || 0),
            (g =
              3 == d ? (g ? b.win.outerHeight() - b.win.innerHeight() : b.win.outerWidth() - b.win.innerWidth()) : 1),
            b.isie8 && d && (d += 1),
            g ? d : 0)
          : d;
      }
      function n(d, c, g, e) {
        b._bind(
          d,
          c,
          function(b) {
            b = b ? b : window.event;
            var e = {
              original: b,
              target: b.target || b.srcElement,
              type: 'wheel',
              deltaMode: 'MozMousePixelScroll' == b.type ? 0 : 1,
              deltaX: 0,
              deltaZ: 0,
              preventDefault: function() {
                b.preventDefault ? b.preventDefault() : (b.returnValue = !1);
                return !1;
              },
              stopImmediatePropagation: function() {
                b.stopImmediatePropagation ? b.stopImmediatePropagation() : (b.cancelBubble = !0);
              },
            };
            'mousewheel' == c
              ? ((e.deltaY = -0.025 * b.wheelDelta), b.wheelDeltaX && (e.deltaX = -0.025 * b.wheelDeltaX))
              : (e.deltaY = b.detail);
            return g.call(d, e);
          },
          e
        );
      }
      function t(d, c, g) {
        var e, f;
        0 == d.deltaMode
          ? ((e = -Math.floor(d.deltaX * (b.opt.mousescrollstep / 54))),
            (f = -Math.floor(d.deltaY * (b.opt.mousescrollstep / 54))))
          : 1 == d.deltaMode &&
            ((e = -Math.floor(d.deltaX * b.opt.mousescrollstep)), (f = -Math.floor(d.deltaY * b.opt.mousescrollstep)));
        c && 0 == e && f && ((e = f), (f = 0));
        e &&
          (b.scrollmom && b.scrollmom.stop(),
          (b.lastdeltax += e),
          b.debounced(
            'mousewheelx',
            function() {
              var d = b.lastdeltax;
              b.lastdeltax = 0;
              b.rail.drag || b.doScrollLeftBy(d);
            },
            120
          ));
        if (f) {
          if (b.opt.nativeparentscrolling && g && !b.ispage && !b.zoomactive)
            if (0 > f) {
              if (b.getScrollTop() >= b.page.maxh) return !0;
            } else if (0 >= b.getScrollTop()) return !0;
          b.scrollmom && b.scrollmom.stop();
          b.lastdeltay += f;
          b.debounced(
            'mousewheely',
            function() {
              var d = b.lastdeltay;
              b.lastdeltay = 0;
              b.rail.drag || b.doScrollBy(d);
            },
            120
          );
        }
        d.stopImmediatePropagation();
        return d.preventDefault();
      }
      var b = this;
      this.version = '3.4.0';
      this.name = 'nicescroll';
      this.me = c;
      this.opt = { doc: e('body'), win: !1 };
      e.extend(this.opt, F);
      this.opt.snapbackspeed = 80;
      if (k) for (var q in b.opt) 'undefined' != typeof k[q] && (b.opt[q] = k[q]);
      this.iddoc = (this.doc = b.opt.doc) && this.doc[0] ? this.doc[0].id || '' : '';
      this.ispage = /BODY|HTML/.test(b.opt.win ? b.opt.win[0].nodeName : this.doc[0].nodeName);
      this.haswrapper = !1 !== b.opt.win;
      this.win = b.opt.win || (this.ispage ? e(window) : this.doc);
      this.docscroll = this.ispage && !this.haswrapper ? e(window) : this.win;
      this.body = e('body');
      this.iframe = this.isfixed = this.viewport = !1;
      this.isiframe = 'IFRAME' == this.doc[0].nodeName && 'IFRAME' == this.win[0].nodeName;
      this.istextarea = 'TEXTAREA' == this.win[0].nodeName;
      this.forcescreen = !1;
      this.canshowonmouseevent = 'scroll' != b.opt.autohidemode;
      this.page = this.view = this.onzoomout = this.onzoomin = this.onscrollcancel = this.onscrollend = this.onscrollstart = this.onclick = this.ongesturezoom = this.onkeypress = this.onmousewheel = this.onmousemove = this.onmouseup = this.onmousedown = !1;
      this.scroll = { x: 0, y: 0 };
      this.scrollratio = { x: 0, y: 0 };
      this.cursorheight = 20;
      this.scrollvaluemax = 0;
      this.observerremover = this.observer = this.scrollmom = this.scrollrunning = this.checkrtlmode = !1;
      do this.id = 'ascrail' + K++;
      while (document.getElementById(this.id));
      this.hasmousefocus = this.hasfocus = this.zoomactive = this.zoom = this.selectiondrag = this.cursorfreezed = this.cursor = this.rail = !1;
      this.visibility = !0;
      this.hidden = this.locked = !1;
      this.cursoractive = !0;
      this.overflowx = b.opt.overflowx;
      this.overflowy = b.opt.overflowy;
      this.nativescrollingarea = !1;
      this.checkarea = 0;
      this.events = [];
      this.saved = {};
      this.delaylist = {};
      this.synclist = {};
      this.lastdeltay = this.lastdeltax = 0;
      this.detected = M();
      var f = e.extend({}, this.detected);
      this.ishwscroll = (this.canhwscroll = f.hastransform && b.opt.hwacceleration) && b.haswrapper;
      this.istouchcapable = !1;
      f.cantouch && f.ischrome && !f.isios && !f.isandroid && ((this.istouchcapable = !0), (f.cantouch = !1));
      f.cantouch && f.ismozilla && !f.isios && ((this.istouchcapable = !0), (f.cantouch = !1));
      b.opt.enablemouselockapi || ((f.hasmousecapture = !1), (f.haspointerlock = !1));
      this.delayed = function(d, c, g, e) {
        var f = b.delaylist[d],
          h = new Date().getTime();
        if (!e && f && f.tt) return !1;
        f && f.tt && clearTimeout(f.tt);
        if (f && f.last + g > h && !f.tt)
          b.delaylist[d] = {
            last: h + g,
            tt: setTimeout(function() {
              b.delaylist[d].tt = 0;
              c.call();
            }, g),
          };
        else if (!f || !f.tt)
          (b.delaylist[d] = { last: h, tt: 0 }),
            setTimeout(function() {
              c.call();
            }, 0);
      };
      this.debounced = function(d, c, g) {
        var f = b.delaylist[d];
        new Date().getTime();
        b.delaylist[d] = c;
        f ||
          setTimeout(function() {
            var c = b.delaylist[d];
            b.delaylist[d] = !1;
            c.call();
          }, g);
      };
      this.synched = function(d, c) {
        b.synclist[d] = c;
        (function() {
          b.onsync ||
            (v(function() {
              b.onsync = !1;
              for (d in b.synclist) {
                var c = b.synclist[d];
                c && c.call(b);
                b.synclist[d] = !1;
              }
            }),
            (b.onsync = !0));
        })();
        return d;
      };
      this.unsynched = function(d) {
        b.synclist[d] && (b.synclist[d] = !1);
      };
      this.css = function(d, c) {
        for (var g in c) b.saved.css.push([d, g, d.css(g)]), d.css(g, c[g]);
      };
      this.scrollTop = function(d) {
        return 'undefined' == typeof d ? b.getScrollTop() : b.setScrollTop(d);
      };
      this.scrollLeft = function(d) {
        return 'undefined' == typeof d ? b.getScrollLeft() : b.setScrollLeft(d);
      };
      BezierClass = function(b, c, g, f, e, h, l) {
        this.st = b;
        this.ed = c;
        this.spd = g;
        this.p1 = f || 0;
        this.p2 = e || 1;
        this.p3 = h || 0;
        this.p4 = l || 1;
        this.ts = new Date().getTime();
        this.df = this.ed - this.st;
      };
      BezierClass.prototype = {
        B2: function(b) {
          return 3 * b * b * (1 - b);
        },
        B3: function(b) {
          return 3 * b * (1 - b) * (1 - b);
        },
        B4: function(b) {
          return (1 - b) * (1 - b) * (1 - b);
        },
        getNow: function() {
          var b = 1 - (new Date().getTime() - this.ts) / this.spd,
            c = this.B2(b) + this.B3(b) + this.B4(b);
          return 0 > b ? this.ed : this.st + Math.round(this.df * c);
        },
        update: function(b, c) {
          this.st = this.getNow();
          this.ed = b;
          this.spd = c;
          this.ts = new Date().getTime();
          this.df = this.ed - this.st;
          return this;
        },
      };
      if (this.ishwscroll) {
        this.doc.translate = { x: 0, y: 0, tx: '0px', ty: '0px' };
        f.hastranslate3d && f.isios && this.doc.css('-webkit-backface-visibility', 'hidden');
        var r = function() {
          var d = b.doc.css(f.trstyle);
          return d && 'matrix' == d.substr(0, 6)
            ? d
                .replace(/^.*\((.*)\)$/g, '$1')
                .replace(/px/g, '')
                .split(/, +/)
            : !1;
        };
        this.getScrollTop = function(d) {
          if (!d) {
            if ((d = r())) return 16 == d.length ? -d[13] : -d[5];
            if (b.timerscroll && b.timerscroll.bz) return b.timerscroll.bz.getNow();
          }
          return b.doc.translate.y;
        };
        this.getScrollLeft = function(d) {
          if (!d) {
            if ((d = r())) return 16 == d.length ? -d[12] : -d[4];
            if (b.timerscroll && b.timerscroll.bh) return b.timerscroll.bh.getNow();
          }
          return b.doc.translate.x;
        };
        this.notifyScrollEvent = document.createEvent
          ? function(b) {
              var c = document.createEvent('UIEvents');
              c.initUIEvent('scroll', !1, !0, window, 1);
              b.dispatchEvent(c);
            }
          : document.fireEvent
          ? function(b) {
              var c = document.createEventObject();
              b.fireEvent('onscroll');
              c.cancelBubble = !0;
            }
          : function(b, c) {};
        f.hastranslate3d && b.opt.enabletranslate3d
          ? ((this.setScrollTop = function(d, c) {
              b.doc.translate.y = d;
              b.doc.translate.ty = -1 * d + 'px';
              b.doc.css(f.trstyle, 'translate3d(' + b.doc.translate.tx + ',' + b.doc.translate.ty + ',0px)');
              c || b.notifyScrollEvent(b.win[0]);
            }),
            (this.setScrollLeft = function(d, c) {
              b.doc.translate.x = d;
              b.doc.translate.tx = -1 * d + 'px';
              b.doc.css(f.trstyle, 'translate3d(' + b.doc.translate.tx + ',' + b.doc.translate.ty + ',0px)');
              c || b.notifyScrollEvent(b.win[0]);
            }))
          : ((this.setScrollTop = function(d, c) {
              b.doc.translate.y = d;
              b.doc.translate.ty = -1 * d + 'px';
              b.doc.css(f.trstyle, 'translate(' + b.doc.translate.tx + ',' + b.doc.translate.ty + ')');
              c || b.notifyScrollEvent(b.win[0]);
            }),
            (this.setScrollLeft = function(d, c) {
              b.doc.translate.x = d;
              b.doc.translate.tx = -1 * d + 'px';
              b.doc.css(f.trstyle, 'translate(' + b.doc.translate.tx + ',' + b.doc.translate.ty + ')');
              c || b.notifyScrollEvent(b.win[0]);
            }));
      } else
        (this.getScrollTop = function() {
          return b.docscroll.scrollTop();
        }),
          (this.setScrollTop = function(d) {
            return b.docscroll.scrollTop(d);
          }),
          (this.getScrollLeft = function() {
            return b.docscroll.scrollLeft();
          }),
          (this.setScrollLeft = function(d) {
            return b.docscroll.scrollLeft(d);
          });
      this.getTarget = function(b) {
        return !b ? !1 : b.target ? b.target : b.srcElement ? b.srcElement : !1;
      };
      this.hasParent = function(b, c) {
        if (!b) return !1;
        for (var g = b.target || b.srcElement || b || !1; g && g.id != c; ) g = g.parentNode || !1;
        return !1 !== g;
      };
      var u = { thin: 1, medium: 3, thick: 5 };
      this.getOffset = function() {
        if (b.isfixed) return { top: parseFloat(b.win.css('top')), left: parseFloat(b.win.css('left')) };
        if (!b.viewport) return b.win.offset();
        var d = b.win.offset(),
          c = b.viewport.offset();
        return { top: d.top - c.top + b.viewport.scrollTop(), left: d.left - c.left + b.viewport.scrollLeft() };
      };
      this.updateScrollBar = function(d) {
        if (b.ishwscroll)
          b.rail.css({ height: b.win.innerHeight() }), b.railh && b.railh.css({ width: b.win.innerWidth() });
        else {
          var c = b.getOffset(),
            g = c.top,
            f = c.left,
            g = g + l(b.win, 'border-top-width', !0);
          b.win.outerWidth();
          b.win.innerWidth();
          var f =
              f +
              (b.rail.align
                ? b.win.outerWidth() - l(b.win, 'border-right-width') - b.rail.width
                : l(b.win, 'border-left-width')),
            e = b.opt.railoffset;
          e && (e.top && (g += e.top), b.rail.align && e.left && (f += e.left));
          b.locked || b.rail.css({ top: g, left: f, height: d ? d.h : b.win.innerHeight() });
          b.zoom && b.zoom.css({ top: g + 1, left: 1 == b.rail.align ? f - 20 : f + b.rail.width + 4 });
          b.railh &&
            !b.locked &&
            ((g = c.top),
            (f = c.left),
            (d = b.railh.align
              ? g + l(b.win, 'border-top-width', !0) + b.win.innerHeight() - b.railh.height
              : g + l(b.win, 'border-top-width', !0)),
            (f += l(b.win, 'border-left-width')),
            b.railh.css({ top: d, left: f, width: b.railh.width }));
        }
      };
      this.doRailClick = function(d, c, g) {
        var f;
        b.locked ||
          (b.cancelEvent(d),
          c
            ? ((c = g ? b.doScrollLeft : b.doScrollTop),
              (f = g
                ? (d.pageX - b.railh.offset().left - b.cursorwidth / 2) * b.scrollratio.x
                : (d.pageY - b.rail.offset().top - b.cursorheight / 2) * b.scrollratio.y),
              c(f))
            : ((c = g ? b.doScrollLeftBy : b.doScrollBy),
              (f = g ? b.scroll.x : b.scroll.y),
              (d = g ? d.pageX - b.railh.offset().left : d.pageY - b.rail.offset().top),
              (g = g ? b.view.w : b.view.h),
              f >= d ? c(g) : c(-g)));
      };
      b.hasanimationframe = v;
      b.hascancelanimationframe = w;
      b.hasanimationframe
        ? b.hascancelanimationframe ||
          (w = function() {
            b.cancelAnimationFrame = !0;
          })
        : ((v = function(b) {
            return setTimeout(b, 15 - (Math.floor(+new Date() / 1e3) % 16));
          }),
          (w = clearInterval));
      this.init = function() {
        b.saved.css = [];
        if (f.isie7mobile) return !0;
        f.hasmstouch && b.css(b.ispage ? e('html') : b.win, { '-ms-touch-action': 'none' });
        b.zindex = 'auto';
        b.zindex = !b.ispage && 'auto' == b.opt.zindex ? h() || 'auto' : b.opt.zindex;
        !b.ispage && 'auto' != b.zindex && b.zindex > x && (x = b.zindex);
        b.isie && 0 == b.zindex && 'auto' == b.opt.zindex && (b.zindex = 'auto');
        if (!b.ispage || (!f.cantouch && !f.isieold && !f.isie9mobile)) {
          var d = b.docscroll;
          b.ispage && (d = b.haswrapper ? b.win : b.doc);
          f.isie9mobile || b.css(d, { 'overflow-y': 'hidden' });
          b.ispage &&
            f.isie7 &&
            ('BODY' == b.doc[0].nodeName
              ? b.css(e('html'), { 'overflow-y': 'hidden' })
              : 'HTML' == b.doc[0].nodeName && b.css(e('body'), { 'overflow-y': 'hidden' }));
          f.isios && !b.ispage && !b.haswrapper && b.css(e('body'), { '-webkit-overflow-scrolling': 'touch' });
          var c = e(document.createElement('div'));
          c.css({
            position: 'relative',
            top: 0,
            float: 'right',
            width: b.opt.cursorwidth,
            height: '0px',
            'background-color': b.opt.cursorcolor,
            border: b.opt.cursorborder,
            'background-clip': 'padding-box',
            '-webkit-border-radius': b.opt.cursorborderradius,
            '-moz-border-radius': b.opt.cursorborderradius,
            'border-radius': b.opt.cursorborderradius,
          });
          c.hborder = parseFloat(c.outerHeight() - c.innerHeight());
          b.cursor = c;
          var g = e(document.createElement('div'));
          g.attr('id', b.id);
          g.addClass('nicescroll-rails');
          var l,
            k,
            n = ['left', 'right'],
            G;
          for (G in n)
            (k = n[G]), (l = b.opt.railpadding[k]) ? g.css('padding-' + k, l + 'px') : (b.opt.railpadding[k] = 0);
          g.append(c);
          g.width =
            Math.max(parseFloat(b.opt.cursorwidth), c.outerWidth()) + b.opt.railpadding.left + b.opt.railpadding.right;
          g.css({ width: g.width + 'px', zIndex: b.zindex, background: b.opt.background, cursor: 'default' });
          g.visibility = !0;
          g.scrollable = !0;
          g.align = 'left' == b.opt.railalign ? 0 : 1;
          b.rail = g;
          c = b.rail.drag = !1;
          b.opt.boxzoom &&
            !b.ispage && !f.isieold &&
            ((c = document.createElement('div')),
            b.bind(c, 'click', b.doZoom),
            (b.zoom = e(c)),
            b.zoom.css({
              cursor: 'pointer',
              'z-index': b.zindex,
              backgroundImage: 'url(' + L + 'zoomico.png)',
              height: 18,
              width: 18,
              backgroundPosition: '0px 0px',
            }),
            b.opt.dblclickzoom && b.bind(b.win, 'dblclick', b.doZoom),
            f.cantouch &&
              b.opt.gesturezoom &&
              ((b.ongesturezoom = function(d) {
                1.5 < d.scale && b.doZoomIn(d);
                0.8 > d.scale && b.doZoomOut(d);
                return b.cancelEvent(d);
              }),
              b.bind(b.win, 'gestureend', b.ongesturezoom)));
          b.railh = !1;
          if (b.opt.horizrailenabled) {
            b.css(d, { 'overflow-x': 'hidden' });
            c = e(document.createElement('div'));
            c.css({
              position: 'relative',
              top: 0,
              height: b.opt.cursorwidth,
              width: '0px',
              'background-color': b.opt.cursorcolor,
              border: b.opt.cursorborder,
              'background-clip': 'padding-box',
              '-webkit-border-radius': b.opt.cursorborderradius,
              '-moz-border-radius': b.opt.cursorborderradius,
              'border-radius': b.opt.cursorborderradius,
            });
            c.wborder = parseFloat(c.outerWidth() - c.innerWidth());
            b.cursorh = c;
            var m = e(document.createElement('div'));
            m.attr('id', b.id + '-hr');
            m.addClass('nicescroll-rails');
            m.height = Math.max(parseFloat(b.opt.cursorwidth), c.outerHeight());
            m.css({ height: m.height + 'px', zIndex: b.zindex, background: b.opt.background });
            m.append(c);
            m.visibility = !0;
            m.scrollable = !0;
            m.align = 'top' == b.opt.railvalign ? 0 : 1;
            b.railh = m;
            b.railh.drag = !1;
          }
          b.ispage
            ? (g.css({ position: 'fixed', top: '0px', height: '100%' }),
              g.align ? g.css({ right: '0px' }) : g.css({ left: '0px' }),
              b.body.append(g),
              b.railh &&
                (m.css({ position: 'fixed', left: '0px', width: '100%' }),
                m.align ? m.css({ bottom: '0px' }) : m.css({ top: '0px' }),
                b.body.append(m)))
            : (b.ishwscroll
                ? ('static' == b.win.css('position') && b.css(b.win, { position: 'relative' }),
                  (d = 'HTML' == b.win[0].nodeName ? b.body : b.win),
                  b.zoom &&
                    (b.zoom.css({ position: 'absolute', top: 1, right: 0, 'margin-right': g.width + 4 }),
                    d.append(b.zoom)),
                  g.css({ position: 'absolute', top: 0 }),
                  g.align ? g.css({ right: 0 }) : g.css({ left: 0 }),
                  d.append(g),
                  m &&
                    (m.css({ position: 'absolute', left: 0, bottom: 0 }),
                    m.align ? m.css({ bottom: 0 }) : m.css({ top: 0 }),
                    d.append(m)))
                : ((b.isfixed = 'fixed' == b.win.css('position')),
                  (d = b.isfixed ? 'fixed' : 'absolute'),
                  b.isfixed || (b.viewport = b.getViewport(b.win[0])),
                  b.viewport &&
                    ((b.body = b.viewport),
                    !1 == /relative|absolute/.test(b.viewport.css('position')) &&
                      b.css(b.viewport, { position: 'relative' })),
                  g.css({ position: d }),
                  b.zoom && b.zoom.css({ position: d }),
                  b.updateScrollBar(),
                  b.body.append(g),
                  b.zoom && b.body.append(b.zoom),
                  b.railh && (m.css({ position: d }), b.body.append(m))),
              f.isios &&
                b.css(b.win, { '-webkit-tap-highlight-color': 'rgba(0,0,0,0)', '-webkit-touch-callout': 'none' }),
              f.isie && b.opt.disableoutline && b.win.attr('hideFocus', 'true'),
              f.iswebkit && b.opt.disableoutline && b.win.css({ outline: 'none' }));
          !1 === b.opt.autohidemode
            ? ((b.autohidedom = !1),
              b.rail.css({ opacity: b.opt.cursoropacitymax }),
              b.railh && b.railh.css({ opacity: b.opt.cursoropacitymax }))
            : !0 === b.opt.autohidemode
            ? ((b.autohidedom = e().add(b.rail)),
              f.isie8 && (b.autohidedom = b.autohidedom.add(b.cursor)),
              b.railh && (b.autohidedom = b.autohidedom.add(b.railh)),
              b.railh && f.isie8 && (b.autohidedom = b.autohidedom.add(b.cursorh)))
            : 'scroll' == b.opt.autohidemode
            ? ((b.autohidedom = e().add(b.rail)), b.railh && (b.autohidedom = b.autohidedom.add(b.railh)))
            : 'cursor' == b.opt.autohidemode
            ? ((b.autohidedom = e().add(b.cursor)), b.railh && (b.autohidedom = b.autohidedom.add(b.cursorh)))
            : 'hidden' == b.opt.autohidemode && ((b.autohidedom = !1), b.hide(), (b.locked = !1));
          if (f.isie9mobile)
            (b.scrollmom = new H(b)),
              (b.onmangotouch = function(d) {
                d = b.getScrollTop();
                var c = b.getScrollLeft();
                if (d == b.scrollmom.lastscrolly && c == b.scrollmom.lastscrollx) return !0;
                var g = d - b.mangotouch.sy,
                  f = c - b.mangotouch.sx;
                if (0 != Math.round(Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2)))) {
                  var p = 0 > g ? -1 : 1,
                    e = 0 > f ? -1 : 1,
                    h = +new Date();
                  b.mangotouch.lazy && clearTimeout(b.mangotouch.lazy);
                  80 < h - b.mangotouch.tm || b.mangotouch.dry != p || b.mangotouch.drx != e
                    ? (b.scrollmom.stop(),
                      b.scrollmom.reset(c, d),
                      (b.mangotouch.sy = d),
                      (b.mangotouch.ly = d),
                      (b.mangotouch.sx = c),
                      (b.mangotouch.lx = c),
                      (b.mangotouch.dry = p),
                      (b.mangotouch.drx = e),
                      (b.mangotouch.tm = h))
                    : (b.scrollmom.stop(),
                      b.scrollmom.update(b.mangotouch.sx - f, b.mangotouch.sy - g),
                      (b.mangotouch.tm = h),
                      (g = Math.max(Math.abs(b.mangotouch.ly - d), Math.abs(b.mangotouch.lx - c))),
                      (b.mangotouch.ly = d),
                      (b.mangotouch.lx = c),
                      2 < g &&
                        (b.mangotouch.lazy = setTimeout(function() {
                          b.mangotouch.lazy = !1;
                          b.mangotouch.dry = 0;
                          b.mangotouch.drx = 0;
                          b.mangotouch.tm = 0;
                          b.scrollmom.doMomentum(30);
                        }, 100)));
                }
              }),
              (g = b.getScrollTop()),
              (m = b.getScrollLeft()),
              (b.mangotouch = { sy: g, ly: g, dry: 0, sx: m, lx: m, drx: 0, lazy: !1, tm: 0 }),
              b.bind(b.docscroll, 'scroll', b.onmangotouch);
          else {
            if (f.cantouch || b.istouchcapable || b.opt.touchbehavior || f.hasmstouch) {
              b.scrollmom = new H(b);
              b.ontouchstart = function(d) {
                if (d.pointerType && 2 != d.pointerType) return !1;
                if (!b.locked) {
                  if (f.hasmstouch)
                    for (var c = d.target ? d.target : !1; c; ) {
                      var g = e(c).getNiceScroll();
                      if (0 < g.length && g[0].me == b.me) break;
                      if (0 < g.length) return !1;
                      if ('DIV' == c.nodeName && c.id == b.id) break;
                      c = c.parentNode ? c.parentNode : !1;
                    }
                  b.cancelScroll();
                  if ((c = b.getTarget(d)) && /INPUT/i.test(c.nodeName) && /range/i.test(c.type))
                    return b.stopPropagation(d);
                  !('clientX' in d) &&
                    'changedTouches' in d &&
                    ((d.clientX = d.changedTouches[0].clientX), (d.clientY = d.changedTouches[0].clientY));
                  b.forcescreen &&
                    ((g = d),
                    (d = { original: d.original ? d.original : d }),
                    (d.clientX = g.screenX),
                    (d.clientY = g.screenY));
                  b.rail.drag = {
                    x: d.clientX,
                    y: d.clientY,
                    sx: b.scroll.x,
                    sy: b.scroll.y,
                    st: b.getScrollTop(),
                    sl: b.getScrollLeft(),
                    pt: 2,
                    dl: !1,
                  };
                  if (b.ispage || !b.opt.directionlockdeadzone) b.rail.drag.dl = 'f';
                  else {
                    var g = e(window).width(),
                      p = e(window).height(),
                      h = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
                      l = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight),
                      p = Math.max(0, l - p),
                      g = Math.max(0, h - g);
                    b.rail.drag.ck =
                      !b.rail.scrollable && b.railh.scrollable
                        ? 0 < p
                          ? 'v'
                          : !1
                        : b.rail.scrollable && !b.railh.scrollable
                        ? 0 < g
                          ? 'h'
                          : !1
                        : !1;
                    b.rail.drag.ck || (b.rail.drag.dl = 'f');
                  }
                  b.opt.touchbehavior &&
                    b.isiframe && f.isie &&
                    ((g = b.win.position()), (b.rail.drag.x += g.left), (b.rail.drag.y += g.top));
                  b.hasmoving = !1;
                  b.lastmouseup = !1;
                  b.scrollmom.reset(d.clientX, d.clientY);
                  if (!f.cantouch && !this.istouchcapable && !f.hasmstouch) {
                    if (!c || !/INPUT|SELECT|TEXTAREA/i.test(c.nodeName))
                      return !b.ispage && f.hasmousecapture && c.setCapture(), b.cancelEvent(d);
                    /SUBMIT|CANCEL|BUTTON/i.test(e(c).attr('type')) &&
                      ((pc = { tg: c, click: !1 }), (b.preventclick = pc));
                  }
                }
              };
              b.ontouchend = function(d) {
                if (d.pointerType && 2 != d.pointerType) return !1;
                if (
                  b.rail.drag &&
                  2 == b.rail.drag.pt &&
                  (b.scrollmom.doMomentum(),
                  (b.rail.drag = !1),
                  b.hasmoving &&
                    ((b.hasmoving = !1),
                    (b.lastmouseup = !0),
                    b.hideCursor(),
                    f.hasmousecapture && document.releaseCapture(),
                    !f.cantouch))
                )
                  return b.cancelEvent(d);
              };
              var q = b.opt.touchbehavior && b.isiframe && !f.hasmousecapture;
              b.ontouchmove = function(d, c) {
                if (d.pointerType && 2 != d.pointerType) return !1;
                if (b.rail.drag && 2 == b.rail.drag.pt) {
                  if (f.cantouch && 'undefined' == typeof d.original) return !0;
                  b.hasmoving = !0;
                  b.preventclick &&
                    !b.preventclick.click &&
                    ((b.preventclick.click = b.preventclick.tg.onclick || !1),
                    (b.preventclick.tg.onclick = b.onpreventclick));
                  d = e.extend({ original: d }, d);
                  'changedTouches' in d &&
                    ((d.clientX = d.changedTouches[0].clientX), (d.clientY = d.changedTouches[0].clientY));
                  if (b.forcescreen) {
                    var g = d;
                    d = { original: d.original ? d.original : d };
                    d.clientX = g.screenX;
                    d.clientY = g.screenY;
                  }
                  g = ofy = 0;
                  if (q && !c) {
                    var p = b.win.position(),
                      g = -p.left;
                    ofy = -p.top;
                  }
                  var h = d.clientY + ofy,
                    p = h - b.rail.drag.y,
                    l = d.clientX + g,
                    k = l - b.rail.drag.x,
                    s = b.rail.drag.st - p;
                  b.ishwscroll && b.opt.bouncescroll
                    ? 0 > s
                      ? (s = Math.round(s / 2))
                      : s > b.page.maxh && (s = b.page.maxh + Math.round((s - b.page.maxh) / 2))
                    : (0 > s && (h = s = 0), s > b.page.maxh && ((s = b.page.maxh), (h = 0)));
                  if (b.railh && b.railh.scrollable) {
                    var m = b.rail.drag.sl - k;
                    b.ishwscroll && b.opt.bouncescroll
                      ? 0 > m
                        ? (m = Math.round(m / 2))
                        : m > b.page.maxw && (m = b.page.maxw + Math.round((m - b.page.maxw) / 2))
                      : (0 > m && (l = m = 0), m > b.page.maxw && ((m = b.page.maxw), (l = 0)));
                  }
                  g = !1;
                  if (b.rail.drag.dl)
                    (g = !0),
                      'v' == b.rail.drag.dl ? (m = b.rail.drag.sl) : 'h' == b.rail.drag.dl && (s = b.rail.drag.st);
                  else {
                    var p = Math.abs(p),
                      k = Math.abs(k),
                      n = b.opt.directionlockdeadzone;
                    if ('v' == b.rail.drag.ck) {
                      if (p > n && k <= 0.3 * p) return (b.rail.drag = !1), !0;
                      k > n && ((b.rail.drag.dl = 'f'), e('body').scrollTop(e('body').scrollTop()));
                    } else if ('h' == b.rail.drag.ck) {
                      if (k > n && p <= 0.3 * az) return (b.rail.drag = !1), !0;
                      p > n && ((b.rail.drag.dl = 'f'), e('body').scrollLeft(e('body').scrollLeft()));
                    }
                  }
                  b.synched('touchmove', function() {
                    b.rail.drag &&
                      2 == b.rail.drag.pt &&
                      (b.prepareTransition && b.prepareTransition(0),
                      b.rail.scrollable && b.setScrollTop(s),
                      b.scrollmom.update(l, h),
                      b.railh && b.railh.scrollable ? (b.setScrollLeft(m), b.showCursor(s, m)) : b.showCursor(s),
                      f.isie10 && document.selection.clear());
                  });
                  f.ischrome && b.istouchcapable && (g = !1);
                  if (g) return b.cancelEvent(d);
                }
              };
            }
            b.onmousedown = function(d, c) {
              if (!(b.rail.drag && 1 != b.rail.drag.pt)) {
                if (b.locked) return b.cancelEvent(d);
                b.cancelScroll();
                b.rail.drag = { x: d.clientX, y: d.clientY, sx: b.scroll.x, sy: b.scroll.y, pt: 1, hr: !!c };
                var g = b.getTarget(d);
                !b.ispage && f.hasmousecapture && g.setCapture();
                b.isiframe &&
                  !f.hasmousecapture &&
                  ((b.saved.csspointerevents = b.doc.css('pointer-events')),
                  b.css(b.doc, { 'pointer-events': 'none' }));
                return b.cancelEvent(d);
              }
            };
            b.onmouseup = function(d) {
              if (
                b.rail.drag &&
                (f.hasmousecapture && document.releaseCapture(),
                b.isiframe && !f.hasmousecapture && b.doc.css('pointer-events', b.saved.csspointerevents),
                1 == b.rail.drag.pt)
              )
                return (b.rail.drag = !1), b.cancelEvent(d);
            };
            b.onmousemove = function(d) {
              if (b.rail.drag && 1 == b.rail.drag.pt) {
                if (f.ischrome && 0 == d.which) return b.onmouseup(d);
                b.cursorfreezed = !0;
                if (b.rail.drag.hr) {
                  b.scroll.x = b.rail.drag.sx + (d.clientX - b.rail.drag.x);
                  0 > b.scroll.x && (b.scroll.x = 0);
                  var c = b.scrollvaluemaxw;
                  b.scroll.x > c && (b.scroll.x = c);
                } else
                  (b.scroll.y = b.rail.drag.sy + (d.clientY - b.rail.drag.y)),
                    0 > b.scroll.y && (b.scroll.y = 0),
                    (c = b.scrollvaluemax),
                    b.scroll.y > c && (b.scroll.y = c);
                b.synched('mousemove', function() {
                  b.rail.drag &&
                    1 == b.rail.drag.pt &&
                    (b.showCursor(),
                    b.rail.drag.hr
                      ? b.doScrollLeft(Math.round(b.scroll.x * b.scrollratio.x), b.opt.cursordragspeed)
                      : b.doScrollTop(Math.round(b.scroll.y * b.scrollratio.y), b.opt.cursordragspeed));
                });
                return b.cancelEvent(d);
              }
            };
            if (f.cantouch || b.opt.touchbehavior)
              (b.onpreventclick = function(d) {
                if (b.preventclick)
                  return (b.preventclick.tg.onclick = b.preventclick.click), (b.preventclick = !1), b.cancelEvent(d);
              }),
                b.bind(b.win, 'mousedown', b.ontouchstart),
                (b.onclick = f.isios
                  ? !1
                  : function(d) {
                      return b.lastmouseup ? ((b.lastmouseup = !1), b.cancelEvent(d)) : !0;
                    }),
                b.opt.grabcursorenabled &&
                  f.cursorgrabvalue &&
                  (b.css(b.ispage ? b.doc : b.win, { cursor: f.cursorgrabvalue }),
                  b.css(b.rail, { cursor: f.cursorgrabvalue }));
            else {
              var r = function(d) {
                if (b.selectiondrag) {
                  if (d) {
                    var c = b.win.outerHeight();
                    d = d.pageY - b.selectiondrag.top;
                    0 < d && d < c && (d = 0);
                    d >= c && (d -= c);
                    b.selectiondrag.df = d;
                  }
                  0 != b.selectiondrag.df &&
                    (b.doScrollBy(2 * -Math.floor(b.selectiondrag.df / 6)),
                    b.debounced(
                      'doselectionscroll',
                      function() {
                        r();
                      },
                      50
                    ));
                }
              };
              b.hasTextSelected =
                'getSelection' in document
                  ? function() {
                      return 0 < document.getSelection().rangeCount;
                    }
                  : 'selection' in document
                  ? function() {
                      return 'None' != document.selection.type;
                    }
                  : function() {
                      return !1;
                    };
              b.onselectionstart = function(d) {
                b.ispage || (b.selectiondrag = b.win.offset());
              };
              b.onselectionend = function(d) {
                b.selectiondrag = !1;
              };
              b.onselectiondrag = function(d) {
                b.selectiondrag &&
                  b.hasTextSelected() &&
                  b.debounced(
                    'selectionscroll',
                    function() {
                      r(d);
                    },
                    250
                  );
              };
            }
            f.hasmstouch &&
              (b.css(b.rail, { '-ms-touch-action': 'none' }),
              b.css(b.cursor, { '-ms-touch-action': 'none' }),
              b.bind(b.win, 'MSPointerDown', b.ontouchstart),
              b.bind(document, 'MSPointerUp', b.ontouchend),
              b.bind(document, 'MSPointerMove', b.ontouchmove),
              b.bind(b.cursor, 'MSGestureHold', function(b) {
                b.preventDefault();
              }),
              b.bind(b.cursor, 'contextmenu', function(b) {
                b.preventDefault();
              }));
            this.istouchcapable &&
              (b.bind(b.win, 'touchstart', b.ontouchstart),
              b.bind(document, 'touchend', b.ontouchend),
              b.bind(document, 'touchcancel', b.ontouchend),
              b.bind(document, 'touchmove', b.ontouchmove));
            b.bind(b.cursor, 'mousedown', b.onmousedown);
            b.bind(b.cursor, 'mouseup', b.onmouseup);
            b.railh &&
              (b.bind(b.cursorh, 'mousedown', function(d) {
                b.onmousedown(d, !0);
              }),
              b.bind(b.cursorh, 'mouseup', function(d) {
                if (!(b.rail.drag && 2 == b.rail.drag.pt))
                  return (
                    (b.rail.drag = !1),
                    (b.hasmoving = !1),
                    b.hideCursor(),
                    f.hasmousecapture && document.releaseCapture(),
                    b.cancelEvent(d)
                  );
              }));
            if (b.opt.cursordragontouch || (!f.cantouch && !b.opt.touchbehavior))
              b.rail.css({ cursor: 'default' }),
                b.railh && b.railh.css({ cursor: 'default' }),
                b.jqbind(b.rail, 'mouseenter', function() {
                  b.canshowonmouseevent && b.showCursor();
                  b.rail.active = !0;
                }),
                b.jqbind(b.rail, 'mouseleave', function() {
                  b.rail.active = !1;
                  b.rail.drag || b.hideCursor();
                }),
                b.opt.sensitiverail &&
                  (b.bind(b.rail, 'click', function(d) {
                    b.doRailClick(d, !1, !1);
                  }),
                  b.bind(b.rail, 'dblclick', function(d) {
                    b.doRailClick(d, !0, !1);
                  }),
                  b.bind(b.cursor, 'click', function(d) {
                    b.cancelEvent(d);
                  }),
                  b.bind(b.cursor, 'dblclick', function(d) {
                    b.cancelEvent(d);
                  })),
                b.railh &&
                  (b.jqbind(b.railh, 'mouseenter', function() {
                    b.canshowonmouseevent && b.showCursor();
                    b.rail.active = !0;
                  }),
                  b.jqbind(b.railh, 'mouseleave', function() {
                    b.rail.active = !1;
                    b.rail.drag || b.hideCursor();
                  }),
                  b.opt.sensitiverail &&
                    (b.bind(b.railh, 'click', function(d) {
                      b.doRailClick(d, !1, !0);
                    }),
                    b.bind(b.railh, 'dblclick', function(d) {
                      b.doRailClick(d, !0, !0);
                    }),
                    b.bind(b.cursorh, 'click', function(d) {
                      b.cancelEvent(d);
                    }),
                    b.bind(b.cursorh, 'dblclick', function(d) {
                      b.cancelEvent(d);
                    })));
            !f.cantouch && !b.opt.touchbehavior
              ? (b.bind(f.hasmousecapture ? b.win : document, 'mouseup', b.onmouseup),
                b.bind(document, 'mousemove', b.onmousemove),
                b.onclick && b.bind(document, 'click', b.onclick),
                !b.ispage &&
                  b.opt.enablescrollonselection &&
                  (b.bind(b.win[0], 'mousedown', b.onselectionstart),
                  b.bind(document, 'mouseup', b.onselectionend),
                  b.bind(b.cursor, 'mouseup', b.onselectionend),
                  b.cursorh && b.bind(b.cursorh, 'mouseup', b.onselectionend),
                  b.bind(document, 'mousemove', b.onselectiondrag)),
                b.zoom &&
                  (b.jqbind(b.zoom, 'mouseenter', function() {
                    b.canshowonmouseevent && b.showCursor();
                    b.rail.active = !0;
                  }),
                  b.jqbind(b.zoom, 'mouseleave', function() {
                    b.rail.active = !1;
                    b.rail.drag || b.hideCursor();
                  })))
              : (b.bind(f.hasmousecapture ? b.win : document, 'mouseup', b.ontouchend),
                b.bind(document, 'mousemove', b.ontouchmove),
                b.onclick && b.bind(document, 'click', b.onclick),
                b.opt.cursordragontouch &&
                  (b.bind(b.cursor, 'mousedown', b.onmousedown),
                  b.bind(b.cursor, 'mousemove', b.onmousemove),
                  b.cursorh && b.bind(b.cursorh, 'mousedown', b.onmousedown),
                  b.cursorh && b.bind(b.cursorh, 'mousemove', b.onmousemove)));
            b.opt.enablemousewheel &&
              (b.isiframe || b.bind(f.isie && b.ispage ? document : b.docscroll, 'mousewheel', b.onmousewheel),
              b.bind(b.rail, 'mousewheel', b.onmousewheel),
              b.railh && b.bind(b.railh, 'mousewheel', b.onmousewheelhr));
            !b.ispage &&
              !f.cantouch && !/HTML|BODY/.test(b.win[0].nodeName) &&
              (b.win.attr('tabindex') || b.win.attr({ tabindex: J++ }),
              b.jqbind(b.win, 'focus', function(d) {
                y = b.getTarget(d).id || !0;
                b.hasfocus = !0;
                b.canshowonmouseevent && b.noticeCursor();
              }),
              b.jqbind(b.win, 'blur', function(d) {
                y = !1;
                b.hasfocus = !1;
              }),
              b.jqbind(b.win, 'mouseenter', function(d) {
                D = b.getTarget(d).id || !0;
                b.hasmousefocus = !0;
                b.canshowonmouseevent && b.noticeCursor();
              }),
              b.jqbind(b.win, 'mouseleave', function() {
                D = !1;
                b.hasmousefocus = !1;
              }));
          }
          b.onkeypress = function(d) {
            if (b.locked && 0 == b.page.maxh) return !0;
            d = d ? d : window.e;
            var c = b.getTarget(d);
            if (
              c &&
              /INPUT|TEXTAREA|SELECT|OPTION/.test(c.nodeName) &&
              ((!c.getAttribute('type') && !c.type) || !/submit|button|cancel/i.tp)
            )
              return !0;
            if (b.hasfocus || (b.hasmousefocus && !y) || (b.ispage && !y && !D)) {
              c = d.keyCode;
              if (b.locked && 27 != c) return b.cancelEvent(d);
              var g = d.ctrlKey || !1,
                p = d.shiftKey || !1,
                f = !1;
              switch (c) {
                case 38:
                case 63233:
                  b.doScrollBy(72);
                  f = !0;
                  break;
                case 40:
                case 63235:
                  b.doScrollBy(-72);
                  f = !0;
                  break;
                case 37:
                case 63232:
                  b.railh && (g ? b.doScrollLeft(0) : b.doScrollLeftBy(72), (f = !0));
                  break;
                case 39:
                case 63234:
                  b.railh && (g ? b.doScrollLeft(b.page.maxw) : b.doScrollLeftBy(-72), (f = !0));
                  break;
                case 33:
                case 63276:
                  b.doScrollBy(b.view.h);
                  f = !0;
                  break;
                case 34:
                case 63277:
                  b.doScrollBy(-b.view.h);
                  f = !0;
                  break;
                case 36:
                case 63273:
                  b.railh && g ? b.doScrollPos(0, 0) : b.doScrollTo(0);
                  f = !0;
                  break;
                case 35:
                case 63275:
                  b.railh && g ? b.doScrollPos(b.page.maxw, b.page.maxh) : b.doScrollTo(b.page.maxh);
                  f = !0;
                  break;
                case 32:
                  b.opt.spacebarenabled && (p ? b.doScrollBy(b.view.h) : b.doScrollBy(-b.view.h), (f = !0));
                  break;
                case 27:
                  b.zoomactive && (b.doZoom(), (f = !0));
              }
              if (f) return b.cancelEvent(d);
            }
          };
          b.opt.enablekeyboard && b.bind(document, f.isopera && !f.isopera12 ? 'keypress' : 'keydown', b.onkeypress);
          b.bind(window, 'resize', b.lazyResize);
          b.bind(window, 'orientationchange', b.lazyResize);
          b.bind(window, 'load', b.lazyResize);
          if (f.ischrome && !b.ispage && !b.haswrapper) {
            var t = b.win.attr('style'),
              g = parseFloat(b.win.css('width')) + 1;
            b.win.css('width', g);
            b.synched('chromefix', function() {
              b.win.attr('style', t);
            });
          }
          b.onAttributeChange = function(d) {
            b.lazyResize(250);
          };
          !b.ispage &&
            !b.haswrapper &&
            (!1 !== z
              ? ((b.observer = new z(function(d) {
                  d.forEach(b.onAttributeChange);
                })),
                b.observer.observe(b.win[0], { childList: !0, characterData: !1, attributes: !0, subtree: !1 }),
                (b.observerremover = new z(function(d) {
                  d.forEach(function(d) {
                    if (0 < d.removedNodes.length)
                      for (var c in d.removedNodes) if (d.removedNodes[c] == b.win[0]) return b.remove();
                  });
                })),
                b.observerremover.observe(b.win[0].parentNode, {
                  childList: !0,
                  characterData: !1,
                  attributes: !1,
                  subtree: !1,
                }))
              : (b.bind(b.win, f.isie && !f.isie9 ? 'propertychange' : 'DOMAttrModified', b.onAttributeChange),
                f.isie9 && b.win[0].attachEvent('onpropertychange', b.onAttributeChange),
                b.bind(b.win, 'DOMNodeRemoved', function(d) {
                  d.target == b.win[0] && b.remove();
                })));
          !b.ispage && b.opt.boxzoom && b.bind(window, 'resize', b.resizeZoom);
          b.istextarea && b.bind(b.win, 'mouseup', b.lazyResize);
          b.checkrtlmode = !0;
          b.lazyResize(30);
        }
        if ('IFRAME' == this.doc[0].nodeName) {
          var I = function(d) {
            b.iframexd = !1;
            try {
              var c = 'contentDocument' in this ? this.contentDocument : this.contentWindow.document;
            } catch (g) {
              (b.iframexd = !0), (c = !1);
            }
            if (b.iframexd) return 'console' in window && console.log('NiceScroll error: policy restriced iframe'), !0;
            b.forcescreen = !0;
            b.isiframe &&
              ((b.iframe = {
                doc: e(c),
                html: b.doc.contents().find('html')[0],
                body: b.doc.contents().find('body')[0],
              }),
              (b.getContentSize = function() {
                return {
                  w: Math.max(b.iframe.html.scrollWidth, b.iframe.body.scrollWidth),
                  h: Math.max(b.iframe.html.scrollHeight, b.iframe.body.scrollHeight),
                };
              }),
              (b.docscroll = e(b.iframe.body)));
            !f.isios &&
              b.opt.iframeautoresize && !b.isiframe &&
              (b.win.scrollTop(0),
              b.doc.height(''),
              (d = Math.max(c.getElementsByTagName('html')[0].scrollHeight, c.body.scrollHeight)),
              b.doc.height(d));
            b.lazyResize(30);
            f.isie7 && b.css(e(b.iframe.html), { 'overflow-y': 'hidden' });
            b.css(e(b.iframe.body), { 'overflow-y': 'hidden' });
            'contentWindow' in this
              ? b.bind(this.contentWindow, 'scroll', b.onscroll)
              : b.bind(c, 'scroll', b.onscroll);
            b.opt.enablemousewheel && b.bind(c, 'mousewheel', b.onmousewheel);
            b.opt.enablekeyboard && b.bind(c, f.isopera ? 'keypress' : 'keydown', b.onkeypress);
            if (f.cantouch || b.opt.touchbehavior)
              b.bind(c, 'mousedown', b.onmousedown),
                b.bind(c, 'mousemove', function(d) {
                  b.onmousemove(d, !0);
                }),
                b.opt.grabcursorenabled && f.cursorgrabvalue && b.css(e(c.body), { cursor: f.cursorgrabvalue });
            b.bind(c, 'mouseup', b.onmouseup);
            b.zoom &&
              (b.opt.dblclickzoom && b.bind(c, 'dblclick', b.doZoom),
              b.ongesturezoom && b.bind(c, 'gestureend', b.ongesturezoom));
          };
          this.doc[0].readyState &&
            'complete' == this.doc[0].readyState &&
            setTimeout(function() {
              I.call(b.doc[0], !1);
            }, 500);
          b.bind(this.doc, 'load', I);
        }
      };
      this.showCursor = function(d, c) {
        b.cursortimeout && (clearTimeout(b.cursortimeout), (b.cursortimeout = 0));
        if (b.rail) {
          b.autohidedom && (b.autohidedom.stop().css({ opacity: b.opt.cursoropacitymax }), (b.cursoractive = !0));
          if (!b.rail.drag || 1 != b.rail.drag.pt)
            'undefined' != typeof d && !1 !== d && (b.scroll.y = Math.round((1 * d) / b.scrollratio.y)),
              'undefined' != typeof c && (b.scroll.x = Math.round((1 * c) / b.scrollratio.x));
          b.cursor.css({ height: b.cursorheight, top: b.scroll.y });
          b.cursorh &&
            (!b.rail.align && b.rail.visibility
              ? b.cursorh.css({ width: b.cursorwidth, left: b.scroll.x + b.rail.width })
              : b.cursorh.css({ width: b.cursorwidth, left: b.scroll.x }),
            (b.cursoractive = !0));
          b.zoom && b.zoom.stop().css({ opacity: b.opt.cursoropacitymax });
        }
      };
      this.hideCursor = function(d) {
        !b.cursortimeout &&
          b.rail && b.autohidedom &&
          (b.cursortimeout = setTimeout(function() {
            if (!b.rail.active || !b.showonmouseevent)
              b.autohidedom.stop().animate({ opacity: b.opt.cursoropacitymin }),
                b.zoom && b.zoom.stop().animate({ opacity: b.opt.cursoropacitymin }),
                (b.cursoractive = !1);
            b.cursortimeout = 0;
          }, d || b.opt.hidecursordelay));
      };
      this.noticeCursor = function(d, c, g) {
        b.showCursor(c, g);
        b.rail.active || b.hideCursor(d);
      };
      this.getContentSize = b.ispage
        ? function() {
            return {
              w: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
              h: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight),
            };
          }
        : b.haswrapper
        ? function() {
            return {
              w: b.doc.outerWidth() + parseInt(b.win.css('paddingLeft')) + parseInt(b.win.css('paddingRight')),
              h: b.doc.outerHeight() + parseInt(b.win.css('paddingTop')) + parseInt(b.win.css('paddingBottom')),
            };
          }
        : function() {
            return { w: b.docscroll[0].scrollWidth, h: b.docscroll[0].scrollHeight };
          };
      this.onResize = function(d, c) {
        if (!b.win) return !1;
        if (!b.haswrapper && !b.ispage) {
          if ('none' == b.win.css('display')) return b.visibility && b.hideRail().hideRailHr(), !1;
          !b.hidden && !b.visibility && b.showRail().showRailHr();
        }
        var g = b.page.maxh,
          f = b.page.maxw,
          e = b.view.w;
        b.view = {
          w: b.ispage ? b.win.width() : parseInt(b.win[0].clientWidth),
          h: b.ispage ? b.win.height() : parseInt(b.win[0].clientHeight),
        };
        b.page = c ? c : b.getContentSize();
        b.page.maxh = Math.max(0, b.page.h - b.view.h);
        b.page.maxw = Math.max(0, b.page.w - b.view.w);
        if (b.page.maxh == g && b.page.maxw == f && b.view.w == e) {
          if (b.ispage) return b;
          g = b.win.offset();
          if (b.lastposition && ((f = b.lastposition), f.top == g.top && f.left == g.left)) return b;
          b.lastposition = g;
        }
        0 == b.page.maxh
          ? (b.hideRail(),
            (b.scrollvaluemax = 0),
            (b.scroll.y = 0),
            (b.scrollratio.y = 0),
            (b.cursorheight = 0),
            b.setScrollTop(0),
            (b.rail.scrollable = !1))
          : (b.rail.scrollable = !0);
        0 == b.page.maxw
          ? (b.hideRailHr(),
            (b.scrollvaluemaxw = 0),
            (b.scroll.x = 0),
            (b.scrollratio.x = 0),
            (b.cursorwidth = 0),
            b.setScrollLeft(0),
            (b.railh.scrollable = !1))
          : (b.railh.scrollable = !0);
        b.locked = 0 == b.page.maxh && 0 == b.page.maxw;
        if (b.locked) return b.ispage || b.updateScrollBar(b.view), !1;
        !b.hidden && !b.visibility ? b.showRail().showRailHr() : !b.hidden && !b.railh.visibility && b.showRailHr();
        b.istextarea && b.win.css('resize') && 'none' != b.win.css('resize') && (b.view.h -= 20);
        b.cursorheight = Math.min(b.view.h, Math.round(b.view.h * (b.view.h / b.page.h)));
        b.cursorheight = b.opt.cursorfixedheight
          ? b.opt.cursorfixedheight
          : Math.max(b.opt.cursorminheight, b.cursorheight);
        b.cursorwidth = Math.min(b.view.w, Math.round(b.view.w * (b.view.w / b.page.w)));
        b.cursorwidth = b.opt.cursorfixedheight
          ? b.opt.cursorfixedheight
          : Math.max(b.opt.cursorminheight, b.cursorwidth);
        b.scrollvaluemax = b.view.h - b.cursorheight - b.cursor.hborder;
        b.railh &&
          ((b.railh.width = 0 < b.page.maxh ? b.view.w - b.rail.width : b.view.w),
          (b.scrollvaluemaxw = b.railh.width - b.cursorwidth - b.cursorh.wborder));
        b.checkrtlmode &&
          b.railh &&
          ((b.checkrtlmode = !1), b.opt.rtlmode && 0 == b.scroll.x && b.setScrollLeft(b.page.maxw));
        b.ispage || b.updateScrollBar(b.view);
        b.scrollratio = { x: b.page.maxw / b.scrollvaluemaxw, y: b.page.maxh / b.scrollvaluemax };
        b.getScrollTop() > b.page.maxh
          ? b.doScrollTop(b.page.maxh)
          : ((b.scroll.y = Math.round(b.getScrollTop() * (1 / b.scrollratio.y))),
            (b.scroll.x = Math.round(b.getScrollLeft() * (1 / b.scrollratio.x))),
            b.cursoractive && b.noticeCursor());
        b.scroll.y && 0 == b.getScrollTop() && b.doScrollTo(Math.floor(b.scroll.y * b.scrollratio.y));
        return b;
      };
      this.resize = b.onResize;
      this.lazyResize = function(d) {
        d = isNaN(d) ? 30 : d;
        b.delayed('resize', b.resize, d);
        return b;
      };
      this._bind = function(d, c, g, f) {
        b.events.push({ e: d, n: c, f: g, b: f, q: !1 });
        d.addEventListener
          ? d.addEventListener(c, g, f || !1)
          : d.attachEvent
          ? d.attachEvent('on' + c, g)
          : (d['on' + c] = g);
      };
      this.jqbind = function(d, c, g) {
        b.events.push({ e: d, n: c, f: g, q: !0 });
        e(d).bind(c, g);
      };
      this.bind = function(d, c, g, e) {
        var h = 'jquery' in d ? d[0] : d;
        'mousewheel' == c
          ? 'onwheel' in b.win
            ? b._bind(h, 'wheel', g, e || !1)
            : ((d = 'undefined' != typeof document.onmousewheel ? 'mousewheel' : 'DOMMouseScroll'),
              n(h, d, g, e || !1),
              'DOMMouseScroll' == d && n(h, 'MozMousePixelScroll', g, e || !1))
          : h.addEventListener
          ? (f.cantouch &&
              /mouseup|mousedown|mousemove/.test(c) &&
              b._bind(
                h,
                'mousedown' == c ? 'touchstart' : 'mouseup' == c ? 'touchend' : 'touchmove',
                function(b) {
                  if (b.touches) {
                    if (2 > b.touches.length) {
                      var d = b.touches.length ? b.touches[0] : b;
                      d.original = b;
                      g.call(this, d);
                    }
                  } else b.changedTouches && ((d = b.changedTouches[0]), (d.original = b), g.call(this, d));
                },
                e || !1
              ),
            b._bind(h, c, g, e || !1),
            f.cantouch && 'mouseup' == c && b._bind(h, 'touchcancel', g, e || !1))
          : b._bind(h, c, function(d) {
              if ((d = d || window.event || !1) && d.srcElement) d.target = d.srcElement;
              'pageY' in d ||
                ((d.pageX = d.clientX + document.documentElement.scrollLeft),
                (d.pageY = d.clientY + document.documentElement.scrollTop));
              return !1 === g.call(h, d) || !1 === e ? b.cancelEvent(d) : !0;
            });
      };
      this._unbind = function(b, c, g, f) {
        b.removeEventListener
          ? b.removeEventListener(c, g, f)
          : b.detachEvent
          ? b.detachEvent('on' + c, g)
          : (b['on' + c] = !1);
      };
      this.unbindAll = function() {
        for (var d = 0; d < b.events.length; d++) {
          var c = b.events[d];
          c.q ? c.e.unbind(c.n, c.f) : b._unbind(c.e, c.n, c.f, c.b);
        }
      };
      this.cancelEvent = function(b) {
        b = b.original ? b.original : b ? b : window.event || !1;
        if (!b) return !1;
        b.preventDefault && b.preventDefault();
        b.stopPropagation && b.stopPropagation();
        b.preventManipulation && b.preventManipulation();
        b.cancelBubble = !0;
        b.cancel = !0;
        return (b.returnValue = !1);
      };
      this.stopPropagation = function(b) {
        b = b.original ? b.original : b ? b : window.event || !1;
        if (!b) return !1;
        if (b.stopPropagation) return b.stopPropagation();
        b.cancelBubble && (b.cancelBubble = !0);
        return !1;
      };
      this.showRail = function() {
        if (0 != b.page.maxh && (b.ispage || 'none' != b.win.css('display')))
          (b.visibility = !0), (b.rail.visibility = !0), b.rail.css('display', 'block');
        return b;
      };
      this.showRailHr = function() {
        if (!b.railh) return b;
        if (0 != b.page.maxw && (b.ispage || 'none' != b.win.css('display')))
          (b.railh.visibility = !0), b.railh.css('display', 'block');
        return b;
      };
      this.hideRail = function() {
        b.visibility = !1;
        b.rail.visibility = !1;
        b.rail.css('display', 'none');
        return b;
      };
      this.hideRailHr = function() {
        if (!b.railh) return b;
        b.railh.visibility = !1;
        b.railh.css('display', 'none');
        return b;
      };
      this.show = function() {
        b.hidden = !1;
        b.locked = !1;
        return b.showRail().showRailHr();
      };
      this.hide = function() {
        b.hidden = !0;
        b.locked = !0;
        return b.hideRail().hideRailHr();
      };
      this.toggle = function() {
        return b.hidden ? b.show() : b.hide();
      };
      this.remove = function() {
        b.stop();
        b.cursortimeout && clearTimeout(b.cursortimeout);
        b.doZoomOut();
        b.unbindAll();
        !1 !== b.observer && b.observer.disconnect();
        !1 !== b.observerremover && b.observerremover.disconnect();
        b.events = [];
        b.cursor && (b.cursor.remove(), (b.cursor = null));
        b.cursorh && (b.cursorh.remove(), (b.cursorh = null));
        b.rail && (b.rail.remove(), (b.rail = null));
        b.railh && (b.railh.remove(), (b.railh = null));
        b.zoom && (b.zoom.remove(), (b.zoom = null));
        for (var d = 0; d < b.saved.css.length; d++) {
          var c = b.saved.css[d];
          c[0].css(c[1], 'undefined' == typeof c[2] ? '' : c[2]);
        }
        b.saved = !1;
        b.me.data('__nicescroll', '');
        b.me = null;
        b.doc = null;
        b.docscroll = null;
        b.win = null;
        return b;
      };
      this.scrollstart = function(d) {
        this.onscrollstart = d;
        return b;
      };
      this.scrollend = function(d) {
        this.onscrollend = d;
        return b;
      };
      this.scrollcancel = function(d) {
        this.onscrollcancel = d;
        return b;
      };
      this.zoomin = function(d) {
        this.onzoomin = d;
        return b;
      };
      this.zoomout = function(d) {
        this.onzoomout = d;
        return b;
      };
      this.isScrollable = function(b) {
        b = b.target ? b.target : b;
        if ('OPTION' == b.nodeName) return !0;
        for (; b && 1 == b.nodeType && !/BODY|HTML/.test(b.nodeName); ) {
          var c = e(b),
            c = c.css('overflowY') || c.css('overflowX') || c.css('overflow') || '';
          if (/scroll|auto/.test(c)) return b.clientHeight != b.scrollHeight;
          b = b.parentNode ? b.parentNode : !1;
        }
        return !1;
      };
      this.getViewport = function(b) {
        for (b = b && b.parentNode ? b.parentNode : !1; b && 1 == b.nodeType && !/BODY|HTML/.test(b.nodeName); ) {
          var c = e(b),
            g = c.css('overflowY') || c.css('overflowX') || c.css('overflow') || '';
          if ((/scroll|auto/.test(g) && b.clientHeight != b.scrollHeight) || 0 < c.getNiceScroll().length) return c;
          b = b.parentNode ? b.parentNode : !1;
        }
        return !1;
      };
      this.onmousewheel = function(d) {
        if (b.locked) return !0;
        if (b.rail.drag) return b.cancelEvent(d);
        if (!b.rail.scrollable) return b.railh && b.railh.scrollable ? b.onmousewheelhr(d) : !0;
        var c = +new Date(),
          g = !1;
        b.opt.preservenativescrolling &&
          b.checkarea + 600 < c &&
          ((b.nativescrollingarea = b.isScrollable(d)), (g = !0));
        b.checkarea = c;
        if (b.nativescrollingarea) return !0;
        if ((d = t(d, !1, g))) b.checkarea = 0;
        return d;
      };
      this.onmousewheelhr = function(d) {
        if (b.locked || !b.railh.scrollable) return !0;
        if (b.rail.drag) return b.cancelEvent(d);
        var c = +new Date(),
          g = !1;
        b.opt.preservenativescrolling &&
          b.checkarea + 600 < c &&
          ((b.nativescrollingarea = b.isScrollable(d)), (g = !0));
        b.checkarea = c;
        return b.nativescrollingarea ? !0 : b.locked ? b.cancelEvent(d) : t(d, !0, g);
      };
      this.stop = function() {
        b.cancelScroll();
        b.scrollmon && b.scrollmon.stop();
        b.cursorfreezed = !1;
        b.scroll.y = Math.round(b.getScrollTop() * (1 / b.scrollratio.y));
        b.noticeCursor();
        return b;
      };
      this.getTransitionSpeed = function(c) {
        var f = Math.round(10 * b.opt.scrollspeed);
        c = Math.min(f, Math.round((c / 20) * b.opt.scrollspeed));
        return 20 < c ? c : 0;
      };
      b.opt.smoothscroll
        ? b.ishwscroll && f.hastransition && b.opt.usetransition
          ? ((this.prepareTransition = function(c, e) {
              var g = e ? (20 < c ? c : 0) : b.getTransitionSpeed(c),
                h = g ? f.prefixstyle + 'transform ' + g + 'ms ease-out' : '';
              if (!b.lasttransitionstyle || b.lasttransitionstyle != h)
                (b.lasttransitionstyle = h), b.doc.css(f.transitionstyle, h);
              return g;
            }),
            (this.doScrollLeft = function(c, f) {
              var g = b.scrollrunning ? b.newscrolly : b.getScrollTop();
              b.doScrollPos(c, g, f);
            }),
            (this.doScrollTop = function(c, f) {
              var g = b.scrollrunning ? b.newscrollx : b.getScrollLeft();
              b.doScrollPos(g, c, f);
            }),
            (this.doScrollPos = function(c, e, g) {
              var h = b.getScrollTop(),
                l = b.getScrollLeft();
              (0 > (b.newscrolly - h) * (e - h) || 0 > (b.newscrollx - l) * (c - l)) && b.cancelScroll();
              !1 == b.opt.bouncescroll &&
                (0 > e ? (e = 0) : e > b.page.maxh && (e = b.page.maxh),
                0 > c ? (c = 0) : c > b.page.maxw && (c = b.page.maxw));
              if (b.scrollrunning && c == b.newscrollx && e == b.newscrolly) return !1;
              b.newscrolly = e;
              b.newscrollx = c;
              b.newscrollspeed = g || !1;
              if (b.timer) return !1;
              b.timer = setTimeout(function() {
                var g = b.getScrollTop(),
                  h = b.getScrollLeft(),
                  l,
                  k;
                l = c - h;
                k = e - g;
                l = Math.round(Math.sqrt(Math.pow(l, 2) + Math.pow(k, 2)));
                l = b.newscrollspeed && 1 < b.newscrollspeed ? b.newscrollspeed : b.getTransitionSpeed(l);
                b.newscrollspeed && 1 >= b.newscrollspeed && (l *= b.newscrollspeed);
                b.prepareTransition(l, !0);
                b.timerscroll && b.timerscroll.tm && clearInterval(b.timerscroll.tm);
                0 < l &&
                  (!b.scrollrunning &&
                    b.onscrollstart &&
                    b.onscrollstart.call(b, {
                      type: 'scrollstart',
                      current: { x: h, y: g },
                      request: { x: c, y: e },
                      end: { x: b.newscrollx, y: b.newscrolly },
                      speed: l,
                    }),
                  f.transitionend
                    ? b.scrollendtrapped ||
                      ((b.scrollendtrapped = !0), b.bind(b.doc, f.transitionend, b.onScrollEnd, !1))
                    : (b.scrollendtrapped && clearTimeout(b.scrollendtrapped),
                      (b.scrollendtrapped = setTimeout(b.onScrollEnd, l))),
                  (b.timerscroll = {
                    bz: new BezierClass(g, b.newscrolly, l, 0, 0, 0.58, 1),
                    bh: new BezierClass(h, b.newscrollx, l, 0, 0, 0.58, 1),
                  }),
                  b.cursorfreezed ||
                    (b.timerscroll.tm = setInterval(function() {
                      b.showCursor(b.getScrollTop(), b.getScrollLeft());
                    }, 60)));
                b.synched('doScroll-set', function() {
                  b.timer = 0;
                  b.scrollendtrapped && (b.scrollrunning = !0);
                  b.setScrollTop(b.newscrolly);
                  b.setScrollLeft(b.newscrollx);
                  if (!b.scrollendtrapped) b.onScrollEnd();
                });
              }, 50);
            }),
            (this.cancelScroll = function() {
              if (!b.scrollendtrapped) return !0;
              var c = b.getScrollTop(),
                e = b.getScrollLeft();
              b.scrollrunning = !1;
              f.transitionend || clearTimeout(f.transitionend);
              b.scrollendtrapped = !1;
              b._unbind(b.doc, f.transitionend, b.onScrollEnd);
              b.prepareTransition(0);
              b.setScrollTop(c);
              b.railh && b.setScrollLeft(e);
              b.timerscroll && b.timerscroll.tm && clearInterval(b.timerscroll.tm);
              b.timerscroll = !1;
              b.cursorfreezed = !1;
              b.showCursor(c, e);
              return b;
            }),
            (this.onScrollEnd = function() {
              b.scrollendtrapped && b._unbind(b.doc, f.transitionend, b.onScrollEnd);
              b.scrollendtrapped = !1;
              b.prepareTransition(0);
              b.timerscroll && b.timerscroll.tm && clearInterval(b.timerscroll.tm);
              b.timerscroll = !1;
              var c = b.getScrollTop(),
                e = b.getScrollLeft();
              b.setScrollTop(c);
              b.railh && b.setScrollLeft(e);
              b.noticeCursor(!1, c, e);
              b.cursorfreezed = !1;
              0 > c ? (c = 0) : c > b.page.maxh && (c = b.page.maxh);
              0 > e ? (e = 0) : e > b.page.maxw && (e = b.page.maxw);
              if (c != b.newscrolly || e != b.newscrollx) return b.doScrollPos(e, c, b.opt.snapbackspeed);
              b.onscrollend &&
                b.scrollrunning &&
                b.onscrollend.call(b, {
                  type: 'scrollend',
                  current: { x: e, y: c },
                  end: { x: b.newscrollx, y: b.newscrolly },
                });
              b.scrollrunning = !1;
            }))
          : ((this.doScrollLeft = function(c, f) {
              var g = b.scrollrunning ? b.newscrolly : b.getScrollTop();
              b.doScrollPos(c, g, f);
            }),
            (this.doScrollTop = function(c, f) {
              var g = b.scrollrunning ? b.newscrollx : b.getScrollLeft();
              b.doScrollPos(g, c, f);
            }),
            (this.doScrollPos = function(c, f, g) {
              function e() {
                if (b.cancelAnimationFrame) return !0;
                b.scrollrunning = !0;
                if ((r = 1 - r)) return (b.timer = v(e) || 1);
                var c = 0,
                  d = (sy = b.getScrollTop());
                if (b.dst.ay) {
                  var d = b.bzscroll ? b.dst.py + b.bzscroll.getNow() * b.dst.ay : b.newscrolly,
                    g = d - sy;
                  if ((0 > g && d < b.newscrolly) || (0 < g && d > b.newscrolly)) d = b.newscrolly;
                  b.setScrollTop(d);
                  d == b.newscrolly && (c = 1);
                } else c = 1;
                var f = (sx = b.getScrollLeft());
                if (b.dst.ax) {
                  f = b.bzscroll ? b.dst.px + b.bzscroll.getNow() * b.dst.ax : b.newscrollx;
                  g = f - sx;
                  if ((0 > g && f < b.newscrollx) || (0 < g && f > b.newscrollx)) f = b.newscrollx;
                  b.setScrollLeft(f);
                  f == b.newscrollx && (c += 1);
                } else c += 1;
                2 == c
                  ? ((b.timer = 0),
                    (b.cursorfreezed = !1),
                    (b.bzscroll = !1),
                    (b.scrollrunning = !1),
                    0 > d ? (d = 0) : d > b.page.maxh && (d = b.page.maxh),
                    0 > f ? (f = 0) : f > b.page.maxw && (f = b.page.maxw),
                    f != b.newscrollx || d != b.newscrolly
                      ? b.doScrollPos(f, d)
                      : b.onscrollend &&
                        b.onscrollend.call(b, {
                          type: 'scrollend',
                          current: { x: sx, y: sy },
                          end: { x: b.newscrollx, y: b.newscrolly },
                        }))
                  : (b.timer = v(e) || 1);
              }
              f = 'undefined' == typeof f || !1 === f ? b.getScrollTop(!0) : f;
              if (b.timer && b.newscrolly == f && b.newscrollx == c) return !0;
              b.timer && w(b.timer);
              b.timer = 0;
              var h = b.getScrollTop(),
                l = b.getScrollLeft();
              (0 > (b.newscrolly - h) * (f - h) || 0 > (b.newscrollx - l) * (c - l)) && b.cancelScroll();
              b.newscrolly = f;
              b.newscrollx = c;
              if (!b.bouncescroll || !b.rail.visibility)
                0 > b.newscrolly ? (b.newscrolly = 0) : b.newscrolly > b.page.maxh && (b.newscrolly = b.page.maxh);
              if (!b.bouncescroll || !b.railh.visibility)
                0 > b.newscrollx ? (b.newscrollx = 0) : b.newscrollx > b.page.maxw && (b.newscrollx = b.page.maxw);
              b.dst = {};
              b.dst.x = c - l;
              b.dst.y = f - h;
              b.dst.px = l;
              b.dst.py = h;
              var k = Math.round(Math.sqrt(Math.pow(b.dst.x, 2) + Math.pow(b.dst.y, 2)));
              b.dst.ax = b.dst.x / k;
              b.dst.ay = b.dst.y / k;
              var n = 0,
                q = k;
              0 == b.dst.x
                ? ((n = h), (q = f), (b.dst.ay = 1), (b.dst.py = 0))
                : 0 == b.dst.y && ((n = l), (q = c), (b.dst.ax = 1), (b.dst.px = 0));
              k = b.getTransitionSpeed(k);
              g && 1 >= g && (k *= g);
              b.bzscroll = 0 < k ? (b.bzscroll ? b.bzscroll.update(q, k) : new BezierClass(n, q, k, 0, 1, 0, 1)) : !1;
              if (!b.timer) {
                ((h == b.page.maxh && f >= b.page.maxh) || (l == b.page.maxw && c >= b.page.maxw)) &&
                  b.checkContentSize();
                var r = 1;
                b.cancelAnimationFrame = !1;
                b.timer = 1;
                b.onscrollstart &&
                  !b.scrollrunning &&
                  b.onscrollstart.call(b, {
                    type: 'scrollstart',
                    current: { x: l, y: h },
                    request: { x: c, y: f },
                    end: { x: b.newscrollx, y: b.newscrolly },
                    speed: k,
                  });
                e();
                ((h == b.page.maxh && f >= h) || (l == b.page.maxw && c >= l)) && b.checkContentSize();
                b.noticeCursor();
              }
            }),
            (this.cancelScroll = function() {
              b.timer && w(b.timer);
              b.timer = 0;
              b.bzscroll = !1;
              b.scrollrunning = !1;
              return b;
            }))
        : ((this.doScrollLeft = function(c, f) {
            var g = b.getScrollTop();
            b.doScrollPos(c, g, f);
          }),
          (this.doScrollTop = function(c, f) {
            var g = b.getScrollLeft();
            b.doScrollPos(g, c, f);
          }),
          (this.doScrollPos = function(c, f, g) {
            var e = c > b.page.maxw ? b.page.maxw : c;
            0 > e && (e = 0);
            var h = f > b.page.maxh ? b.page.maxh : f;
            0 > h && (h = 0);
            b.synched('scroll', function() {
              b.setScrollTop(h);
              b.setScrollLeft(e);
            });
          }),
          (this.cancelScroll = function() {}));
      this.doScrollBy = function(c, f) {
        var g = 0,
          g = f ? Math.floor((b.scroll.y - c) * b.scrollratio.y) : (b.timer ? b.newscrolly : b.getScrollTop(!0)) - c;
        if (b.bouncescroll) {
          var e = Math.round(b.view.h / 2);
          g < -e ? (g = -e) : g > b.page.maxh + e && (g = b.page.maxh + e);
        }
        b.cursorfreezed = !1;
        py = b.getScrollTop(!0);
        if (0 > g && 0 >= py) return b.noticeCursor();
        if (g > b.page.maxh && py >= b.page.maxh) return b.checkContentSize(), b.noticeCursor();
        b.doScrollTop(g);
      };
      this.doScrollLeftBy = function(c, f) {
        var g = 0,
          g = f ? Math.floor((b.scroll.x - c) * b.scrollratio.x) : (b.timer ? b.newscrollx : b.getScrollLeft(!0)) - c;
        if (b.bouncescroll) {
          var e = Math.round(b.view.w / 2);
          g < -e ? (g = -e) : g > b.page.maxw + e && (g = b.page.maxw + e);
        }
        b.cursorfreezed = !1;
        px = b.getScrollLeft(!0);
        if ((0 > g && 0 >= px) || (g > b.page.maxw && px >= b.page.maxw)) return b.noticeCursor();
        b.doScrollLeft(g);
      };
      this.doScrollTo = function(c, f) {
        f && Math.round(c * b.scrollratio.y);
        b.cursorfreezed = !1;
        b.doScrollTop(c);
      };
      this.checkContentSize = function() {
        var c = b.getContentSize();
        (c.h != b.page.h || c.w != b.page.w) && b.resize(!1, c);
      };
      b.onscroll = function(c) {
        b.rail.drag ||
          b.cursorfreezed ||
          b.synched('scroll', function() {
            b.scroll.y = Math.round(b.getScrollTop() * (1 / b.scrollratio.y));
            b.railh && (b.scroll.x = Math.round(b.getScrollLeft() * (1 / b.scrollratio.x)));
            b.noticeCursor();
          });
      };
      b.bind(b.docscroll, 'scroll', b.onscroll);
      this.doZoomIn = function(c) {
        if (!b.zoomactive) {
          b.zoomactive = !0;
          b.zoomrestore = { style: {} };
          var h = 'position top left zIndex backgroundColor marginTop marginBottom marginLeft marginRight'.split(' '),
            g = b.win[0].style,
            l;
          for (l in h) {
            var k = h[l];
            b.zoomrestore.style[k] = 'undefined' != typeof g[k] ? g[k] : '';
          }
          b.zoomrestore.style.width = b.win.css('width');
          b.zoomrestore.style.height = b.win.css('height');
          b.zoomrestore.padding = { w: b.win.outerWidth() - b.win.width(), h: b.win.outerHeight() - b.win.height() };
          f.isios4 && ((b.zoomrestore.scrollTop = e(window).scrollTop()), e(window).scrollTop(0));
          b.win.css({ position: f.isios4 ? 'absolute' : 'fixed', top: 0, left: 0, 'z-index': x + 100, margin: '0px' });
          h = b.win.css('backgroundColor');
          ('' == h || /transparent|rgba\(0, 0, 0, 0\)|rgba\(0,0,0,0\)/.test(h)) && b.win.css('backgroundColor', '#fff');
          b.rail.css({ 'z-index': x + 101 });
          b.zoom.css({ 'z-index': x + 102 });
          b.zoom.css('backgroundPosition', '0px -18px');
          b.resizeZoom();
          b.onzoomin && b.onzoomin.call(b);
          return b.cancelEvent(c);
        }
      };
      this.doZoomOut = function(c) {
        if (b.zoomactive)
          return (
            (b.zoomactive = !1),
            b.win.css('margin', ''),
            b.win.css(b.zoomrestore.style),
            f.isios4 && e(window).scrollTop(b.zoomrestore.scrollTop),
            b.rail.css({ 'z-index': b.zindex }),
            b.zoom.css({ 'z-index': b.zindex }),
            (b.zoomrestore = !1),
            b.zoom.css('backgroundPosition', '0px 0px'),
            b.onResize(),
            b.onzoomout && b.onzoomout.call(b),
            b.cancelEvent(c)
          );
      };
      this.doZoom = function(c) {
        return b.zoomactive ? b.doZoomOut(c) : b.doZoomIn(c);
      };
      this.resizeZoom = function() {
        if (b.zoomactive) {
          var c = b.getScrollTop();
          b.win.css({
            width: e(window).width() - b.zoomrestore.padding.w + 'px',
            height: e(window).height() - b.zoomrestore.padding.h + 'px',
          });
          b.onResize();
          b.setScrollTop(Math.min(b.page.maxh, c));
        }
      };
      this.init();
      e.nicescroll.push(this);
    },
    H = function(e) {
      var c = this;
      this.nc = e;
      this.steptime = this.lasttime = this.speedy = this.speedx = this.lasty = this.lastx = 0;
      this.snapy = this.snapx = !1;
      this.demuly = this.demulx = 0;
      this.lastscrolly = this.lastscrollx = -1;
      this.timer = this.chky = this.chkx = 0;
      this.time = function() {
        return +new Date();
      };
      this.reset = function(e, l) {
        c.stop();
        var k = c.time();
        c.steptime = 0;
        c.lasttime = k;
        c.speedx = 0;
        c.speedy = 0;
        c.lastx = e;
        c.lasty = l;
        c.lastscrollx = -1;
        c.lastscrolly = -1;
      };
      this.update = function(e, l) {
        var k = c.time();
        c.steptime = k - c.lasttime;
        c.lasttime = k;
        var k = l - c.lasty,
          t = e - c.lastx,
          b = c.nc.getScrollTop(),
          q = c.nc.getScrollLeft(),
          b = b + k,
          q = q + t;
        c.snapx = 0 > q || q > c.nc.page.maxw;
        c.snapy = 0 > b || b > c.nc.page.maxh;
        c.speedx = t;
        c.speedy = k;
        c.lastx = e;
        c.lasty = l;
      };
      this.stop = function() {
        c.nc.unsynched('domomentum2d');
        c.timer && clearTimeout(c.timer);
        c.timer = 0;
        c.lastscrollx = -1;
        c.lastscrolly = -1;
      };
      this.doSnapy = function(e, l) {
        var k = !1;
        0 > l ? ((l = 0), (k = !0)) : l > c.nc.page.maxh && ((l = c.nc.page.maxh), (k = !0));
        0 > e ? ((e = 0), (k = !0)) : e > c.nc.page.maxw && ((e = c.nc.page.maxw), (k = !0));
        k && c.nc.doScrollPos(e, l, c.nc.opt.snapbackspeed);
      };
      this.doMomentum = function(e) {
        var l = c.time(),
          k = e ? l + e : c.lasttime;
        e = c.nc.getScrollLeft();
        var t = c.nc.getScrollTop(),
          b = c.nc.page.maxh,
          q = c.nc.page.maxw;
        c.speedx = 0 < q ? Math.min(60, c.speedx) : 0;
        c.speedy = 0 < b ? Math.min(60, c.speedy) : 0;
        k = k && 50 >= l - k;
        if (0 > t || t > b || 0 > e || e > q) k = !1;
        e = c.speedx && k ? c.speedx : !1;
        if ((c.speedy && k && c.speedy) || e) {
          var f = Math.max(16, c.steptime);
          50 < f && ((e = f / 50), (c.speedx *= e), (c.speedy *= e), (f = 50));
          c.demulxy = 0;
          c.lastscrollx = c.nc.getScrollLeft();
          c.chkx = c.lastscrollx;
          c.lastscrolly = c.nc.getScrollTop();
          c.chky = c.lastscrolly;
          var r = c.lastscrollx,
            u = c.lastscrolly,
            d = function() {
              var e = 600 < c.time() - l ? 0.04 : 0.02;
              if (
                c.speedx &&
                ((r = Math.floor(c.lastscrollx - c.speedx * (1 - c.demulxy))), (c.lastscrollx = r), 0 > r || r > q)
              )
                e = 0.1;
              if (
                c.speedy &&
                ((u = Math.floor(c.lastscrolly - c.speedy * (1 - c.demulxy))), (c.lastscrolly = u), 0 > u || u > b)
              )
                e = 0.1;
              c.demulxy = Math.min(1, c.demulxy + e);
              c.nc.synched('domomentum2d', function() {
                c.speedx && (c.nc.getScrollLeft() != c.chkx && c.stop(), (c.chkx = r), c.nc.setScrollLeft(r));
                c.speedy && (c.nc.getScrollTop() != c.chky && c.stop(), (c.chky = u), c.nc.setScrollTop(u));
                c.timer || (c.nc.hideCursor(), c.doSnapy(r, u));
              });
              1 > c.demulxy ? (c.timer = setTimeout(d, f)) : (c.stop(), c.nc.hideCursor(), c.doSnapy(r, u));
            };
          d();
        } else c.doSnapy(c.nc.getScrollLeft(), c.nc.getScrollTop());
      };
    },
    A = e.fn.scrollTop;
  e.cssHooks.pageYOffset = {
    get: function(k, c, h) {
      return (c = e.data(k, '__nicescroll') || !1) && c.ishwscroll ? c.getScrollTop() : A.call(k);
    },
    set: function(k, c) {
      var h = e.data(k, '__nicescroll') || !1;
      h && h.ishwscroll ? h.setScrollTop(parseInt(c)) : A.call(k, c);
      return this;
    },
  };
  e.fn.scrollTop = function(k) {
    if ('undefined' == typeof k) {
      var c = this[0] ? e.data(this[0], '__nicescroll') || !1 : !1;
      return c && c.ishwscroll ? c.getScrollTop() : A.call(this);
    }
    return this.each(function() {
      var c = e.data(this, '__nicescroll') || !1;
      c && c.ishwscroll ? c.setScrollTop(parseInt(k)) : A.call(e(this), k);
    });
  };
  var B = e.fn.scrollLeft;
  e.cssHooks.pageXOffset = {
    get: function(k, c, h) {
      return (c = e.data(k, '__nicescroll') || !1) && c.ishwscroll ? c.getScrollLeft() : B.call(k);
    },
    set: function(k, c) {
      var h = e.data(k, '__nicescroll') || !1;
      h && h.ishwscroll ? h.setScrollLeft(parseInt(c)) : B.call(k, c);
      return this;
    },
  };
  e.fn.scrollLeft = function(k) {
    if ('undefined' == typeof k) {
      var c = this[0] ? e.data(this[0], '__nicescroll') || !1 : !1;
      return c && c.ishwscroll ? c.getScrollLeft() : B.call(this);
    }
    return this.each(function() {
      var c = e.data(this, '__nicescroll') || !1;
      c && c.ishwscroll ? c.setScrollLeft(parseInt(k)) : B.call(e(this), k);
    });
  };
  var C = function(k) {
    var c = this;
    this.length = 0;
    this.name = 'nicescrollarray';
    this.each = function(e) {
      for (var h = 0; h < c.length; h++) e.call(c[h]);
      return c;
    };
    this.push = function(e) {
      c[c.length] = e;
      c.length++;
    };
    this.eq = function(e) {
      return c[e];
    };
    if (k)
      for (a = 0; a < k.length; a++) {
        var h = e.data(k[a], '__nicescroll') || !1;
        h && ((this[this.length] = h), this.length++);
      }
    return this;
  };
  (function(e, c, h) {
    for (var l = 0; l < c.length; l++) h(e, c[l]);
  })(C.prototype, 'show hide toggle onResize resize remove stop doScrollPos'.split(' '), function(e, c) {
    e[c] = function() {
      var e = arguments;
      return this.each(function() {
        this[c].apply(this, e);
      });
    };
  });
  e.fn.getNiceScroll = function(k) {
    return 'undefined' == typeof k ? new C(this) : e.data(this[k], '__nicescroll') || !1;
  };
  e.extend(e.expr[':'], {
    nicescroll: function(k) {
      return e.data(k, '__nicescroll') ? !0 : !1;
    },
  });
  e.fn.niceScroll = function(k, c) {
    'undefined' == typeof c && 'object' == typeof k && !('jquery' in k) && ((c = k), (k = !1));
    var h = new C();
    'undefined' == typeof c && (c = {});
    k && ((c.doc = e(k)), (c.win = e(this)));
    var l = !('doc' in c);
    !l && !('win' in c) && (c.win = e(this));
    this.each(function() {
      var k = e(this).data('__nicescroll') || !1;
      k || ((c.doc = l ? e(this) : c.doc), (k = new N(c, e(this))), e(this).data('__nicescroll', k));
      h.push(k);
    });
    return 1 == h.length ? h[0] : h;
  };
  window.NiceScroll = {
    getjQuery: function() {
      return e;
    },
  };
  e.nicescroll || ((e.nicescroll = new C()), (e.nicescroll.options = F));
})(jQuery);

/*! Copyright (c) 2013 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.1.3
 *
 * Requires: 1.2.2+
 */

(function(factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    // Node/CommonJS style for Browserify
    module.exports = factory;
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function($) {
  var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
  var toBind =
    'onwheel' in document || document.documentMode >= 9
      ? ['wheel']
      : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
  var lowestDelta, lowestDeltaXY;

  if ($.event.fixHooks) {
    for (var i = toFix.length; i; ) {
      $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
    }
  }

  $.event.special.mousewheel = {
    setup: function() {
      if (this.addEventListener) {
        for (var i = toBind.length; i; ) {
          this.addEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = handler;
      }
    },

    teardown: function() {
      if (this.removeEventListener) {
        for (var i = toBind.length; i; ) {
          this.removeEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = null;
      }
    },
  };

  $.fn.extend({
    mousewheel: function(fn) {
      return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
    },

    unmousewheel: function(fn) {
      return this.unbind('mousewheel', fn);
    },
  });

  function handler(event) {
    var orgEvent = event || window.event,
      args = [].slice.call(arguments, 1),
      delta = 0,
      deltaX = 0,
      deltaY = 0,
      absDelta = 0,
      absDeltaXY = 0,
      fn;
    event = $.event.fix(orgEvent);
    event.type = 'mousewheel';

    // Old school scrollwheel delta
    if (orgEvent.wheelDelta) {
      delta = orgEvent.wheelDelta;
    }
    if (orgEvent.detail) {
      delta = orgEvent.detail * -1;
    }

    // New school wheel delta (wheel event)
    if (orgEvent.deltaY) {
      deltaY = orgEvent.deltaY * -1;
      delta = deltaY;
    }
    if (orgEvent.deltaX) {
      deltaX = orgEvent.deltaX;
      delta = deltaX * -1;
    }

    // Webkit
    if (orgEvent.wheelDeltaY !== undefined) {
      deltaY = orgEvent.wheelDeltaY;
    }
    if (orgEvent.wheelDeltaX !== undefined) {
      deltaX = orgEvent.wheelDeltaX * -1;
    }

    // Look for lowest delta to normalize the delta values
    absDelta = Math.abs(delta);
    if (!lowestDelta || absDelta < lowestDelta) {
      lowestDelta = absDelta;
    }
    absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
    if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
      lowestDeltaXY = absDeltaXY;
    }

    // Get a whole value for the deltas
    fn = delta > 0 ? 'floor' : 'ceil';
    delta = Math[fn](delta / lowestDelta);
    deltaX = Math[fn](deltaX / lowestDeltaXY);
    deltaY = Math[fn](deltaY / lowestDeltaXY);

    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);

    return ($.event.dispatch || $.event.handle).apply(this, args);
  }
});

(function(m, j) {
  var d = {},
    e = 1,
    f = m.fn.each,
    k = m.fn.on || m.fn.bind,
    n = m.fn.off || m.fn.unbind,
    l = {};
  function a(p, q) {
    q = m(q);
    q.prevObject = p;
    var o = p.length;
    if (o !== q.length) {
      return q;
    }
    while (o--) {
      if (p[o] !== q[o]) {
        return q;
      }
    }
    return p;
  }
  function c(o) {
    var p = [],
      q = o.length;
    while (q--) {
      p[q] = o[q].g;
    }
    return p;
  }
  function h(p, w, t, s) {
    t = t || [];
    var u = { f: p, i: w },
      q = false,
      o,
      x,
      y;
    function v(A, B) {
      A.e = false;
      function z() {
        A.k = a(A.f, A.k);
        A.e = true;
        r();
      }
      return typeof B.promise == 'function' ? B.promise().then(z) : B.then(z, true);
    }
    function r(A) {
      while (!q) {
        try {
          q = !q;
          if (typeof s == 'function') {
            s(m.makeArray(u.k || u.f));
          }
          if (u.e == false) {
            break;
          }
          if (!u.i.j) {
            if (y && (!t.length || t[0].b)) {
              if (u.f && typeof u.f.promise == 'function') {
                u.f.promise().then(y.resolve);
              } else {
                y.resolveWith(u.f);
              }
              y = null;
            }
            if (!t.length) {
              return u.f;
            }
            x = t[0].l && t[0].l(r, u, t);
            if (!x) {
              break;
            }
            u = x;
            continue;
          }
          o = (u.f && u.f[u.i.j]) || l[u.i.j];
          if (!o) {
            throw 'no such method "' + u.i.j + '" on object (' + u.f + ')';
          }
          if (o.timing && !u.e) {
            u.e = false;
            u = o.timing(r, u, t, s) || u;
          } else {
            if (!o.timing && !u.e) {
              u.k = u.f[u.i.j].apply(u.f, u.i.c);
              if (t.length && u.k && u.k instanceof g) {
                v(u, u.k);
                continue;
              }
            }
            x = { f: u.k, i: u.i.k };
            u.e = false;
            if (typeof u.d == 'function') {
              u.d.apply(u.f, c(t));
            }
            u = x;
          }
        } catch (z) {
          q = !q;
          throw z;
        } finally {
          q = !q;
        }
      }
      return A;
    }
    if (m.Deferred) {
      r.promise = function(A, B) {
        var z = (y = y || m.Deferred()).promise(B);
        r();
        return z;
      };
    }
    return r;
  }
  function g(q, r, p) {
    this['.methods'] = r;
    this['.callback'] = p;
    this.length = 0;
    Array.prototype.push.apply(this, m.makeArray((this._ = q._ = q)));
    for (var o in q) {
      if (!(o in g.prototype) && typeof q[o] == 'function') {
        this[o] = i(o);
      }
    }
  }
  if (m.Deferred) {
    g.prototype.promise = function(o, p) {
      if (typeof o == 'object') {
        p = o;
        o = null;
      }
      return this['.callback'] && typeof this['.callback'].promise == 'function'
        ? this['.callback'].promise(o, p)
        : m
            .Deferred()
            .resolveWith(this)
            .promise(p);
    };
  }
  function i(o) {
    return (g.prototype[o] = function() {
      this['.methods'].j = o;
      this['.methods'].c = arguments;
      this['.methods'] = this['.methods'].k = {};
      return this['.callback'] ? this['.callback'](this, o, arguments) : this;
    });
  }
  m.each(['bind', 'on', 'one', 'live', 'delegate'], function(p, o) {
    if (m.fn[o]) {
      var q = m.fn[o];
      m.fn[o] = function() {
        var u,
          x,
          w,
          s,
          r,
          t = this;
        for (u = 0; u < arguments.length; u++) {
          if (
            typeof arguments[u] == 'function' ||
            (arguments[u] && typeof arguments[u] == 'object') ||
            arguments[u] === false
          ) {
            if (arguments[u] !== m) {
              if (typeof arguments[u] == 'function' && m.guid) {
                arguments[u].guid = arguments[u].guid || m.guid++;
              }
              return q.apply(t, arguments);
            }
            break;
          }
        }
        Array.prototype.splice.call(arguments, u, 1, function() {
          s = h(t.$(this), x, [{ g: m.extend(Array.prototype.shift.apply(arguments), arguments), b: true }], function(
            y
          ) {
            w.length = 0;
            Array.prototype.push.apply(w, y);
          });
          if (r) {
            s.promise().then(r.resolve);
            r = null;
          }
          return s();
        });
        function v() {
          return s ? s(w) : w;
        }
        if (m.Deferred) {
          v.promise = function(y, z) {
            if (typeof y == 'object') {
              z = y;
              y = null;
            }
            return s && !y ? s.promise(y, z) : (r = r || m.Deferred()).promise(z);
          };
        }
        return (w = new g(q.apply(t, arguments), (x = {}), v));
      };
    }
  });
  m.each(['animate', 'load'], function(p, o) {
    if (m.fn[o]) {
      var q = m.fn[o];
      m.fn[o] = function() {
        while (arguments.length && arguments[arguments.length - 1] == null) {
          Array.prototype.pop.apply(arguments);
        }
        if (this.length && arguments.length > 1 && arguments[arguments.length - 1] === m) {
          var r = '_timing' + e++;
          arguments[arguments.length - 1] = function() {
            m(this).trigger(r);
          };
          return this.each()
            .one(r)
            .all(q.apply(this, arguments));
        }
        return q.apply(this, arguments);
      };
    }
  });
  m.each(['wait', 'repeat', 'join', 'then'], function(p, o) {
    m.fn[o] = function() {
      var r = {},
        q = new g(
          this,
          r,
          h(this, r, [], function(s) {
            q.length = 0;
            Array.prototype.push.apply(q, s);
          })
        );
      return q[o].apply(q, arguments);
    };
  });
  m.fn.join.timing = function(p, r) {
    var q,
      o,
      s = r.f.length;
    if (typeof r.i.c[0] == 'string') {
      q = r.i.c[0];
      if (typeof r.i.c[1] == 'function') {
        r.d = r.i.c[1];
      } else {
        o = r.i.c[1];
        r.d = r.i.c[2];
      }
    } else {
      if (typeof r.i.c[0] == 'function') {
        r.d = r.i.c[0];
      } else {
        o = r.i.c[0];
        r.d = r.i.c[1];
      }
    }
    r.k = r.f;
    r.e = !s;
    if (o) {
      r.f.promise(q == null ? 'fx' : q).then(function() {
        r.e = true;
        p();
      });
    } else {
      r.f.queue(q == null ? 'fx' : q, function(t) {
        r.e = !--s;
        p();
        t();
      });
    }
  };
  m.fn.then.timing = function(o, p) {
    p.d = p.i.c[0];
    p.k = p.f;
    p.e = true;
    if (p.i.c[1]) {
      Array.prototype.shift.apply(p.i.c);
    }
  };
  m.fn.wait.timing = function(s, t, u) {
    var r,
      o,
      v,
      p = t.f;
    r = t.i.c[0];
    t.d = t.i.c[1];
    function w() {
      n.call(o ? n.call(p, o, w) : p, 'unwait', q);
      t.e = true;
      t.k = a(t.f, t.k);
      s();
    }
    function q(x, y) {
      n.call(o ? n.call(m(this), o, w) : m(this), 'unwait', q);
      p = p.not(this);
      if (!y) {
        t.k = t.k.not(this);
      }
      if (!p.length) {
        t.e = t.k.length;
        t.k = a(t.f, t.k);
        j.clearTimeout(v);
        t = { f: p };
      }
      s();
    }
    k.call(p, 'unwait', q);
    t.k = p;
    if (r == null || r == m) {
      r = p;
    }
    if (typeof r == 'function') {
      r = r.apply(p, c(u));
    }
    if (typeof r == 'string') {
      k.call(p, (o = r), w);
    } else {
      if (r && typeof r.promise == 'function') {
        r.promise().then(w);
      } else {
        if (r && typeof r.then == 'function') {
          r.then(w, true);
        } else {
          v = j.setTimeout(w, Math.max(0, r));
        }
      }
    }
  };
  m.fn.each = function(q) {
    if (!q || q === m) {
      var p = {},
        o = new g(
          this,
          p,
          h(this, p, [], function(r) {
            o.length = 0;
            Array.prototype.push.apply(o, r);
          })
        );
      return o.each(q);
    }
    return f.apply(this, arguments);
  };
  m.fn.each.timing = function(r, v, w, u) {
    if (v.i.c[0] && v.i.c[0] !== m) {
      v.e = true;
      v.k = f.apply(v.f, v.i.c);
      return;
    }
    var B = Math.max(v.f.length, 1),
      p = 0,
      y,
      s,
      t,
      A = [],
      z = [],
      x = m.extend({}, v.f),
      q = v.i.c[0] === m;
    if (q) {
      j.setTimeout(function() {
        t = true;
        r();
      }, 0);
    }
    function o() {
      if (q) {
        if (p < B) {
          A[p]();
        }
      } else {
        for (var C = 0; C < B; C++) {
          A[C]();
        }
      }
      return x;
    }
    for (y in g.prototype) {
      x[y] = o;
    }
    x.length = B;
    for (y = 0; y < B; y++) {
      (function(C) {
        var E = w.slice(),
          D = v.f.eq(C);
        z[C] = D.get();
        E.unshift({
          g: C,
          a: function(F) {
            p++;
            if (p == B) {
              s = F.i.k;
            }
            r();
          },
          h: l.all,
          l: function(G, F) {
            if (t) {
              p++;
              if (p == B) {
                s = F.i;
              }
              r();
            }
          },
        });
        A[C] = h(D, v.i.k, E, function(G) {
          z[C] = G;
          x.length = 0;
          for (var F = 0; F < B; F++) {
            Array.prototype.push.apply(x, z[F]);
          }
          if (u) {
            u(m.makeArray(x));
          }
        });
      })(y);
    }
    v.k = x;
    v.e = true;
    v.l = function(E, D) {
      if (p == B) {
        w.shift();
        return { f: a(v.f, x), i: s };
      }
      var C = p;
      o();
      if (p != C) {
        return D;
      }
    };
    v.g = B;
    w.unshift(v);
  };
  l.all = function(o) {
    m.extend(o.i, { k: m.extend({}, o.i), j: 'all', c: [] });
    o.e = null;
  };
  l.all.timing = function(o, q, p) {
    if (!p.length || !p[0].h) {
      throw '.all() method must be used after .each() only';
    }
    if (!p[0].a) {
      p[0].h(q);
      return;
    }
    p[0].a(q);
  };
  m.fn.repeat.timing = function(s, v, w) {
    var q, t, u, o, p;
    if (typeof v.i.c[0] == 'function') {
      v.d = v.i.c[0];
    } else {
      if (typeof v.i.c[1] == 'function') {
        q = v.i.c[0];
        v.d = v.i.c[1];
      } else {
        q = v.i.c[0];
        t = v.i.c[1];
        v.d = v.i.c[2];
      }
    }
    function x() {
      v.k = v.k || v.f;
      v.e = true;
      s();
    }
    function r() {
      n.call(o ? n.call(m(this), o, x) : m(this), 'unrepeat', r);
      var y = v.f.not(this);
      v.k = v.k == v.f ? y : v.k;
      v.f = y;
      v.e = v.f.length && v.e;
      q = v.f.length && q;
      j.clearInterval(!v.f.length && p);
      s();
    }
    v.l = function(z, y) {
      if (v.e || u) {
        v.g++;
        v.k = v.k || v.f;
        v.e = v.e || (q && y.f && y.f.length);
        return v;
      }
    };
    if (q == null) {
      t = q = true;
      j.setTimeout(function() {
        u = true;
        s();
      }, 0);
    } else {
      if (typeof q == 'string') {
        k.call(v.f, (o = q), x);
      } else {
        p = j.setInterval(x, Math.max(0, q));
      }
      q = false;
    }
    k.call(v.f, 'unrepeat', r);
    v.k = v.f;
    v.g = 0;
    v.n = function(y) {
      if (y) {
        r.apply(v.f);
      }
      if (q) {
        x();
      }
    };
    v.h = l.until;
    if (t) {
      x();
    }
    w.unshift(v);
  };
  l.until = function(o) {
    m.extend(o.i, { k: m.extend({}, o.i), j: 'until', c: [] });
    o.e = null;
  };
  l.until.timing = function(o, r, q) {
    if (!q.length || !q[0].h) {
      throw '.until() method must be used after .repeat() only';
    }
    if (!q[0].n) {
      q[0].h(r);
      return;
    }
    var s = r.i.c[0],
      p = r.i.c[1];
    if (s === m) {
      s = null;
      p = r.i.c.length <= 1 || p;
    }
    if (typeof s == 'function') {
      s = s.apply(r.f, c(q));
    }
    if (s == null) {
      s = !r.f.size();
    }
    if (typeof s == 'object') {
      s = s.toString();
    }
    if (typeof s == 'number') {
      s = q[0].g >= s - 1;
    }
    if (s) {
      r.e = true;
      r.k = r.f;
      q.shift().n(s);
    } else {
      if (p) {
        q[0].k = r.f;
      }
      r = q[0];
      r.g++;
      r.n(s);
      return r;
    }
  };
  new g(l);
  m.each(['unwait', 'unrepeat'], function(p, o) {
    m.fn[o] = function() {
      return this.trigger(o, arguments);
    };
  });
  m.each(['wait', 'repeat', 'join', 'then', 'unwait', 'unrepeat'], function(p, o) {
    m[o] = function() {
      var q = typeof arguments[0] == 'string' ? Array.prototype.shift.apply(arguments) : '';
      return m.fn[o].apply((d[q] = d[q] || m('<div>').text(q)), arguments);
    };
  });
  function b(r, u, q) {
    if (typeof r == 'string') {
      q = new Function('x', 'return [' + r + '\n,x]');
      r = function(w, v) {
        v = q(w);
        p.x = v[1];
        return v[0];
      };
    }
    var o = typeof u == 'function',
      t = typeof r == 'function',
      p = function(v) {
        if (arguments.length == 1) {
          p.x = v;
          if (o) {
            u(v);
          }
        } else {
          return s();
        }
      };
    function s(v) {
      v = o ? u() : p.x;
      return t ? r(v) : v;
    }
    p.x = 0;
    p._ = { toString: (p.$ = p.toString = s.toString = s) };
    p.mod = function(v) {
      return b(function(w) {
        return w % v;
      }, p);
    };
    p.add = function(v) {
      return b(function(w) {
        return w + v;
      }, p);
    };
    p.neg = function() {
      return b('-x', p);
    };
    p.$$ = p.X = function(v) {
      return b(v, p);
    };
    m.each('abcdefghij', function(v, w) {
      p[v] = p[w] = function() {
        p(arguments[v]);
      };
    });
    return p;
  }
  j.$$ = m.$$ = m.X = b;
  m.fn.$ = function() {
    var o = m.apply(j, arguments);
    o.prevObject = this;
    return o;
  };
})(jQuery, window);

/**
 * jQuery hashchange 1.0.0
 *
 * (based on jquery.history)
 *
 * Copyright (c) 2008 Chris Leishman (chrisleishman.com)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * Modified from original at http://plugins.jquery.com/project/hashchange
 *
 * treyk 06/10/2009 - Added in support for change to address bar in IE
 *                    Also removed live binding to a[href] because it's not needed with
 *                    monitoring for address bar changes in IE.
 *
 * History / hashchange plugin that provides history, hashchange event, and bookmarking for
 * DHTML and Ajax applications
 *
 * This plugin provides onhashchange event notification for browsers that don't yet support
 * this HTML 5 standard.  To get notifications for this event, simply use the provide
 * hashchange function:
 * @codestart
 * $(document).ready(function($) {
 *    $(document.body).hashchange(function() {
 *       alert("Got hashchange event: " + location.hash);
 *    });
 * });
 * @codeend
 *
 * This module needs to be initialized. You have the option of firing an initial hash change
 * event after initialization.  To do this, set the $.History.fireInitialChange variable to
 * true BEFORE calling init.  This variable defaults to <b>true</b>.
 * <b>Note:</b> If you want to get an initally change event, you must first bind to the
 * event before calling the init function.
 * @codestart
 * $(document).ready(function($) {
 *    $.History.fireInitialChange = false;  // Set before calling init function.
 *    $.History.init();
 * });
 * @codeend
 *
 *
 *
 *
 *
 *
 *
 */
(function($) {
  function formatHash(hash) {
    if (!hash) hash = '#';
    else if (hash.charAt(0) != '#') hash = '#' + hash;

    return hash;
  }

  $.fn.extend({
    hashchange: function(callback) {
      return this.bind('hashchange', callback);
    },
    openOnClick: function(href) {
      if (href === undefined || href.length == 0) href = '#';
      return this.click(function(ev) {
        if (href && href.charAt(0) == '#') {
          // execute load in separate call stack
          window.setTimeout(function() {
            $.History.add(href);
          }, 0);
        } else {
          window.location(href);
        }
        ev.stopPropagation();
        return false;
      });
    },
  });

  function isHashchangeEventSupported() {
    var el = window;
    var eventName = 'onhashchange';
    var isSupported = eventName in el;
    if (!isSupported) {
      try {
        el.setAttribute(eventName, 'return;');
        isSupported = typeof el[eventName] == 'function';
      } catch (e) {}
    }
    el = null;
    return isSupported;
  }
  $.support.hashchange = isHashchangeEventSupported();

  // For browsers that support hashchange natively, we don't have to poll for hash changes
  if ($.support.hashchange) {
    $.support.hashchange = true;
    $.extend({
      History: {
        fireInitialChange: true,
        init: function() {
          if ($.History.fireInitialChange) $.event.trigger('hashchange');
        },

        add: function(hash) {
          location.hash = formatHash(hash);
        },

        replace: function(hash) {
          var path = location.href.split('#')[0] + formatHash(hash);
          location.replace(path);
        },
      },
    });
    return;
  }

  var curHash;
  // hidden iframe for IE (earlier than 8)
  var iframe;

  $.extend({
    History: {
      fireInitialChange: true,
      init: function() {
        curHash = location.hash;

        if ($.browser.msie) {
          // stop the callback firing twice during init if no hash present
          if (curHash == '') curHash = '#';
          // add hidden iframe for IE
          iframe = $('<iframe />')
            .hide()
            .get(0);
          $('body').prepend(iframe);
          updateIEFrame(location.hash);
          setInterval(checkHashIE, 100);
        } else if (!$.browser.rhino) setInterval(checkHash, 100); //id like this to wait for load

        if ($.History.fireInitialChange) $.event.trigger('hashchange');
      },

      add: function(hash) {
        if (curHash === undefined) return;

        location.hash = formatHash(hash);

        //if (curHash == hash)  let it detect this itself because location.hash might not equal hash
        //   return;
        //curHash = hash;

        //if ($.browser.msie)
        //   updateIEFrame(hash);

        //$.event.trigger('hashchange');  Removed,
      },

      replace: function(hash) {
        var path = location.href.split('#')[0] + formatHash(hash);
        location.replace(path);
      },
    },
  });
  /*
$(document).ready(function() {
   $.History.init();
});
*/
  $(window).unload(function() {
    iframe = null;
  });

  function checkHash() {
    var hash = location.hash;
    if (hash != curHash) {
      curHash = hash;
      $.event.trigger('hashchange');
    }
  }
  /*  
function hasNamedAnchor(hash) {
   return ($(hash).length > 0 || $('a[name='+hash.slice(1)+']').length > 0);
}

if ($.browser.msie) {
    // Attach a live handler for any anchor links
//orig    $('a[href^=#]').live('click', function() {
    $("a[href*='#']").live('click', function() {
        var hash = $(this).attr('href');
        var poundIndex = hash.indexOf('#');
        if(poundIndex > 0)
           hash = hash.substring(poundIndex);
        // Don't intercept the click if there is an existing anchor on the page
        // that matches this hash
        if ( !hasNamedAnchor(hash) ) {
            $.History.add(hash);
            return false;
        }
    });
}
*/
  function checkHashIE() {
    /* First, check for address bar change */
    var hash = location.hash;
    if (hash != curHash) {
      updateIEFrame(hash);
      curHash = hash;
      $.event.trigger('hashchange');
      return;
    }

    // Now check for back/forward button
    // On IE, check for location.hash of iframe
    var idoc = iframe.contentDocument || iframe.contentWindow.document;
    var hash = idoc.location.hash;
    if (hash == '') hash = '#';

    if (hash != curHash) {
      if (location.hash != hash) location.hash = hash;
      curHash = hash;
      $.event.trigger('hashchange');
    }
  }

  function updateIEFrame(hash) {
    if (hash == '#') hash = '';
    var idoc = iframe.contentDocument || iframe.contentWindow.document;
    idoc.open();
    idoc.close();
    if (idoc.location.hash != hash) idoc.location.hash = hash;
  }
})(jQuery);

/*!
 * jQuery Cookie Plugin v1.3
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document, undefined) {
  var pluses = /\+/g;

  function raw(s) {
    return s;
  }

  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  var config = ($.cookie = function(key, value, options) {
    // write
    if (value !== undefined) {
      options = $.extend({}, config.defaults, options);

      if (value === null) {
        options.expires = -1;
      }

      if (typeof options.expires === 'number') {
        var days = options.expires,
          t = (options.expires = new Date());
        t.setDate(t.getDate() + days);
      }

      value = config.json ? JSON.stringify(value) : String(value);

      return (document.cookie = [
        encodeURIComponent(key),
        '=',
        config.raw ? value : encodeURIComponent(value),
        options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
        options.path ? '; path=' + options.path : '',
        options.domain ? '; domain=' + options.domain : '',
        options.secure ? '; secure' : '',
      ].join(''));
    }

    // read
    var decode = config.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, l = cookies.length; i < l; i++) {
      var parts = cookies[i].split('=');
      if (decode(parts.shift()) === key) {
        var cookie = decode(parts.join('='));
        return config.json ? JSON.parse(cookie) : cookie;
      }
    }

    return null;
  });

  config.defaults = {};

  $.removeCookie = function(key, options) {
    if ($.cookie(key) !== null) {
      $.cookie(key, null, options);
      return true;
    }
    return false;
  };
})(jQuery, document);

/*! Nestoria Slider - v1.0.13 - 2015-07-16
 * http://lokku.github.io/jquery-nstslider/
 * Copyright (c) 2015 Lokku Ltd.; Licensed MIT */
!(function(a) {
  var b,
    c,
    d,
    e,
    f,
    g,
    h,
    i,
    j,
    k = {
      setNakedBarDelta: function(a, b) {
        if ('stickToSides' === a) j = { toEndWidth: b, toBeginLeft: 0, toBeginWidth: b };
        else {
          if ('middle' !== a) throw new Error('unknown position of setNakedBarDelta: ' + a);
          j = { toEndWidth: b / 2, toBeginLeft: b / 2, toBeginWidth: b / 2 };
        }
      },
      getSliderValuesAtPositionPx: function(a, b) {
        var c,
          d,
          e = this,
          f = e.data('pixel_to_value_mapping');
        if ('undefined' != typeof f) (c = f(a)), (d = f(b));
        else {
          var g = k.getSliderWidthPx.call(e) - e.data('left_grip_width');
          (c = k.inverse_rangemap_0_to_n.call(e, a, g)), (d = k.inverse_rangemap_0_to_n.call(e, b, g));
        }
        return [c, d];
      },
      validateAndMoveGripsToPx: function(a, b) {
        var c = this,
          d = k.getSliderWidthPx.call(c) - c.data('left_grip_width');
        if (d >= b && a >= 0 && d >= a && (!c.data('has_right_grip') || b >= a)) {
          var e = c.data('cur_min'),
            f = c.data('cur_max');
          k.set_position_from_px.call(c, a, b),
            k.refresh_grips_style.call(c),
            k.notify_changed_implicit.call(c, 'drag_move', e, f);
        }
        return c;
      },
      updateAriaAttributes: function() {
        var a = this,
          b = a.data('settings'),
          c = a.find(b.left_grip_selector);
        if (a.data('has_right_grip')) {
          var d = a.find(b.right_grip_selector);
          c
            .attr('aria-valuemin', a.data('range_min'))
            .attr('aria-valuenow', l.get_current_min_value.call(a))
            .attr('aria-valuemax', l.get_current_max_value.call(a)),
            d
              .attr('aria-valuemin', l.get_current_min_value.call(a))
              .attr('aria-valuenow', l.get_current_max_value.call(a))
              .attr('aria-valuemax', a.data('range_max'));
        } else
          c.attr('aria-valuemin', a.data('range_min'))
            .attr('aria-valuenow', l.get_current_min_value.call(a))
            .attr('aria-valuemax', a.data('range_max'));
        return a;
      },
      getSliderWidthPx: function() {
        var a = this;
        return Math.round(a.width());
      },
      getGripPositionPx: function(a) {
        return parseInt(a.css('left').replace('px', ''), 10);
      },
      getLeftGripPositionPx: function() {
        var a = this,
          b = a.data('settings'),
          c = a.find(b.left_grip_selector);
        return k.getGripPositionPx.call(a, c);
      },
      getRightGripPositionPx: function() {
        var a = this,
          b = a.data('settings');
        if (a.data('has_right_grip')) return k.getGripPositionPx.call(a, a.find(b.right_grip_selector));
        var c = k.getSliderWidthPx.call(a) - a.data('left_grip_width');
        return k.rangemap_0_to_n.call(a, a.data('cur_max'), c);
      },
      getLeftGripWidth: function() {
        var a = this,
          b = a.data('settings'),
          c = a.find(b.left_grip_selector);
        return Math.round(c.outerWidth());
      },
      getRightGripWidth: function() {
        var a = this,
          b = a.data('settings'),
          c = a.find(b.right_grip_selector);
        return Math.round(c.outerWidth());
      },
      binarySearchValueToPxCompareFunc: function(b, c, d) {
        return b === c[d]
          ? 0
          : b < c[d] && 0 === d
          ? 0
          : c[d - 1] <= b && b < c[d]
          ? 0
          : b > c[d]
          ? 1
          : b <= c[d - 1]
          ? -1
          : void a.error('cannot compare s: ' + b + ' with a[' + d + ']. a is: ' + c.join(','));
      },
      binarySearch: function(a, b, c, d) {
        for (var e, f, g = 0, h = a.length - 1; h >= g; ) {
          (e = ((g + h) / 2) | 0), (f = c(a, e));
          var i = d(b, a, e);
          if (i > 0) g = e + 1;
          else {
            if (!(0 > i)) return e;
            h = e - 1;
          }
        }
        return -1;
      },
      haveLimits: function() {
        var a = this,
          b = a.data('lower-limit'),
          c = a.data('upper-limit'),
          d = !1;
        return 'undefined' != typeof b && 'undefined' != typeof c && (d = !0), d;
      },
      refresh_grips_style: function() {
        var a = this,
          b = a.data('settings');
        if ('undefined' != typeof b.highlight) {
          var c = a.data('highlightedRangeMin');
          if ('undefined' != typeof c) {
            var d = a.find(b.left_grip_selector),
              e = a.find(b.right_grip_selector),
              f = a.data('highlightedRangeMax'),
              g = a.data('cur_min'),
              h = a.data('cur_max'),
              i = b.highlight.grip_class;
            c > g || g > f ? d.removeClass(i) : d.addClass(i), c > h || h > f ? e.removeClass(i) : e.addClass(i);
          }
        }
      },
      set_position_from_val: function(a, b) {
        var c = this,
          d = c.data('range_min'),
          e = c.data('range_max');
        d > a && (a = d),
          a > e && (a = e),
          c.data('has_right_grip') ? (b > e && (b = e), d > b && (b = d)) : (b = c.data('cur_max'));
        var f = l.value_to_px.call(c, a),
          g = l.value_to_px.call(c, b);
        return (
          k.set_handles_at_px.call(c, f, g), c.data('cur_min', a), c.data('has_right_grip') && c.data('cur_max', b), c
        );
      },
      set_position_from_px: function(a, b) {
        var c = this;
        k.set_handles_at_px.call(c, a, b);
        var d = k.getSliderValuesAtPositionPx.call(c, a, b),
          e = d[0],
          f = d[1];
        return c.data('cur_min', e), c.data('has_right_grip') && c.data('cur_max', f), c;
      },
      set_handles_at_px: function(a, b) {
        var c = this,
          d = c.data('settings'),
          e = d.left_grip_selector,
          f = d.right_grip_selector,
          g = d.value_bar_selector,
          h = c.data('left_grip_width');
        return (
          c.find(e).css('left', a + 'px'),
          c.find(f).css('left', b + 'px'),
          c.data('has_right_grip')
            ? c
                .find(g)
                .css('left', a + 'px')
                .css('width', b - a + h + 'px')
            : (j || k.populateNakedBarDeltas.call(c, a, b, h),
              b > a
                ? c
                    .find(g)
                    .css('left', a + 'px')
                    .css('width', b - a + j.toEndWidth + 'px')
                : c
                    .find(g)
                    .css('left', b + j.toBeginLeft + 'px')
                    .css('width', a - b + j.toBeginWidth + 'px')),
          c
        );
      },
      drag_start_func_touch: function(a, b, c, e, f) {
        var g = this,
          h = a.originalEvent,
          i = h.touches[0],
          j = i.pageY,
          l = i.pageX,
          m = Math.abs(g.offset().top - j),
          n = g.offset().left,
          o = n - l,
          p = l - (n + g.width());
        m > b.touch_tolerance_value_bar_y ||
          o > b.touch_tolerance_value_bar_x ||
          p > b.touch_tolerance_value_bar_x ||
          (h.preventDefault(), (d = i.pageX), k.drag_start_func.call(g, i, b, c, e, f));
      },
      drag_start_func: function(d, f, g, h, i) {
        var j = this;
        if (
          (j
            .find(f.left_grip_selector + ',' + f.value_bar_selector + ',' + f.right_grip_selector)
            .removeClass(f.animating_css_class),
          l.is_enabled.call(j))
        ) {
          var m = a(d.target),
            n = !1;
          if (
            ('object' == typeof f.highlight && (n = m.is(f.highlight.panel_selector)),
            i !== !1 ||
              m.is(f.left_grip_selector) ||
              m.is(f.right_grip_selector) ||
              m.is(f.value_bar_selector) ||
              n ||
              m.is(j))
          ) {
            b = j;
            var o,
              p,
              q,
              r,
              s,
              t,
              u = k.getGripPositionPx.call(j, g),
              v = k.getSliderWidthPx.call(j) - j.data('left_grip_width'),
              w = g.offset().left,
              x = k.getRightGripPositionPx.call(j);
            (p = Math.round(d.pageX) - j.data('left_grip_width') / 2),
              (q = Math.abs(w - p)),
              (s = p - w),
              j.data('has_right_grip')
                ? ((o = h.offset().left), (r = Math.abs(o - p)), (t = p - o))
                : ((r = 2 * q), (t = 2 * s)),
              f.user_drag_start_callback.call(j, d),
              q === r
                ? w > p
                  ? ((u += s), (e = !0))
                  : ((x += t), (e = !1))
                : r > q
                ? ((u += s), (e = !0))
                : ((x += t), (e = !1)),
              j.data('has_right_grip') ? x > v && (x = v) : u > v && (u = v),
              0 > u && (u = 0),
              (c = !0);
            var y = j.data('cur_min'),
              z = j.data('cur_max');
            k.set_position_from_px.call(j, u, x),
              k.refresh_grips_style.call(j),
              k.notify_changed_implicit.call(j, 'drag_start', y, z),
              '[object Touch]' !== Object.prototype.toString.apply(d) && d.preventDefault();
          }
        }
      },
      drag_move_func_touch: function(a) {
        if (c === !0) {
          var b = a.originalEvent;
          b.preventDefault();
          var d = b.touches[0];
          k.drag_move_func(d);
        }
      },
      drag_move_func: function(a) {
        if (c) {
          var f = b,
            g = f.data('settings'),
            h = k.getSliderWidthPx.call(f) - f.data('left_grip_width'),
            i = k.getLeftGripPositionPx.call(f),
            j = k.getRightGripPositionPx.call(f),
            l = Math.round(a.pageX),
            m = l - d,
            n = f.data('left_grip_width') / 2,
            o = f.offset().left + f.data('left_grip_width') - n,
            p = o + h;
          g.crossable_handles === !1 && f.data('has_right_grip') && (e ? (p = o + j) : (o += i));
          var q = 0,
            r = 0;
          o > l && ((q = 1), (r = 0)),
            l > p && ((r = 1), (q = 0)),
            g.crossable_handles === !0 &&
              f.data('has_right_grip') &&
              (e ? h >= j && i + m > j && ((e = !1), (i = j)) : i >= 0 && i > j + m && ((e = !0), (j = i)));
          var s = i,
            t = j;
          ((m > 0 && !q) || (0 > m && !r)) && (e ? (s += m) : (t += m)),
            k.validateAndMoveGripsToPx.call(f, s, t),
            (d = l),
            '[object Touch]' !== Object.prototype.toString.apply(a) && a.preventDefault();
        }
      },
      drag_end_func_touch: function(a) {
        var b = a.originalEvent;
        b.preventDefault();
        var c = b.touches[0];
        k.drag_end_func(c);
      },
      drag_end_func: function() {
        var a = b;
        if ('undefined' != typeof a) {
          (c = !1), (d = void 0), k.notify_mouse_up_implicit.call(a, e), (b = void 0);
          var f = a.data('settings');
          a.find(f.left_grip_selector + ',' + f.value_bar_selector + ',' + f.right_grip_selector).addClass(
            f.animating_css_class
          );
        }
      },
      get_rounding_for_value: function(a) {
        var b = this,
          c = b.data('rounding'),
          d = b.data('rounding_ranges');
        if ('object' == typeof d) {
          var e = k.binarySearch.call(
            b,
            d,
            a,
            function(a, b) {
              return a[b].range;
            },
            function(a, b, c) {
              return a < b[c].range ? (c > 0 ? (a >= b[c - 1].range ? 0 : -1) : 0) : 1;
            }
          );
          if (((c = 1), e > -1)) c = parseInt(d[e].value, 10);
          else {
            var f = d.length - 1;
            a >= d[f].range && (c = d[f].value);
          }
        }
        return c;
      },
      notify_mouse_up_implicit: function(a) {
        var b = this,
          c = l.get_current_min_value.call(b),
          d = l.get_current_max_value.call(b),
          e = !1;
        (b.data('beforestart_min') !== c || b.data('beforestart_max') !== d) &&
          ((e = !0), b.data('beforestart_min', c), b.data('beforestart_max', d));
        var f = b.data('settings');
        return (
          f.user_mouseup_callback.call(b, l.get_current_min_value.call(b), l.get_current_max_value.call(b), a, e), b
        );
      },
      notify_changed_implicit: function(a, b, c) {
        var d = this,
          e = !1;
        ('init' === a || 'refresh' === a) && (e = !0);
        var f = l.get_current_min_value.call(d),
          g = l.get_current_max_value.call(d);
        return (
          e ||
            ((b = l.round_value_according_to_rounding.call(d, b)),
            (c = l.round_value_according_to_rounding.call(d, c))),
          (e || f !== b || g !== c) && (k.notify_changed_explicit.call(d, a, b, c, f, g), (e = 1)),
          e
        );
      },
      notify_changed_explicit: function(a, b, c, d, e) {
        var f = this,
          g = f.data('settings');
        return (
          f.data('aria_enabled') && k.updateAriaAttributes.call(f), g.value_changed_callback.call(f, a, d, e, b, c), f
        );
      },
      validate_params: function(b) {
        var c = this,
          d = c.data('range_min'),
          e = c.data('range_max'),
          f = c.data('cur_min'),
          g = c.data('lower-limit'),
          h = c.data('upper-limit'),
          i = k.haveLimits.call(c);
        'undefined' == typeof d && a.error('the data-range_min attribute was not defined'),
          'undefined' == typeof e && a.error('the data-range_max attribute was not defined'),
          'undefined' == typeof f && a.error('the data-cur_min attribute must be defined'),
          d > e && a.error('Invalid input parameter. must be min < max'),
          i && g > h && a.error('Invalid data-lower-limit or data-upper-limit'),
          0 === c.find(b.left_grip_selector).length &&
            a.error('Cannot find element pointed by left_grip_selector: ' + b.left_grip_selector),
          'undefined' != typeof b.right_grip_selector &&
            0 === c.find(b.right_grip_selector).length &&
            a.error('Cannot find element pointed by right_grip_selector: ' + b.right_grip_selector),
          'undefined' != typeof b.value_bar_selector &&
            0 === c.find(b.value_bar_selector).length &&
            a.error('Cannot find element pointed by value_bar_selector' + b.value_bar_selector);
      },
      rangemap_0_to_n: function(a, b) {
        var c = this,
          d = c.data('range_min'),
          e = c.data('range_max');
        return d >= a ? 0 : a >= e ? b : Math.floor((b * a - b * d) / (e - d));
      },
      inverse_rangemap_0_to_n: function(a, b) {
        var c = this,
          d = c.data('range_min'),
          e = c.data('range_max');
        if (0 >= a) return d;
        if (a >= b) return e;
        var f = ((e - d) * a) / b;
        return f + d;
      },
    },
    l = {
      teardown: function() {
        var b = this;
        return (
          b.removeData(),
          a(document)
            .unbind('mousemove.nstSlider')
            .unbind('mouseup.nstSlider'),
          b
            .parent()
            .unbind('mousedown.nstSlider')
            .unbind('touchstart.nstSlider')
            .unbind('touchmove.nstSlider')
            .unbind('touchend.nstSlider'),
          b.unbind('keydown.nstSlider').unbind('keyup.nstSlider'),
          b
        );
      },
      init: function(b) {
        var c = a.extend(
            {
              animating_css_class: 'nst-animating',
              touch_tolerance_value_bar_y: 30,
              touch_tolerance_value_bar_x: 15,
              left_grip_selector: '.nst-slider-grip-left',
              right_grip_selector: void 0,
              highlight: void 0,
              rounding: void 0,
              value_bar_selector: void 0,
              crossable_handles: !0,
              value_changed_callback: function() {},
              user_mouseup_callback: function() {},
              user_drag_start_callback: function() {},
            },
            b
          ),
          d = a(document);
        return (
          d.unbind('mouseup.nstSlider'),
          d.unbind('mousemove.nstSlider'),
          d.bind('mousemove.nstSlider', k.drag_move_func),
          d.bind('mouseup.nstSlider', k.drag_end_func),
          this.each(function() {
            var b = a(this),
              d = b.parent();
            b.data('enabled', !0);
            var j = b.data('range_min'),
              m = b.data('range_max'),
              n = b.data('cur_min'),
              o = b.data('cur_max');
            'undefined' == typeof o && (o = n),
              '' === j && (j = 0),
              '' === m && (m = 0),
              '' === n && (n = 0),
              '' === o && (o = 0),
              b.data('range_min', j),
              b.data('range_max', m),
              b.data('cur_min', n),
              b.data('cur_max', o),
              k.validate_params.call(b, c),
              b.data('settings', c),
              'undefined' != typeof c.rounding
                ? l.set_rounding.call(b, c.rounding)
                : 'undefined' != typeof b.data('rounding')
                ? l.set_rounding.call(b, b.data('rounding'))
                : l.set_rounding.call(b, 1);
            var p = b.find(c.left_grip_selector)[0],
              q = a(p),
              r = a(b.find(c.right_grip_selector)[0]);
            'undefined' == typeof q.attr('tabindex') && q.attr('tabindex', 0);
            var s = !1;
            b.find(c.right_grip_selector).length > 0 &&
              ((s = !0), 'undefined' == typeof r.attr('tabindex') && r.attr('tabindex', 0)),
              b.data('has_right_grip', s),
              b.data('aria_enabled') === !0 &&
                (q.attr('role', 'slider').attr('aria-disabled', 'false'),
                s && r.attr('role', 'slider').attr('aria-disabled', 'false')),
              b.bind('keyup.nstSlider', function(a) {
                if (b.data('enabled')) {
                  switch (a.which) {
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                      if (f === h) {
                        var c,
                          d,
                          j,
                          m = k.getSliderWidthPx.call(b);
                        if (0 > g - i) {
                          for (d = i; m >= d; d++)
                            if (
                              ((c = l.round_value_according_to_rounding.call(
                                b,
                                k.getSliderValuesAtPositionPx.call(b, d, d)[1]
                              )),
                              c !== h)
                            ) {
                              j = d;
                              break;
                            }
                        } else
                          for (d = i; d >= 0; d--)
                            if (
                              ((c = l.round_value_according_to_rounding.call(
                                b,
                                k.getSliderValuesAtPositionPx.call(b, d, d)[1]
                              )),
                              c !== h)
                            ) {
                              j = d;
                              break;
                            }
                        e
                          ? k.validateAndMoveGripsToPx.call(b, j, k.getRightGripPositionPx.call(b))
                          : k.validateAndMoveGripsToPx.call(b, k.getLeftGripPositionPx.call(b), j),
                          k.notify_mouse_up_implicit.call(b, e);
                      }
                  }
                  (f = void 0), (g = void 0), (h = void 0), (i = void 0);
                }
              }),
              b.bind('keydown.nstSlider', function(a) {
                if (b.data('enabled')) {
                  var c = function(a, c) {
                    var d = k.getLeftGripPositionPx.call(b),
                      j = k.getRightGripPositionPx.call(b);
                    switch (
                      ('undefined' == typeof f &&
                        ((g = e ? d : j), (f = e ? l.get_current_min_value.call(b) : l.get_current_max_value.call(b))),
                      c.which)
                    ) {
                      case 37:
                      case 40:
                        e ? d-- : j--, c.preventDefault();
                        break;
                      case 38:
                      case 39:
                        e ? d++ : j++, c.preventDefault();
                    }
                    (i = e ? d : j),
                      k.validateAndMoveGripsToPx.call(b, d, j),
                      (h = e ? l.get_current_min_value.call(b) : l.get_current_max_value.call(b));
                  };
                  s && b.find(':focus').is(r) ? ((e = !1), c.call(b, r, a)) : ((e = !0), c.call(b, q, a));
                }
              });
            var t = k.getLeftGripWidth.call(b),
              u = s ? k.getRightGripWidth.call(b) : t;
            if (
              (b.data('left_grip_width', t),
              b.data('right_grip_width', u),
              b.data('value_bar_selector', c.value_bar_selector),
              !s)
            ) {
              var v = o === m || o === j;
              k.setNakedBarDelta.call(b, v ? 'stickToSides' : 'middle', t);
            }
            j === m || n === o
              ? l.set_range.call(b, j, m)
              : k.set_position_from_val.call(b, b.data('cur_min'), b.data('cur_max')),
              k.notify_changed_implicit.call(b, 'init'),
              b.data('beforestart_min', l.get_current_min_value.call(b)),
              b.data('beforestart_max', l.get_current_max_value.call(b)),
              b.bind('mousedown.nstSlider', function(a) {
                k.drag_start_func.call(b, a, c, q, r, !1);
              }),
              d.bind('touchstart.nstSlider', function(a) {
                k.drag_start_func_touch.call(b, a, c, q, r, !0);
              }),
              d.bind('touchend.nstSlider', function(a) {
                k.drag_end_func_touch.call(b, a);
              }),
              d.bind('touchmove.nstSlider', function(a) {
                k.drag_move_func_touch.call(b, a);
              });
            var w = b.data('histogram');
            'undefined' != typeof w && l.set_step_histogram.call(b, w);
          })
        );
      },
      get_range_min: function() {
        var a = this;
        return a.data('range_min');
      },
      get_range_max: function() {
        var a = this;
        return a.data('range_max');
      },
      get_current_min_value: function() {
        var b,
          c = a(this),
          d = l.get_range_min.call(c),
          e = l.get_range_max.call(c),
          f = c.data('cur_min');
        if (((b = d >= f ? d : l.round_value_according_to_rounding.call(c, f)), k.haveLimits.call(c))) {
          if (d >= b) return c.data('lower-limit');
          if (b >= e) return c.data('upper-limit');
        } else {
          if (d >= b) return d;
          if (b >= e) return e;
        }
        return b;
      },
      get_current_max_value: function() {
        var b,
          c = a(this),
          d = l.get_range_min.call(c),
          e = l.get_range_max.call(c),
          f = c.data('cur_max');
        if (((b = f >= e ? e : l.round_value_according_to_rounding.call(c, f)), k.haveLimits.call(c))) {
          if (b >= e) return c.data('upper-limit');
          if (d >= b) return c.data('lower-limit');
        } else {
          if (b >= e) return e;
          if (d >= b) return d;
        }
        return b;
      },
      is_handle_to_left_extreme: function() {
        var a = this;
        return k.haveLimits.call(a)
          ? a.data('lower-limit') === l.get_current_min_value.call(a)
          : l.get_range_min.call(a) === l.get_current_min_value.call(a);
      },
      is_handle_to_right_extreme: function() {
        var a = this;
        return k.haveLimits.call(a)
          ? a.data('upper-limit') === l.get_current_max_value.call(a)
          : l.get_range_max.call(a) === l.get_current_max_value.call(a);
      },
      refresh: function() {
        var a = this,
          b = a.data('last_step_histogram');
        'undefined' != typeof b && l.set_step_histogram.call(a, b),
          k.set_position_from_val.call(a, l.get_current_min_value.call(a), l.get_current_max_value.call(a));
        var c = a.data('highlightedRangeMin');
        if ('number' == typeof c) {
          var d = a.data('highlightedRangeMax');
          l.highlight_range.call(a, c, d);
        }
        return k.notify_changed_implicit.call(a, 'refresh'), a;
      },
      disable: function() {
        var a = this,
          b = a.data('settings');
        return (
          a
            .data('enabled', !1)
            .find(b.left_grip_selector)
            .attr('aria-disabled', 'true')
            .end()
            .find(b.right_grip_selector)
            .attr('aria-disabled', 'true'),
          a
        );
      },
      enable: function() {
        var a = this,
          b = a.data('settings');
        return (
          a
            .data('enabled', !0)
            .find(b.left_grip_selector)
            .attr('aria-disabled', 'false')
            .end()
            .find(b.right_grip_selector)
            .attr('aria-disabled', 'false'),
          a
        );
      },
      is_enabled: function() {
        var a = this;
        return a.data('enabled');
      },
      set_position: function(a, b) {
        var c = this,
          d = c.data('cur_min'),
          e = c.data('cur_max');
        a > b ? k.set_position_from_val.call(c, b, a) : k.set_position_from_val.call(c, a, b),
          k.refresh_grips_style.call(c),
          k.notify_changed_implicit.call(c, 'set_position', d, e),
          c.data('beforestart_min', a),
          c.data('beforestart_max', b);
      },
      set_step_histogram: function(b) {
        var c = this;
        c.data('last_step_histogram', b),
          'undefined' == typeof b &&
            (a.error('got an undefined histogram in set_step_histogram'), k.unset_step_histogram.call(c));
        var d = k.getSliderWidthPx.call(c) - c.data('left_grip_width'),
          e = b.length;
        if (!(0 >= d)) {
          var f,
            g = 0;
          for (f = 0; e > f; f++) g += b[f];
          if (0 === g) return l.unset_step_histogram.call(c), c;
          var h = parseFloat(g) / d;
          for (f = 0; e > f; f++) b[f] = b[f] / h;
          var i = [b[0]];
          for (f = 1; e > f; f++) {
            var j = i[f - 1] + b[f];
            i.push(j);
          }
          i.push(d);
          for (var m = [c.data('range_min')], n = 0, o = m[0], p = 0; d >= n; ) {
            var q = parseInt(i.shift(), 10),
              r = k.inverse_rangemap_0_to_n.call(c, p + 1, e + 1);
            p++;
            var s = q - n,
              t = r - o;
            for (f = n; q > f; f++) {
              var u = o + (t * (f - n + 1)) / s;
              m.push(u), n++, (o = u);
            }
            if (n === d) break;
          }
          m[m.length - 1] = c.data('range_max');
          var v = function(a) {
              return m[parseInt(a, 10)];
            },
            w = function(a) {
              var b = k.binarySearch.call(
                c,
                m,
                a,
                function(a, b) {
                  return a[b];
                },
                k.binarySearchValueToPxCompareFunc
              );
              return m[b] === a ? b : Math.abs(m[b - 1] - a) < Math.abs(m[b] - a) ? b - 1 : b;
            };
          return c.data('pixel_to_value_mapping', v), c.data('value_to_pixel_mapping', w), c;
        }
      },
      unset_step_histogram: function() {
        var a = this;
        return (
          a.removeData('pixel_to_value_mapping'),
          a.removeData('value_to_pixel_mapping'),
          a.removeData('last_step_histogram'),
          a
        );
      },
      set_range: function(a, b) {
        var c = this,
          d = l.get_current_min_value.call(c),
          e = l.get_current_max_value.call(c);
        return (
          c.data('range_min', a),
          c.data('range_max', b),
          k.set_position_from_val.call(c, d, e),
          k.notify_changed_implicit.call(c, 'set_range', d, e),
          c
        );
      },
      highlight_range: function(b, c) {
        var d = this,
          e = d.data('settings');
        'undefined' == typeof e.highlight &&
          a.error(
            'you cannot call highlight_range if you haven\' specified the "highlight" parameter in construction!'
          ),
          b || (b = 0),
          c || (c = 0);
        var f = l.value_to_px.call(d, b),
          g = l.value_to_px.call(d, c),
          h = g - f + d.data('left_grip_width'),
          i = d.find(e.highlight.panel_selector);
        return (
          i.css('left', f + 'px'),
          i.css('width', h + 'px'),
          d.data('highlightedRangeMin', b),
          d.data('highlightedRangeMax', c),
          k.refresh_grips_style.call(d),
          d
        );
      },
      set_rounding: function(b) {
        var c = this;
        'string' == typeof b && b.indexOf('{') > -1 && (b = a.parseJSON(b)), c.data('rounding', b);
        var d = [];
        if ('object' == typeof b) {
          var e;
          for (e in b)
            if (b.hasOwnProperty(e)) {
              var f = b[e];
              d.push({ range: f, value: e });
            }
          d.sort(function(a, b) {
            return a.range - b.range;
          }),
            c.data('rounding_ranges', d);
        } else c.removeData('rounding_ranges');
        return c;
      },
      get_rounding: function() {
        var a = this;
        return a.data('rounding');
      },
      round_value_according_to_rounding: function(b) {
        var c = this,
          d = k.get_rounding_for_value.call(c, b);
        if (d > 0) {
          var e = b / d,
            f = parseInt(e, 10),
            g = e - f;
          g > 0.5 && f++;
          var h = f * d;
          return h;
        }
        return a.error('rounding must be > 0, got ' + d + ' instead'), b;
      },
      value_to_px: function(a) {
        var b = this,
          c = b.data('value_to_pixel_mapping');
        if ('undefined' != typeof c) return c(a);
        var d = k.getSliderWidthPx.call(b) - b.data('left_grip_width');
        return k.rangemap_0_to_n.call(b, a, d);
      },
    },
    m = 'nstSlider';
  a.fn[m] = function(b) {
    if (l[b]) {
      if (this.data('initialized') === !0) return l[b].apply(this, Array.prototype.slice.call(arguments, 1));
      throw new Error('method ' + b + ' called on an uninitialized instance of ' + m);
    }
    return 'object' != typeof b && b
      ? void a.error('Cannot call method ' + b)
      : (this.data('initialized', !0), l.init.apply(this, arguments));
  };
})(jQuery);

/* == jquery mousewheel plugin == Version: 3.1.13, License: MIT License (MIT) */
!(function(a) {
  'function' == typeof define && define.amd
    ? define(['jquery'], a)
    : 'object' == typeof exports
    ? (module.exports = a)
    : a(jQuery);
})(function(a) {
  function b(b) {
    var g = b || window.event,
      h = i.call(arguments, 1),
      j = 0,
      l = 0,
      m = 0,
      n = 0,
      o = 0,
      p = 0;
    if (
      ((b = a.event.fix(g)),
      (b.type = 'mousewheel'),
      'detail' in g && (m = -1 * g.detail),
      'wheelDelta' in g && (m = g.wheelDelta),
      'wheelDeltaY' in g && (m = g.wheelDeltaY),
      'wheelDeltaX' in g && (l = -1 * g.wheelDeltaX),
      'axis' in g && g.axis === g.HORIZONTAL_AXIS && ((l = -1 * m), (m = 0)),
      (j = 0 === m ? l : m),
      'deltaY' in g && ((m = -1 * g.deltaY), (j = m)),
      'deltaX' in g && ((l = g.deltaX), 0 === m && (j = -1 * l)),
      0 !== m || 0 !== l)
    ) {
      if (1 === g.deltaMode) {
        var q = a.data(this, 'mousewheel-line-height');
        (j *= q), (m *= q), (l *= q);
      } else if (2 === g.deltaMode) {
        var r = a.data(this, 'mousewheel-page-height');
        (j *= r), (m *= r), (l *= r);
      }
      if (
        ((n = Math.max(Math.abs(m), Math.abs(l))),
        (!f || f > n) && ((f = n), d(g, n) && (f /= 40)),
        d(g, n) && ((j /= 40), (l /= 40), (m /= 40)),
        (j = Math[j >= 1 ? 'floor' : 'ceil'](j / f)),
        (l = Math[l >= 1 ? 'floor' : 'ceil'](l / f)),
        (m = Math[m >= 1 ? 'floor' : 'ceil'](m / f)),
        k.settings.normalizeOffset && this.getBoundingClientRect)
      ) {
        var s = this.getBoundingClientRect();
        (o = b.clientX - s.left), (p = b.clientY - s.top);
      }
      return (
        (b.deltaX = l),
        (b.deltaY = m),
        (b.deltaFactor = f),
        (b.offsetX = o),
        (b.offsetY = p),
        (b.deltaMode = 0),
        h.unshift(b, j, l, m),
        e && clearTimeout(e),
        (e = setTimeout(c, 200)),
        (a.event.dispatch || a.event.handle).apply(this, h)
      );
    }
  }
  function c() {
    f = null;
  }
  function d(a, b) {
    return k.settings.adjustOldDeltas && 'mousewheel' === a.type && b % 120 === 0;
  }
  var e,
    f,
    g = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
    h =
      'onwheel' in document || document.documentMode >= 9
        ? ['wheel']
        : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
    i = Array.prototype.slice;
  if (a.event.fixHooks) for (var j = g.length; j; ) a.event.fixHooks[g[--j]] = a.event.mouseHooks;
  var k = (a.event.special.mousewheel = {
    version: '3.1.12',
    setup: function() {
      if (this.addEventListener) for (var c = h.length; c; ) this.addEventListener(h[--c], b, !1);
      else this.onmousewheel = b;
      a.data(this, 'mousewheel-line-height', k.getLineHeight(this)),
        a.data(this, 'mousewheel-page-height', k.getPageHeight(this));
    },
    teardown: function() {
      if (this.removeEventListener) for (var c = h.length; c; ) this.removeEventListener(h[--c], b, !1);
      else this.onmousewheel = null;
      a.removeData(this, 'mousewheel-line-height'), a.removeData(this, 'mousewheel-page-height');
    },
    getLineHeight: function(b) {
      var c = a(b),
        d = c['offsetParent' in a.fn ? 'offsetParent' : 'parent']();
      return d.length || (d = a('body')), parseInt(d.css('fontSize'), 10) || parseInt(c.css('fontSize'), 10) || 16;
    },
    getPageHeight: function(b) {
      return a(b).height();
    },
    settings: { adjustOldDeltas: !0, normalizeOffset: !0 },
  });
  a.fn.extend({
    mousewheel: function(a) {
      return a ? this.bind('mousewheel', a) : this.trigger('mousewheel');
    },
    unmousewheel: function(a) {
      return this.unbind('mousewheel', a);
    },
  });
});
!(function(a) {
  'function' == typeof define && define.amd
    ? define(['jquery'], a)
    : 'object' == typeof exports
    ? (module.exports = a)
    : a(jQuery);
})(function(a) {
  function b(b) {
    var g = b || window.event,
      h = i.call(arguments, 1),
      j = 0,
      l = 0,
      m = 0,
      n = 0,
      o = 0,
      p = 0;
    if (
      ((b = a.event.fix(g)),
      (b.type = 'mousewheel'),
      'detail' in g && (m = -1 * g.detail),
      'wheelDelta' in g && (m = g.wheelDelta),
      'wheelDeltaY' in g && (m = g.wheelDeltaY),
      'wheelDeltaX' in g && (l = -1 * g.wheelDeltaX),
      'axis' in g && g.axis === g.HORIZONTAL_AXIS && ((l = -1 * m), (m = 0)),
      (j = 0 === m ? l : m),
      'deltaY' in g && ((m = -1 * g.deltaY), (j = m)),
      'deltaX' in g && ((l = g.deltaX), 0 === m && (j = -1 * l)),
      0 !== m || 0 !== l)
    ) {
      if (1 === g.deltaMode) {
        var q = a.data(this, 'mousewheel-line-height');
        (j *= q), (m *= q), (l *= q);
      } else if (2 === g.deltaMode) {
        var r = a.data(this, 'mousewheel-page-height');
        (j *= r), (m *= r), (l *= r);
      }
      if (
        ((n = Math.max(Math.abs(m), Math.abs(l))),
        (!f || f > n) && ((f = n), d(g, n) && (f /= 40)),
        d(g, n) && ((j /= 40), (l /= 40), (m /= 40)),
        (j = Math[j >= 1 ? 'floor' : 'ceil'](j / f)),
        (l = Math[l >= 1 ? 'floor' : 'ceil'](l / f)),
        (m = Math[m >= 1 ? 'floor' : 'ceil'](m / f)),
        k.settings.normalizeOffset && this.getBoundingClientRect)
      ) {
        var s = this.getBoundingClientRect();
        (o = b.clientX - s.left), (p = b.clientY - s.top);
      }
      return (
        (b.deltaX = l),
        (b.deltaY = m),
        (b.deltaFactor = f),
        (b.offsetX = o),
        (b.offsetY = p),
        (b.deltaMode = 0),
        h.unshift(b, j, l, m),
        e && clearTimeout(e),
        (e = setTimeout(c, 200)),
        (a.event.dispatch || a.event.handle).apply(this, h)
      );
    }
  }
  function c() {
    f = null;
  }
  function d(a, b) {
    return k.settings.adjustOldDeltas && 'mousewheel' === a.type && b % 120 === 0;
  }
  var e,
    f,
    g = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
    h =
      'onwheel' in document || document.documentMode >= 9
        ? ['wheel']
        : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
    i = Array.prototype.slice;
  if (a.event.fixHooks) for (var j = g.length; j; ) a.event.fixHooks[g[--j]] = a.event.mouseHooks;
  var k = (a.event.special.mousewheel = {
    version: '3.1.12',
    setup: function() {
      if (this.addEventListener) for (var c = h.length; c; ) this.addEventListener(h[--c], b, !1);
      else this.onmousewheel = b;
      a.data(this, 'mousewheel-line-height', k.getLineHeight(this)),
        a.data(this, 'mousewheel-page-height', k.getPageHeight(this));
    },
    teardown: function() {
      if (this.removeEventListener) for (var c = h.length; c; ) this.removeEventListener(h[--c], b, !1);
      else this.onmousewheel = null;
      a.removeData(this, 'mousewheel-line-height'), a.removeData(this, 'mousewheel-page-height');
    },
    getLineHeight: function(b) {
      var c = a(b),
        d = c['offsetParent' in a.fn ? 'offsetParent' : 'parent']();
      return d.length || (d = a('body')), parseInt(d.css('fontSize'), 10) || parseInt(c.css('fontSize'), 10) || 16;
    },
    getPageHeight: function(b) {
      return a(b).height();
    },
    settings: { adjustOldDeltas: !0, normalizeOffset: !0 },
  });
  a.fn.extend({
    mousewheel: function(a) {
      return a ? this.bind('mousewheel', a) : this.trigger('mousewheel');
    },
    unmousewheel: function(a) {
      return this.unbind('mousewheel', a);
    },
  });
});
/* == malihu jquery custom scrollbar plugin == Version: 3.1.5, License: MIT License (MIT) */
!(function(e) {
  'function' == typeof define && define.amd
    ? define(['jquery'], e)
    : 'undefined' != typeof module && module.exports
    ? (module.exports = e)
    : e(jQuery, window, document);
})(function(e) {
  !(function(t) {
    var o = 'function' == typeof define && define.amd,
      a = 'undefined' != typeof module && module.exports,
      n = 'https:' == document.location.protocol ? 'https:' : 'http:',
      i = 'cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js';
    o ||
      (a
        ? require('jquery-mousewheel')(e)
        : e.event.special.mousewheel ||
          e('head').append(decodeURI('%3Cscript src=' + n + '//' + i + '%3E%3C/script%3E'))),
      t();
  })(function() {
    var t,
      o = 'mCustomScrollbar',
      a = 'mCS',
      n = '.mCustomScrollbar',
      i = {
        setTop: 0,
        setLeft: 0,
        axis: 'y',
        scrollbarPosition: 'inside',
        scrollInertia: 950,
        autoDraggerLength: !0,
        alwaysShowScrollbar: 0,
        snapOffset: 0,
        mouseWheel: {
          enable: !0,
          scrollAmount: 'auto',
          axis: 'y',
          deltaFactor: 'auto',
          disableOver: ['select', 'option', 'keygen', 'datalist', 'textarea'],
        },
        scrollButtons: { scrollType: 'stepless', scrollAmount: 'auto' },
        keyboard: { enable: !0, scrollType: 'stepless', scrollAmount: 'auto' },
        contentTouchScroll: 25,
        documentTouchScroll: !0,
        advanced: {
          autoScrollOnFocus:
            "input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
          updateOnContentResize: !0,
          updateOnImageLoad: 'auto',
          autoUpdateTimeout: 60,
        },
        theme: 'light',
        callbacks: { onTotalScrollOffset: 0, onTotalScrollBackOffset: 0, alwaysTriggerOffsets: !0 },
      },
      r = 0,
      l = {},
      s = window.attachEvent && !window.addEventListener ? 1 : 0,
      c = !1,
      d = [
        'mCSB_dragger_onDrag',
        'mCSB_scrollTools_onDrag',
        'mCS_img_loaded',
        'mCS_disabled',
        'mCS_destroyed',
        'mCS_no_scrollbar',
        'mCS-autoHide',
        'mCS-dir-rtl',
        'mCS_no_scrollbar_y',
        'mCS_no_scrollbar_x',
        'mCS_y_hidden',
        'mCS_x_hidden',
        'mCSB_draggerContainer',
        'mCSB_buttonUp',
        'mCSB_buttonDown',
        'mCSB_buttonLeft',
        'mCSB_buttonRight',
      ],
      u = {
        init: function(t) {
          var t = e.extend(!0, {}, i, t),
            o = f.call(this);
          if (t.live) {
            var s = t.liveSelector || this.selector || n,
              c = e(s);
            if ('off' === t.live) return void m(s);
            l[s] = setTimeout(function() {
              c.mCustomScrollbar(t), 'once' === t.live && c.length && m(s);
            }, 500);
          } else m(s);
          return (
            (t.setWidth = t.set_width ? t.set_width : t.setWidth),
            (t.setHeight = t.set_height ? t.set_height : t.setHeight),
            (t.axis = t.horizontalScroll ? 'x' : p(t.axis)),
            (t.scrollInertia = t.scrollInertia > 0 && t.scrollInertia < 17 ? 17 : t.scrollInertia),
            'object' != typeof t.mouseWheel &&
              1 == t.mouseWheel &&
              (t.mouseWheel = {
                enable: !0,
                scrollAmount: 'auto',
                axis: 'y',
                preventDefault: !1,
                deltaFactor: 'auto',
                normalizeDelta: !1,
                invert: !1,
              }),
            (t.mouseWheel.scrollAmount = t.mouseWheelPixels ? t.mouseWheelPixels : t.mouseWheel.scrollAmount),
            (t.mouseWheel.normalizeDelta = t.advanced.normalizeMouseWheelDelta
              ? t.advanced.normalizeMouseWheelDelta
              : t.mouseWheel.normalizeDelta),
            (t.scrollButtons.scrollType = g(t.scrollButtons.scrollType)),
            h(t),
            e(o).each(function() {
              var o = e(this);
              if (!o.data(a)) {
                o.data(a, {
                  idx: ++r,
                  opt: t,
                  scrollRatio: { y: null, x: null },
                  overflowed: null,
                  contentReset: { y: null, x: null },
                  bindEvents: !1,
                  tweenRunning: !1,
                  sequential: {},
                  langDir: o.css('direction'),
                  cbOffsets: null,
                  trigger: null,
                  poll: { size: { o: 0, n: 0 }, img: { o: 0, n: 0 }, change: { o: 0, n: 0 } },
                });
                var n = o.data(a),
                  i = n.opt,
                  l = o.data('mcs-axis'),
                  s = o.data('mcs-scrollbar-position'),
                  c = o.data('mcs-theme');
                l && (i.axis = l),
                  s && (i.scrollbarPosition = s),
                  c && ((i.theme = c), h(i)),
                  v.call(this),
                  n &&
                    i.callbacks.onCreate &&
                    'function' == typeof i.callbacks.onCreate &&
                    i.callbacks.onCreate.call(this),
                  e('#mCSB_' + n.idx + '_container img:not(.' + d[2] + ')').addClass(d[2]),
                  u.update.call(null, o);
              }
            })
          );
        },
        update: function(t, o) {
          var n = t || f.call(this);
          return e(n).each(function() {
            var t = e(this);
            if (t.data(a)) {
              var n = t.data(a),
                i = n.opt,
                r = e('#mCSB_' + n.idx + '_container'),
                l = e('#mCSB_' + n.idx),
                s = [e('#mCSB_' + n.idx + '_dragger_vertical'), e('#mCSB_' + n.idx + '_dragger_horizontal')];
              if (!r.length) return;
              n.tweenRunning && Q(t),
                o &&
                  n &&
                  i.callbacks.onBeforeUpdate &&
                  'function' == typeof i.callbacks.onBeforeUpdate &&
                  i.callbacks.onBeforeUpdate.call(this),
                t.hasClass(d[3]) && t.removeClass(d[3]),
                t.hasClass(d[4]) && t.removeClass(d[4]),
                l.css('max-height', 'none'),
                l.height() !== t.height() && l.css('max-height', t.height()),
                _.call(this),
                'y' === i.axis || i.advanced.autoExpandHorizontalScroll || r.css('width', x(r)),
                (n.overflowed = y.call(this)),
                M.call(this),
                i.autoDraggerLength && S.call(this),
                b.call(this),
                T.call(this);
              var c = [Math.abs(r[0].offsetTop), Math.abs(r[0].offsetLeft)];
              'x' !== i.axis &&
                (n.overflowed[0]
                  ? s[0].height() > s[0].parent().height()
                    ? B.call(this)
                    : (G(t, c[0].toString(), { dir: 'y', dur: 0, overwrite: 'none' }), (n.contentReset.y = null))
                  : (B.call(this),
                    'y' === i.axis
                      ? k.call(this)
                      : 'yx' === i.axis &&
                        n.overflowed[1] &&
                        G(t, c[1].toString(), { dir: 'x', dur: 0, overwrite: 'none' }))),
                'y' !== i.axis &&
                  (n.overflowed[1]
                    ? s[1].width() > s[1].parent().width()
                      ? B.call(this)
                      : (G(t, c[1].toString(), { dir: 'x', dur: 0, overwrite: 'none' }), (n.contentReset.x = null))
                    : (B.call(this),
                      'x' === i.axis
                        ? k.call(this)
                        : 'yx' === i.axis &&
                          n.overflowed[0] &&
                          G(t, c[0].toString(), { dir: 'y', dur: 0, overwrite: 'none' }))),
                o &&
                  n &&
                  (2 === o && i.callbacks.onImageLoad && 'function' == typeof i.callbacks.onImageLoad
                    ? i.callbacks.onImageLoad.call(this)
                    : 3 === o && i.callbacks.onSelectorChange && 'function' == typeof i.callbacks.onSelectorChange
                    ? i.callbacks.onSelectorChange.call(this)
                    : i.callbacks.onUpdate &&
                      'function' == typeof i.callbacks.onUpdate &&
                      i.callbacks.onUpdate.call(this)),
                N.call(this);
            }
          });
        },
        scrollTo: function(t, o) {
          if ('undefined' != typeof t && null != t) {
            var n = f.call(this);
            return e(n).each(function() {
              var n = e(this);
              if (n.data(a)) {
                var i = n.data(a),
                  r = i.opt,
                  l = {
                    trigger: 'external',
                    scrollInertia: r.scrollInertia,
                    scrollEasing: 'mcsEaseInOut',
                    moveDragger: !1,
                    timeout: 60,
                    callbacks: !0,
                    onStart: !0,
                    onUpdate: !0,
                    onComplete: !0,
                  },
                  s = e.extend(!0, {}, l, o),
                  c = Y.call(this, t),
                  d = s.scrollInertia > 0 && s.scrollInertia < 17 ? 17 : s.scrollInertia;
                (c[0] = X.call(this, c[0], 'y')),
                  (c[1] = X.call(this, c[1], 'x')),
                  s.moveDragger && ((c[0] *= i.scrollRatio.y), (c[1] *= i.scrollRatio.x)),
                  (s.dur = ne() ? 0 : d),
                  setTimeout(function() {
                    null !== c[0] &&
                      'undefined' != typeof c[0] &&
                      'x' !== r.axis &&
                      i.overflowed[0] &&
                      ((s.dir = 'y'), (s.overwrite = 'all'), G(n, c[0].toString(), s)),
                      null !== c[1] &&
                        'undefined' != typeof c[1] &&
                        'y' !== r.axis &&
                        i.overflowed[1] &&
                        ((s.dir = 'x'), (s.overwrite = 'none'), G(n, c[1].toString(), s));
                  }, s.timeout);
              }
            });
          }
        },
        stop: function() {
          var t = f.call(this);
          return e(t).each(function() {
            var t = e(this);
            t.data(a) && Q(t);
          });
        },
        disable: function(t) {
          var o = f.call(this);
          return e(o).each(function() {
            var o = e(this);
            if (o.data(a)) {
              o.data(a);
              N.call(this, 'remove'), k.call(this), t && B.call(this), M.call(this, !0), o.addClass(d[3]);
            }
          });
        },
        destroy: function() {
          var t = f.call(this);
          return e(t).each(function() {
            var n = e(this);
            if (n.data(a)) {
              var i = n.data(a),
                r = i.opt,
                l = e('#mCSB_' + i.idx),
                s = e('#mCSB_' + i.idx + '_container'),
                c = e('.mCSB_' + i.idx + '_scrollbar');
              r.live && m(r.liveSelector || e(t).selector),
                N.call(this, 'remove'),
                k.call(this),
                B.call(this),
                n.removeData(a),
                $(this, 'mcs'),
                c.remove(),
                s.find('img.' + d[2]).removeClass(d[2]),
                l.replaceWith(s.contents()),
                n
                  .removeClass(o + ' _' + a + '_' + i.idx + ' ' + d[6] + ' ' + d[7] + ' ' + d[5] + ' ' + d[3])
                  .addClass(d[4]);
            }
          });
        },
      },
      f = function() {
        return 'object' != typeof e(this) || e(this).length < 1 ? n : this;
      },
      h = function(t) {
        var o = ['rounded', 'rounded-dark', 'rounded-dots', 'rounded-dots-dark'],
          a = [
            'rounded-dots',
            'rounded-dots-dark',
            '3d',
            '3d-dark',
            '3d-thick',
            '3d-thick-dark',
            'inset',
            'inset-dark',
            'inset-2',
            'inset-2-dark',
            'inset-3',
            'inset-3-dark',
          ],
          n = ['minimal', 'minimal-dark'],
          i = ['minimal', 'minimal-dark'],
          r = ['minimal', 'minimal-dark'];
        (t.autoDraggerLength = e.inArray(t.theme, o) > -1 ? !1 : t.autoDraggerLength),
          (t.autoExpandScrollbar = e.inArray(t.theme, a) > -1 ? !1 : t.autoExpandScrollbar),
          (t.scrollButtons.enable = e.inArray(t.theme, n) > -1 ? !1 : t.scrollButtons.enable),
          (t.autoHideScrollbar = e.inArray(t.theme, i) > -1 ? !0 : t.autoHideScrollbar),
          (t.scrollbarPosition = e.inArray(t.theme, r) > -1 ? 'outside' : t.scrollbarPosition);
      },
      m = function(e) {
        l[e] && (clearTimeout(l[e]), $(l, e));
      },
      p = function(e) {
        return 'yx' === e || 'xy' === e || 'auto' === e ? 'yx' : 'x' === e || 'horizontal' === e ? 'x' : 'y';
      },
      g = function(e) {
        return 'stepped' === e || 'pixels' === e || 'step' === e || 'click' === e ? 'stepped' : 'stepless';
      },
      v = function() {
        var t = e(this),
          n = t.data(a),
          i = n.opt,
          r = i.autoExpandScrollbar ? ' ' + d[1] + '_expand' : '',
          l = [
            "<div id='mCSB_" +
              n.idx +
              "_scrollbar_vertical' class='mCSB_scrollTools mCSB_" +
              n.idx +
              '_scrollbar mCS-' +
              i.theme +
              ' mCSB_scrollTools_vertical' +
              r +
              "'><div class='" +
              d[12] +
              "'><div id='mCSB_" +
              n.idx +
              "_dragger_vertical' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>",
            "<div id='mCSB_" +
              n.idx +
              "_scrollbar_horizontal' class='mCSB_scrollTools mCSB_" +
              n.idx +
              '_scrollbar mCS-' +
              i.theme +
              ' mCSB_scrollTools_horizontal' +
              r +
              "'><div class='" +
              d[12] +
              "'><div id='mCSB_" +
              n.idx +
              "_dragger_horizontal' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>",
          ],
          s = 'yx' === i.axis ? 'mCSB_vertical_horizontal' : 'x' === i.axis ? 'mCSB_horizontal' : 'mCSB_vertical',
          c = 'yx' === i.axis ? l[0] + l[1] : 'x' === i.axis ? l[1] : l[0],
          u = 'yx' === i.axis ? "<div id='mCSB_" + n.idx + "_container_wrapper' class='mCSB_container_wrapper' />" : '',
          f = i.autoHideScrollbar ? ' ' + d[6] : '',
          h = 'x' !== i.axis && 'rtl' === n.langDir ? ' ' + d[7] : '';
        i.setWidth && t.css('width', i.setWidth),
          i.setHeight && t.css('height', i.setHeight),
          (i.setLeft = 'y' !== i.axis && 'rtl' === n.langDir ? '989999px' : i.setLeft),
          t
            .addClass(o + ' _' + a + '_' + n.idx + f + h)
            .wrapInner(
              "<div id='mCSB_" +
                n.idx +
                "' class='mCustomScrollBox mCS-" +
                i.theme +
                ' ' +
                s +
                "'><div id='mCSB_" +
                n.idx +
                "_container' class='mCSB_container' style='position:relative; top:" +
                i.setTop +
                '; left:' +
                i.setLeft +
                ";' dir='" +
                n.langDir +
                "' /></div>"
            );
        var m = e('#mCSB_' + n.idx),
          p = e('#mCSB_' + n.idx + '_container');
        'y' === i.axis || i.advanced.autoExpandHorizontalScroll || p.css('width', x(p)),
          'outside' === i.scrollbarPosition
            ? ('static' === t.css('position') && t.css('position', 'relative'),
              t.css('overflow', 'visible'),
              m.addClass('mCSB_outside').after(c))
            : (m.addClass('mCSB_inside').append(c), p.wrap(u)),
          w.call(this);
        var g = [e('#mCSB_' + n.idx + '_dragger_vertical'), e('#mCSB_' + n.idx + '_dragger_horizontal')];
        g[0].css('min-height', g[0].height()), g[1].css('min-width', g[1].width());
      },
      x = function(t) {
        var o = [
            t[0].scrollWidth,
            Math.max.apply(
              Math,
              t
                .children()
                .map(function() {
                  return e(this).outerWidth(!0);
                })
                .get()
            ),
          ],
          a = t.parent().width();
        return o[0] > a ? o[0] : o[1] > a ? o[1] : '100%';
      },
      _ = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = e('#mCSB_' + o.idx + '_container');
        if (n.advanced.autoExpandHorizontalScroll && 'y' !== n.axis) {
          i.css({ width: 'auto', 'min-width': 0, 'overflow-x': 'scroll' });
          var r = Math.ceil(i[0].scrollWidth);
          3 === n.advanced.autoExpandHorizontalScroll ||
          (2 !== n.advanced.autoExpandHorizontalScroll && r > i.parent().width())
            ? i.css({ width: r, 'min-width': '100%', 'overflow-x': 'inherit' })
            : i
                .css({ 'overflow-x': 'inherit', position: 'absolute' })
                .wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />")
                .css({
                  width:
                    Math.ceil(i[0].getBoundingClientRect().right + 0.4) - Math.floor(i[0].getBoundingClientRect().left),
                  'min-width': '100%',
                  position: 'relative',
                })
                .unwrap();
        }
      },
      w = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = e('.mCSB_' + o.idx + '_scrollbar:first'),
          r = oe(n.scrollButtons.tabindex) ? "tabindex='" + n.scrollButtons.tabindex + "'" : '',
          l = [
            "<a href='#' class='" + d[13] + "' " + r + ' />',
            "<a href='#' class='" + d[14] + "' " + r + ' />',
            "<a href='#' class='" + d[15] + "' " + r + ' />',
            "<a href='#' class='" + d[16] + "' " + r + ' />',
          ],
          s = ['x' === n.axis ? l[2] : l[0], 'x' === n.axis ? l[3] : l[1], l[2], l[3]];
        n.scrollButtons.enable &&
          i
            .prepend(s[0])
            .append(s[1])
            .next('.mCSB_scrollTools')
            .prepend(s[2])
            .append(s[3]);
      },
      S = function() {
        var t = e(this),
          o = t.data(a),
          n = e('#mCSB_' + o.idx),
          i = e('#mCSB_' + o.idx + '_container'),
          r = [e('#mCSB_' + o.idx + '_dragger_vertical'), e('#mCSB_' + o.idx + '_dragger_horizontal')],
          l = [n.height() / i.outerHeight(!1), n.width() / i.outerWidth(!1)],
          c = [
            parseInt(r[0].css('min-height')),
            Math.round(l[0] * r[0].parent().height()),
            parseInt(r[1].css('min-width')),
            Math.round(l[1] * r[1].parent().width()),
          ],
          d = s && c[1] < c[0] ? c[0] : c[1],
          u = s && c[3] < c[2] ? c[2] : c[3];
        r[0]
          .css({ height: d, 'max-height': r[0].parent().height() - 10 })
          .find('.mCSB_dragger_bar')
          .css({ 'line-height': c[0] + 'px' }),
          r[1].css({ width: u, 'max-width': r[1].parent().width() - 10 });
      },
      b = function() {
        var t = e(this),
          o = t.data(a),
          n = e('#mCSB_' + o.idx),
          i = e('#mCSB_' + o.idx + '_container'),
          r = [e('#mCSB_' + o.idx + '_dragger_vertical'), e('#mCSB_' + o.idx + '_dragger_horizontal')],
          l = [i.outerHeight(!1) - n.height(), i.outerWidth(!1) - n.width()],
          s = [l[0] / (r[0].parent().height() - r[0].height()), l[1] / (r[1].parent().width() - r[1].width())];
        o.scrollRatio = { y: s[0], x: s[1] };
      },
      C = function(e, t, o) {
        var a = o ? d[0] + '_expanded' : '',
          n = e.closest('.mCSB_scrollTools');
        'active' === t
          ? (e.toggleClass(d[0] + ' ' + a), n.toggleClass(d[1]), (e[0]._draggable = e[0]._draggable ? 0 : 1))
          : e[0]._draggable ||
            ('hide' === t ? (e.removeClass(d[0]), n.removeClass(d[1])) : (e.addClass(d[0]), n.addClass(d[1])));
      },
      y = function() {
        var t = e(this),
          o = t.data(a),
          n = e('#mCSB_' + o.idx),
          i = e('#mCSB_' + o.idx + '_container'),
          r = null == o.overflowed ? i.height() : i.outerHeight(!1),
          l = null == o.overflowed ? i.width() : i.outerWidth(!1),
          s = i[0].scrollHeight,
          c = i[0].scrollWidth;
        return s > r && (r = s), c > l && (l = c), [r > n.height(), l > n.width()];
      },
      B = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = e('#mCSB_' + o.idx),
          r = e('#mCSB_' + o.idx + '_container'),
          l = [e('#mCSB_' + o.idx + '_dragger_vertical'), e('#mCSB_' + o.idx + '_dragger_horizontal')];
        if (
          (Q(t),
          (('x' !== n.axis && !o.overflowed[0]) || ('y' === n.axis && o.overflowed[0])) &&
            (l[0].add(r).css('top', 0), G(t, '_resetY')),
          ('y' !== n.axis && !o.overflowed[1]) || ('x' === n.axis && o.overflowed[1]))
        ) {
          var s = (dx = 0);
          'rtl' === o.langDir && ((s = i.width() - r.outerWidth(!1)), (dx = Math.abs(s / o.scrollRatio.x))),
            r.css('left', s),
            l[1].css('left', dx),
            G(t, '_resetX');
        }
      },
      T = function() {
        function t() {
          r = setTimeout(function() {
            e.event.special.mousewheel ? (clearTimeout(r), W.call(o[0])) : t();
          }, 100);
        }
        var o = e(this),
          n = o.data(a),
          i = n.opt;
        if (!n.bindEvents) {
          if ((I.call(this), i.contentTouchScroll && D.call(this), E.call(this), i.mouseWheel.enable)) {
            var r;
            t();
          }
          P.call(this),
            U.call(this),
            i.advanced.autoScrollOnFocus && H.call(this),
            i.scrollButtons.enable && F.call(this),
            i.keyboard.enable && q.call(this),
            (n.bindEvents = !0);
        }
      },
      k = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = a + '_' + o.idx,
          r = '.mCSB_' + o.idx + '_scrollbar',
          l = e(
            '#mCSB_' +
              o.idx +
              ',#mCSB_' +
              o.idx +
              '_container,#mCSB_' +
              o.idx +
              '_container_wrapper,' +
              r +
              ' .' +
              d[12] +
              ',#mCSB_' +
              o.idx +
              '_dragger_vertical,#mCSB_' +
              o.idx +
              '_dragger_horizontal,' +
              r +
              '>a'
          ),
          s = e('#mCSB_' + o.idx + '_container');
        n.advanced.releaseDraggableSelectors && l.add(e(n.advanced.releaseDraggableSelectors)),
          n.advanced.extraDraggableSelectors && l.add(e(n.advanced.extraDraggableSelectors)),
          o.bindEvents &&
            (e(document)
              .add(e(!A() || top.document))
              .unbind('.' + i),
            l.each(function() {
              e(this).unbind('.' + i);
            }),
            clearTimeout(t[0]._focusTimeout),
            $(t[0], '_focusTimeout'),
            clearTimeout(o.sequential.step),
            $(o.sequential, 'step'),
            clearTimeout(s[0].onCompleteTimeout),
            $(s[0], 'onCompleteTimeout'),
            (o.bindEvents = !1));
      },
      M = function(t) {
        var o = e(this),
          n = o.data(a),
          i = n.opt,
          r = e('#mCSB_' + n.idx + '_container_wrapper'),
          l = r.length ? r : e('#mCSB_' + n.idx + '_container'),
          s = [e('#mCSB_' + n.idx + '_scrollbar_vertical'), e('#mCSB_' + n.idx + '_scrollbar_horizontal')],
          c = [s[0].find('.mCSB_dragger'), s[1].find('.mCSB_dragger')];
        'x' !== i.axis &&
          (n.overflowed[0] && !t
            ? (s[0]
                .add(c[0])
                .add(s[0].children('a'))
                .css('display', 'block'),
              l.removeClass(d[8] + ' ' + d[10]))
            : (i.alwaysShowScrollbar
                ? (2 !== i.alwaysShowScrollbar && c[0].css('display', 'none'), l.removeClass(d[10]))
                : (s[0].css('display', 'none'), l.addClass(d[10])),
              l.addClass(d[8]))),
          'y' !== i.axis &&
            (n.overflowed[1] && !t
              ? (s[1]
                  .add(c[1])
                  .add(s[1].children('a'))
                  .css('display', 'block'),
                l.removeClass(d[9] + ' ' + d[11]))
              : (i.alwaysShowScrollbar
                  ? (2 !== i.alwaysShowScrollbar && c[1].css('display', 'none'), l.removeClass(d[11]))
                  : (s[1].css('display', 'none'), l.addClass(d[11])),
                l.addClass(d[9]))),
          n.overflowed[0] || n.overflowed[1] ? o.removeClass(d[5]) : o.addClass(d[5]);
      },
      O = function(t) {
        var o = t.type,
          a =
            t.target.ownerDocument !== document && null !== frameElement
              ? [e(frameElement).offset().top, e(frameElement).offset().left]
              : null,
          n =
            A() && t.target.ownerDocument !== top.document && null !== frameElement
              ? [e(t.view.frameElement).offset().top, e(t.view.frameElement).offset().left]
              : [0, 0];
        switch (o) {
          case 'pointerdown':
          case 'MSPointerDown':
          case 'pointermove':
          case 'MSPointerMove':
          case 'pointerup':
          case 'MSPointerUp':
            return a
              ? [t.originalEvent.pageY - a[0] + n[0], t.originalEvent.pageX - a[1] + n[1], !1]
              : [t.originalEvent.pageY, t.originalEvent.pageX, !1];
          case 'touchstart':
          case 'touchmove':
          case 'touchend':
            var i = t.originalEvent.touches[0] || t.originalEvent.changedTouches[0],
              r = t.originalEvent.touches.length || t.originalEvent.changedTouches.length;
            return t.target.ownerDocument !== document ? [i.screenY, i.screenX, r > 1] : [i.pageY, i.pageX, r > 1];
          default:
            return a ? [t.pageY - a[0] + n[0], t.pageX - a[1] + n[1], !1] : [t.pageY, t.pageX, !1];
        }
      },
      I = function() {
        function t(e, t, a, n) {
          if (((h[0].idleTimer = d.scrollInertia < 233 ? 250 : 0), o.attr('id') === f[1]))
            var i = 'x',
              s = (o[0].offsetLeft - t + n) * l.scrollRatio.x;
          else
            var i = 'y',
              s = (o[0].offsetTop - e + a) * l.scrollRatio.y;
          G(r, s.toString(), { dir: i, drag: !0 });
        }
        var o,
          n,
          i,
          r = e(this),
          l = r.data(a),
          d = l.opt,
          u = a + '_' + l.idx,
          f = ['mCSB_' + l.idx + '_dragger_vertical', 'mCSB_' + l.idx + '_dragger_horizontal'],
          h = e('#mCSB_' + l.idx + '_container'),
          m = e('#' + f[0] + ',#' + f[1]),
          p = d.advanced.releaseDraggableSelectors ? m.add(e(d.advanced.releaseDraggableSelectors)) : m,
          g = d.advanced.extraDraggableSelectors
            ? e(!A() || top.document).add(e(d.advanced.extraDraggableSelectors))
            : e(!A() || top.document);
        m
          .bind('contextmenu.' + u, function(e) {
            e.preventDefault();
          })
          .bind('mousedown.' + u + ' touchstart.' + u + ' pointerdown.' + u + ' MSPointerDown.' + u, function(t) {
            if ((t.stopImmediatePropagation(), t.preventDefault(), ee(t))) {
              (c = !0),
                s &&
                  (document.onselectstart = function() {
                    return !1;
                  }),
                L.call(h, !1),
                Q(r),
                (o = e(this));
              var a = o.offset(),
                l = O(t)[0] - a.top,
                u = O(t)[1] - a.left,
                f = o.height() + a.top,
                m = o.width() + a.left;
              f > l && l > 0 && m > u && u > 0 && ((n = l), (i = u)), C(o, 'active', d.autoExpandScrollbar);
            }
          })
          .bind('touchmove.' + u, function(e) {
            e.stopImmediatePropagation(), e.preventDefault();
            var a = o.offset(),
              r = O(e)[0] - a.top,
              l = O(e)[1] - a.left;
            t(n, i, r, l);
          }),
          e(document)
            .add(g)
            .bind('mousemove.' + u + ' pointermove.' + u + ' MSPointerMove.' + u, function(e) {
              if (o) {
                var a = o.offset(),
                  r = O(e)[0] - a.top,
                  l = O(e)[1] - a.left;
                if (n === r && i === l) return;
                t(n, i, r, l);
              }
            })
            .add(p)
            .bind('mouseup.' + u + ' touchend.' + u + ' pointerup.' + u + ' MSPointerUp.' + u, function() {
              o && (C(o, 'active', d.autoExpandScrollbar), (o = null)),
                (c = !1),
                s && (document.onselectstart = null),
                L.call(h, !0);
            });
      },
      D = function() {
        function o(e) {
          if (!te(e) || c || O(e)[2]) return void (t = 0);
          (t = 1), (b = 0), (C = 0), (d = 1), y.removeClass('mCS_touch_action');
          var o = I.offset();
          (u = O(e)[0] - o.top), (f = O(e)[1] - o.left), (z = [O(e)[0], O(e)[1]]);
        }
        function n(e) {
          if (
            te(e) &&
            !c &&
            !O(e)[2] &&
            (T.documentTouchScroll || e.preventDefault(), e.stopImmediatePropagation(), (!C || b) && d)
          ) {
            g = K();
            var t = M.offset(),
              o = O(e)[0] - t.top,
              a = O(e)[1] - t.left,
              n = 'mcsLinearOut';
            if (
              (E.push(o),
              W.push(a),
              (z[2] = Math.abs(O(e)[0] - z[0])),
              (z[3] = Math.abs(O(e)[1] - z[1])),
              B.overflowed[0])
            )
              var i = D[0].parent().height() - D[0].height(),
                r = u - o > 0 && o - u > -(i * B.scrollRatio.y) && (2 * z[3] < z[2] || 'yx' === T.axis);
            if (B.overflowed[1])
              var l = D[1].parent().width() - D[1].width(),
                h = f - a > 0 && a - f > -(l * B.scrollRatio.x) && (2 * z[2] < z[3] || 'yx' === T.axis);
            r || h ? (U || e.preventDefault(), (b = 1)) : ((C = 1), y.addClass('mCS_touch_action')),
              U && e.preventDefault(),
              (w = 'yx' === T.axis ? [u - o, f - a] : 'x' === T.axis ? [null, f - a] : [u - o, null]),
              (I[0].idleTimer = 250),
              B.overflowed[0] && s(w[0], R, n, 'y', 'all', !0),
              B.overflowed[1] && s(w[1], R, n, 'x', L, !0);
          }
        }
        function i(e) {
          if (!te(e) || c || O(e)[2]) return void (t = 0);
          (t = 1), e.stopImmediatePropagation(), Q(y), (p = K());
          var o = M.offset();
          (h = O(e)[0] - o.top), (m = O(e)[1] - o.left), (E = []), (W = []);
        }
        function r(e) {
          if (te(e) && !c && !O(e)[2]) {
            (d = 0), e.stopImmediatePropagation(), (b = 0), (C = 0), (v = K());
            var t = M.offset(),
              o = O(e)[0] - t.top,
              a = O(e)[1] - t.left;
            if (!(v - g > 30)) {
              _ = 1e3 / (v - p);
              var n = 'mcsEaseOut',
                i = 2.5 > _,
                r = i ? [E[E.length - 2], W[W.length - 2]] : [0, 0];
              x = i ? [o - r[0], a - r[1]] : [o - h, a - m];
              var u = [Math.abs(x[0]), Math.abs(x[1])];
              _ = i ? [Math.abs(x[0] / 4), Math.abs(x[1] / 4)] : [_, _];
              var f = [
                Math.abs(I[0].offsetTop) - x[0] * l(u[0] / _[0], _[0]),
                Math.abs(I[0].offsetLeft) - x[1] * l(u[1] / _[1], _[1]),
              ];
              (w = 'yx' === T.axis ? [f[0], f[1]] : 'x' === T.axis ? [null, f[1]] : [f[0], null]),
                (S = [4 * u[0] + T.scrollInertia, 4 * u[1] + T.scrollInertia]);
              var y = parseInt(T.contentTouchScroll) || 0;
              (w[0] = u[0] > y ? w[0] : 0),
                (w[1] = u[1] > y ? w[1] : 0),
                B.overflowed[0] && s(w[0], S[0], n, 'y', L, !1),
                B.overflowed[1] && s(w[1], S[1], n, 'x', L, !1);
            }
          }
        }
        function l(e, t) {
          var o = [1.5 * t, 2 * t, t / 1.5, t / 2];
          return e > 90
            ? t > 4
              ? o[0]
              : o[3]
            : e > 60
            ? t > 3
              ? o[3]
              : o[2]
            : e > 30
            ? t > 8
              ? o[1]
              : t > 6
              ? o[0]
              : t > 4
              ? t
              : o[2]
            : t > 8
            ? t
            : o[3];
        }
        function s(e, t, o, a, n, i) {
          e && G(y, e.toString(), { dur: t, scrollEasing: o, dir: a, overwrite: n, drag: i });
        }
        var d,
          u,
          f,
          h,
          m,
          p,
          g,
          v,
          x,
          _,
          w,
          S,
          b,
          C,
          y = e(this),
          B = y.data(a),
          T = B.opt,
          k = a + '_' + B.idx,
          M = e('#mCSB_' + B.idx),
          I = e('#mCSB_' + B.idx + '_container'),
          D = [e('#mCSB_' + B.idx + '_dragger_vertical'), e('#mCSB_' + B.idx + '_dragger_horizontal')],
          E = [],
          W = [],
          R = 0,
          L = 'yx' === T.axis ? 'none' : 'all',
          z = [],
          P = I.find('iframe'),
          H = [
            'touchstart.' + k + ' pointerdown.' + k + ' MSPointerDown.' + k,
            'touchmove.' + k + ' pointermove.' + k + ' MSPointerMove.' + k,
            'touchend.' + k + ' pointerup.' + k + ' MSPointerUp.' + k,
          ],
          U = void 0 !== document.body.style.touchAction && '' !== document.body.style.touchAction;
        I.bind(H[0], function(e) {
          o(e);
        }).bind(H[1], function(e) {
          n(e);
        }),
          M.bind(H[0], function(e) {
            i(e);
          }).bind(H[2], function(e) {
            r(e);
          }),
          P.length &&
            P.each(function() {
              e(this).bind('load', function() {
                A(this) &&
                  e(this.contentDocument || this.contentWindow.document)
                    .bind(H[0], function(e) {
                      o(e), i(e);
                    })
                    .bind(H[1], function(e) {
                      n(e);
                    })
                    .bind(H[2], function(e) {
                      r(e);
                    });
              });
            });
      },
      E = function() {
        function o() {
          return window.getSelection
            ? window.getSelection().toString()
            : document.selection && 'Control' != document.selection.type
            ? document.selection.createRange().text
            : 0;
        }
        function n(e, t, o) {
          (d.type = o && i ? 'stepped' : 'stepless'), (d.scrollAmount = 10), j(r, e, t, 'mcsLinearOut', o ? 60 : null);
        }
        var i,
          r = e(this),
          l = r.data(a),
          s = l.opt,
          d = l.sequential,
          u = a + '_' + l.idx,
          f = e('#mCSB_' + l.idx + '_container'),
          h = f.parent();
        f.bind('mousedown.' + u, function() {
          t || i || ((i = 1), (c = !0));
        })
          .add(document)
          .bind('mousemove.' + u, function(e) {
            if (!t && i && o()) {
              var a = f.offset(),
                r = O(e)[0] - a.top + f[0].offsetTop,
                c = O(e)[1] - a.left + f[0].offsetLeft;
              r > 0 && r < h.height() && c > 0 && c < h.width()
                ? d.step && n('off', null, 'stepped')
                : ('x' !== s.axis && l.overflowed[0] && (0 > r ? n('on', 38) : r > h.height() && n('on', 40)),
                  'y' !== s.axis && l.overflowed[1] && (0 > c ? n('on', 37) : c > h.width() && n('on', 39)));
            }
          })
          .bind('mouseup.' + u + ' dragend.' + u, function() {
            t || (i && ((i = 0), n('off', null)), (c = !1));
          });
      },
      W = function() {
        function t(t, a) {
          if ((Q(o), !z(o, t.target))) {
            var r =
                'auto' !== i.mouseWheel.deltaFactor
                  ? parseInt(i.mouseWheel.deltaFactor)
                  : s && t.deltaFactor < 100
                  ? 100
                  : t.deltaFactor || 100,
              d = i.scrollInertia;
            if ('x' === i.axis || 'x' === i.mouseWheel.axis)
              var u = 'x',
                f = [Math.round(r * n.scrollRatio.x), parseInt(i.mouseWheel.scrollAmount)],
                h = 'auto' !== i.mouseWheel.scrollAmount ? f[1] : f[0] >= l.width() ? 0.9 * l.width() : f[0],
                m = Math.abs(e('#mCSB_' + n.idx + '_container')[0].offsetLeft),
                p = c[1][0].offsetLeft,
                g = c[1].parent().width() - c[1].width(),
                v = 'y' === i.mouseWheel.axis ? t.deltaY || a : t.deltaX;
            else
              var u = 'y',
                f = [Math.round(r * n.scrollRatio.y), parseInt(i.mouseWheel.scrollAmount)],
                h = 'auto' !== i.mouseWheel.scrollAmount ? f[1] : f[0] >= l.height() ? 0.9 * l.height() : f[0],
                m = Math.abs(e('#mCSB_' + n.idx + '_container')[0].offsetTop),
                p = c[0][0].offsetTop,
                g = c[0].parent().height() - c[0].height(),
                v = t.deltaY || a;
            ('y' === u && !n.overflowed[0]) ||
              ('x' === u && !n.overflowed[1]) ||
              ((i.mouseWheel.invert || t.webkitDirectionInvertedFromDevice) && (v = -v),
              i.mouseWheel.normalizeDelta && (v = 0 > v ? -1 : 1),
              ((v > 0 && 0 !== p) || (0 > v && p !== g) || i.mouseWheel.preventDefault) &&
                (t.stopImmediatePropagation(), t.preventDefault()),
              t.deltaFactor < 5 && !i.mouseWheel.normalizeDelta && ((h = t.deltaFactor), (d = 17)),
              G(o, (m - v * h).toString(), { dir: u, dur: d }));
          }
        }
        if (e(this).data(a)) {
          var o = e(this),
            n = o.data(a),
            i = n.opt,
            r = a + '_' + n.idx,
            l = e('#mCSB_' + n.idx),
            c = [e('#mCSB_' + n.idx + '_dragger_vertical'), e('#mCSB_' + n.idx + '_dragger_horizontal')],
            d = e('#mCSB_' + n.idx + '_container').find('iframe');
          d.length &&
            d.each(function() {
              e(this).bind('load', function() {
                A(this) &&
                  e(this.contentDocument || this.contentWindow.document).bind('mousewheel.' + r, function(e, o) {
                    t(e, o);
                  });
              });
            }),
            l.bind('mousewheel.' + r, function(e, o) {
              t(e, o);
            });
        }
      },
      R = new Object(),
      A = function(t) {
        var o = !1,
          a = !1,
          n = null;
        if (
          (void 0 === t ? (a = '#empty') : void 0 !== e(t).attr('id') && (a = e(t).attr('id')),
          a !== !1 && void 0 !== R[a])
        )
          return R[a];
        if (t) {
          try {
            var i = t.contentDocument || t.contentWindow.document;
            n = i.body.innerHTML;
          } catch (r) {}
          o = null !== n;
        } else {
          try {
            var i = top.document;
            n = i.body.innerHTML;
          } catch (r) {}
          o = null !== n;
        }
        return a !== !1 && (R[a] = o), o;
      },
      L = function(e) {
        var t = this.find('iframe');
        if (t.length) {
          var o = e ? 'auto' : 'none';
          t.css('pointer-events', o);
        }
      },
      z = function(t, o) {
        var n = o.nodeName.toLowerCase(),
          i = t.data(a).opt.mouseWheel.disableOver,
          r = ['select', 'textarea'];
        return e.inArray(n, i) > -1 && !(e.inArray(n, r) > -1 && !e(o).is(':focus'));
      },
      P = function() {
        var t,
          o = e(this),
          n = o.data(a),
          i = a + '_' + n.idx,
          r = e('#mCSB_' + n.idx + '_container'),
          l = r.parent(),
          s = e('.mCSB_' + n.idx + '_scrollbar .' + d[12]);
        s.bind('mousedown.' + i + ' touchstart.' + i + ' pointerdown.' + i + ' MSPointerDown.' + i, function(o) {
          (c = !0), e(o.target).hasClass('mCSB_dragger') || (t = 1);
        })
          .bind('touchend.' + i + ' pointerup.' + i + ' MSPointerUp.' + i, function() {
            c = !1;
          })
          .bind('click.' + i, function(a) {
            if (t && ((t = 0), e(a.target).hasClass(d[12]) || e(a.target).hasClass('mCSB_draggerRail'))) {
              Q(o);
              var i = e(this),
                s = i.find('.mCSB_dragger');
              if (i.parent('.mCSB_scrollTools_horizontal').length > 0) {
                if (!n.overflowed[1]) return;
                var c = 'x',
                  u = a.pageX > s.offset().left ? -1 : 1,
                  f = Math.abs(r[0].offsetLeft) - u * (0.9 * l.width());
              } else {
                if (!n.overflowed[0]) return;
                var c = 'y',
                  u = a.pageY > s.offset().top ? -1 : 1,
                  f = Math.abs(r[0].offsetTop) - u * (0.9 * l.height());
              }
              G(o, f.toString(), { dir: c, scrollEasing: 'mcsEaseInOut' });
            }
          });
      },
      H = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = a + '_' + o.idx,
          r = e('#mCSB_' + o.idx + '_container'),
          l = r.parent();
        r.bind('focusin.' + i, function() {
          var o = e(document.activeElement),
            a = r.find('.mCustomScrollBox').length,
            i = 0;
          o.is(n.advanced.autoScrollOnFocus) &&
            (Q(t),
            clearTimeout(t[0]._focusTimeout),
            (t[0]._focusTimer = a ? (i + 17) * a : 0),
            (t[0]._focusTimeout = setTimeout(function() {
              var e = [ae(o)[0], ae(o)[1]],
                a = [r[0].offsetTop, r[0].offsetLeft],
                s = [
                  a[0] + e[0] >= 0 && a[0] + e[0] < l.height() - o.outerHeight(!1),
                  a[1] + e[1] >= 0 && a[0] + e[1] < l.width() - o.outerWidth(!1),
                ],
                c = 'yx' !== n.axis || s[0] || s[1] ? 'all' : 'none';
              'x' === n.axis ||
                s[0] ||
                G(t, e[0].toString(), { dir: 'y', scrollEasing: 'mcsEaseInOut', overwrite: c, dur: i }),
                'y' === n.axis ||
                  s[1] ||
                  G(t, e[1].toString(), { dir: 'x', scrollEasing: 'mcsEaseInOut', overwrite: c, dur: i });
            }, t[0]._focusTimer)));
        });
      },
      U = function() {
        var t = e(this),
          o = t.data(a),
          n = a + '_' + o.idx,
          i = e('#mCSB_' + o.idx + '_container').parent();
        i.bind('scroll.' + n, function() {
          (0 === i.scrollTop() && 0 === i.scrollLeft()) ||
            e('.mCSB_' + o.idx + '_scrollbar').css('visibility', 'hidden');
        });
      },
      F = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = o.sequential,
          r = a + '_' + o.idx,
          l = '.mCSB_' + o.idx + '_scrollbar',
          s = e(l + '>a');
        s.bind('contextmenu.' + r, function(e) {
          e.preventDefault();
        }).bind(
          'mousedown.' +
            r +
            ' touchstart.' +
            r +
            ' pointerdown.' +
            r +
            ' MSPointerDown.' +
            r +
            ' mouseup.' +
            r +
            ' touchend.' +
            r +
            ' pointerup.' +
            r +
            ' MSPointerUp.' +
            r +
            ' mouseout.' +
            r +
            ' pointerout.' +
            r +
            ' MSPointerOut.' +
            r +
            ' click.' +
            r,
          function(a) {
            function r(e, o) {
              (i.scrollAmount = n.scrollButtons.scrollAmount), j(t, e, o);
            }
            if ((a.preventDefault(), ee(a))) {
              var l = e(this).attr('class');
              switch (((i.type = n.scrollButtons.scrollType), a.type)) {
                case 'mousedown':
                case 'touchstart':
                case 'pointerdown':
                case 'MSPointerDown':
                  if ('stepped' === i.type) return;
                  (c = !0), (o.tweenRunning = !1), r('on', l);
                  break;
                case 'mouseup':
                case 'touchend':
                case 'pointerup':
                case 'MSPointerUp':
                case 'mouseout':
                case 'pointerout':
                case 'MSPointerOut':
                  if ('stepped' === i.type) return;
                  (c = !1), i.dir && r('off', l);
                  break;
                case 'click':
                  if ('stepped' !== i.type || o.tweenRunning) return;
                  r('on', l);
              }
            }
          }
        );
      },
      q = function() {
        function t(t) {
          function a(e, t) {
            (r.type = i.keyboard.scrollType),
              (r.scrollAmount = i.keyboard.scrollAmount),
              ('stepped' === r.type && n.tweenRunning) || j(o, e, t);
          }
          switch (t.type) {
            case 'blur':
              n.tweenRunning && r.dir && a('off', null);
              break;
            case 'keydown':
            case 'keyup':
              var l = t.keyCode ? t.keyCode : t.which,
                s = 'on';
              if (('x' !== i.axis && (38 === l || 40 === l)) || ('y' !== i.axis && (37 === l || 39 === l))) {
                if (((38 === l || 40 === l) && !n.overflowed[0]) || ((37 === l || 39 === l) && !n.overflowed[1]))
                  return;
                'keyup' === t.type && (s = 'off'),
                  e(document.activeElement).is(u) || (t.preventDefault(), t.stopImmediatePropagation(), a(s, l));
              } else if (33 === l || 34 === l) {
                if (
                  ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()),
                  'keyup' === t.type)
                ) {
                  Q(o);
                  var f = 34 === l ? -1 : 1;
                  if ('x' === i.axis || ('yx' === i.axis && n.overflowed[1] && !n.overflowed[0]))
                    var h = 'x',
                      m = Math.abs(c[0].offsetLeft) - f * (0.9 * d.width());
                  else
                    var h = 'y',
                      m = Math.abs(c[0].offsetTop) - f * (0.9 * d.height());
                  G(o, m.toString(), { dir: h, scrollEasing: 'mcsEaseInOut' });
                }
              } else if (
                (35 === l || 36 === l) &&
                !e(document.activeElement).is(u) &&
                ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()),
                'keyup' === t.type)
              ) {
                if ('x' === i.axis || ('yx' === i.axis && n.overflowed[1] && !n.overflowed[0]))
                  var h = 'x',
                    m = 35 === l ? Math.abs(d.width() - c.outerWidth(!1)) : 0;
                else
                  var h = 'y',
                    m = 35 === l ? Math.abs(d.height() - c.outerHeight(!1)) : 0;
                G(o, m.toString(), { dir: h, scrollEasing: 'mcsEaseInOut' });
              }
          }
        }
        var o = e(this),
          n = o.data(a),
          i = n.opt,
          r = n.sequential,
          l = a + '_' + n.idx,
          s = e('#mCSB_' + n.idx),
          c = e('#mCSB_' + n.idx + '_container'),
          d = c.parent(),
          u = "input,textarea,select,datalist,keygen,[contenteditable='true']",
          f = c.find('iframe'),
          h = ['blur.' + l + ' keydown.' + l + ' keyup.' + l];
        f.length &&
          f.each(function() {
            e(this).bind('load', function() {
              A(this) &&
                e(this.contentDocument || this.contentWindow.document).bind(h[0], function(e) {
                  t(e);
                });
            });
          }),
          s.attr('tabindex', '0').bind(h[0], function(e) {
            t(e);
          });
      },
      j = function(t, o, n, i, r) {
        function l(e) {
          u.snapAmount &&
            (f.scrollAmount =
              u.snapAmount instanceof Array ? ('x' === f.dir[0] ? u.snapAmount[1] : u.snapAmount[0]) : u.snapAmount);
          var o = 'stepped' !== f.type,
            a = r ? r : e ? (o ? p / 1.5 : g) : 1e3 / 60,
            n = e ? (o ? 7.5 : 40) : 2.5,
            s = [Math.abs(h[0].offsetTop), Math.abs(h[0].offsetLeft)],
            d = [c.scrollRatio.y > 10 ? 10 : c.scrollRatio.y, c.scrollRatio.x > 10 ? 10 : c.scrollRatio.x],
            m = 'x' === f.dir[0] ? s[1] + f.dir[1] * (d[1] * n) : s[0] + f.dir[1] * (d[0] * n),
            v =
              'x' === f.dir[0]
                ? s[1] + f.dir[1] * parseInt(f.scrollAmount)
                : s[0] + f.dir[1] * parseInt(f.scrollAmount),
            x = 'auto' !== f.scrollAmount ? v : m,
            _ = i ? i : e ? (o ? 'mcsLinearOut' : 'mcsEaseInOut') : 'mcsLinear',
            w = !!e;
          return (
            e && 17 > a && (x = 'x' === f.dir[0] ? s[1] : s[0]),
            G(t, x.toString(), { dir: f.dir[0], scrollEasing: _, dur: a, onComplete: w }),
            e
              ? void (f.dir = !1)
              : (clearTimeout(f.step),
                void (f.step = setTimeout(function() {
                  l();
                }, a)))
          );
        }
        function s() {
          clearTimeout(f.step), $(f, 'step'), Q(t);
        }
        var c = t.data(a),
          u = c.opt,
          f = c.sequential,
          h = e('#mCSB_' + c.idx + '_container'),
          m = 'stepped' === f.type,
          p = u.scrollInertia < 26 ? 26 : u.scrollInertia,
          g = u.scrollInertia < 1 ? 17 : u.scrollInertia;
        switch (o) {
          case 'on':
            if (
              ((f.dir = [
                n === d[16] || n === d[15] || 39 === n || 37 === n ? 'x' : 'y',
                n === d[13] || n === d[15] || 38 === n || 37 === n ? -1 : 1,
              ]),
              Q(t),
              oe(n) && 'stepped' === f.type)
            )
              return;
            l(m);
            break;
          case 'off':
            s(), (m || (c.tweenRunning && f.dir)) && l(!0);
        }
      },
      Y = function(t) {
        var o = e(this).data(a).opt,
          n = [];
        return (
          'function' == typeof t && (t = t()),
          t instanceof Array
            ? (n = t.length > 1 ? [t[0], t[1]] : 'x' === o.axis ? [null, t[0]] : [t[0], null])
            : ((n[0] = t.y ? t.y : t.x || 'x' === o.axis ? null : t),
              (n[1] = t.x ? t.x : t.y || 'y' === o.axis ? null : t)),
          'function' == typeof n[0] && (n[0] = n[0]()),
          'function' == typeof n[1] && (n[1] = n[1]()),
          n
        );
      },
      X = function(t, o) {
        if (null != t && 'undefined' != typeof t) {
          var n = e(this),
            i = n.data(a),
            r = i.opt,
            l = e('#mCSB_' + i.idx + '_container'),
            s = l.parent(),
            c = typeof t;
          o || (o = 'x' === r.axis ? 'x' : 'y');
          var d = 'x' === o ? l.outerWidth(!1) - s.width() : l.outerHeight(!1) - s.height(),
            f = 'x' === o ? l[0].offsetLeft : l[0].offsetTop,
            h = 'x' === o ? 'left' : 'top';
          switch (c) {
            case 'function':
              return t();
            case 'object':
              var m = t.jquery ? t : e(t);
              if (!m.length) return;
              return 'x' === o ? ae(m)[1] : ae(m)[0];
            case 'string':
            case 'number':
              if (oe(t)) return Math.abs(t);
              if (-1 !== t.indexOf('%')) return Math.abs((d * parseInt(t)) / 100);
              if (-1 !== t.indexOf('-=')) return Math.abs(f - parseInt(t.split('-=')[1]));
              if (-1 !== t.indexOf('+=')) {
                var p = f + parseInt(t.split('+=')[1]);
                return p >= 0 ? 0 : Math.abs(p);
              }
              if (-1 !== t.indexOf('px') && oe(t.split('px')[0])) return Math.abs(t.split('px')[0]);
              if ('top' === t || 'left' === t) return 0;
              if ('bottom' === t) return Math.abs(s.height() - l.outerHeight(!1));
              if ('right' === t) return Math.abs(s.width() - l.outerWidth(!1));
              if ('first' === t || 'last' === t) {
                var m = l.find(':' + t);
                return 'x' === o ? ae(m)[1] : ae(m)[0];
              }
              return e(t).length
                ? 'x' === o
                  ? ae(e(t))[1]
                  : ae(e(t))[0]
                : (l.css(h, t), void u.update.call(null, n[0]));
          }
        }
      },
      N = function(t) {
        function o() {
          return (
            clearTimeout(f[0].autoUpdate),
            0 === l.parents('html').length
              ? void (l = null)
              : void (f[0].autoUpdate = setTimeout(function() {
                  return c.advanced.updateOnSelectorChange &&
                    ((s.poll.change.n = i()), s.poll.change.n !== s.poll.change.o)
                    ? ((s.poll.change.o = s.poll.change.n), void r(3))
                    : c.advanced.updateOnContentResize &&
                      ((s.poll.size.n =
                        l[0].scrollHeight +
                        l[0].scrollWidth +
                        f[0].offsetHeight +
                        l[0].offsetHeight +
                        l[0].offsetWidth),
                      s.poll.size.n !== s.poll.size.o)
                    ? ((s.poll.size.o = s.poll.size.n), void r(1))
                    : !c.advanced.updateOnImageLoad ||
                      ('auto' === c.advanced.updateOnImageLoad && 'y' === c.axis) ||
                      ((s.poll.img.n = f.find('img').length), s.poll.img.n === s.poll.img.o)
                    ? void (
                        (c.advanced.updateOnSelectorChange ||
                          c.advanced.updateOnContentResize ||
                          c.advanced.updateOnImageLoad) &&
                        o()
                      )
                    : ((s.poll.img.o = s.poll.img.n),
                      void f.find('img').each(function() {
                        n(this);
                      }));
                }, c.advanced.autoUpdateTimeout))
          );
        }
        function n(t) {
          function o(e, t) {
            return function() {
              return t.apply(e, arguments);
            };
          }
          function a() {
            (this.onload = null), e(t).addClass(d[2]), r(2);
          }
          if (e(t).hasClass(d[2])) return void r();
          var n = new Image();
          (n.onload = o(n, a)), (n.src = t.src);
        }
        function i() {
          c.advanced.updateOnSelectorChange === !0 && (c.advanced.updateOnSelectorChange = '*');
          var e = 0,
            t = f.find(c.advanced.updateOnSelectorChange);
          return (
            c.advanced.updateOnSelectorChange &&
              t.length > 0 &&
              t.each(function() {
                e += this.offsetHeight + this.offsetWidth;
              }),
            e
          );
        }
        function r(e) {
          clearTimeout(f[0].autoUpdate), u.update.call(null, l[0], e);
        }
        var l = e(this),
          s = l.data(a),
          c = s.opt,
          f = e('#mCSB_' + s.idx + '_container');
        return t ? (clearTimeout(f[0].autoUpdate), void $(f[0], 'autoUpdate')) : void o();
      },
      V = function(e, t, o) {
        return Math.round(e / t) * t - o;
      },
      Q = function(t) {
        var o = t.data(a),
          n = e(
            '#mCSB_' +
              o.idx +
              '_container,#mCSB_' +
              o.idx +
              '_container_wrapper,#mCSB_' +
              o.idx +
              '_dragger_vertical,#mCSB_' +
              o.idx +
              '_dragger_horizontal'
          );
        n.each(function() {
          Z.call(this);
        });
      },
      G = function(t, o, n) {
        function i(e) {
          return s && c.callbacks[e] && 'function' == typeof c.callbacks[e];
        }
        function r() {
          return [c.callbacks.alwaysTriggerOffsets || w >= S[0] + y, c.callbacks.alwaysTriggerOffsets || -B >= w];
        }
        function l() {
          var e = [h[0].offsetTop, h[0].offsetLeft],
            o = [x[0].offsetTop, x[0].offsetLeft],
            a = [h.outerHeight(!1), h.outerWidth(!1)],
            i = [f.height(), f.width()];
          t[0].mcs = {
            content: h,
            top: e[0],
            left: e[1],
            draggerTop: o[0],
            draggerLeft: o[1],
            topPct: Math.round((100 * Math.abs(e[0])) / (Math.abs(a[0]) - i[0])),
            leftPct: Math.round((100 * Math.abs(e[1])) / (Math.abs(a[1]) - i[1])),
            direction: n.dir,
          };
        }
        var s = t.data(a),
          c = s.opt,
          d = {
            trigger: 'internal',
            dir: 'y',
            scrollEasing: 'mcsEaseOut',
            drag: !1,
            dur: c.scrollInertia,
            overwrite: 'all',
            callbacks: !0,
            onStart: !0,
            onUpdate: !0,
            onComplete: !0,
          },
          n = e.extend(d, n),
          u = [n.dur, n.drag ? 0 : n.dur],
          f = e('#mCSB_' + s.idx),
          h = e('#mCSB_' + s.idx + '_container'),
          m = h.parent(),
          p = c.callbacks.onTotalScrollOffset ? Y.call(t, c.callbacks.onTotalScrollOffset) : [0, 0],
          g = c.callbacks.onTotalScrollBackOffset ? Y.call(t, c.callbacks.onTotalScrollBackOffset) : [0, 0];
        if (
          ((s.trigger = n.trigger),
          (0 === m.scrollTop() && 0 === m.scrollLeft()) ||
            (e('.mCSB_' + s.idx + '_scrollbar').css('visibility', 'visible'), m.scrollTop(0).scrollLeft(0)),
          '_resetY' !== o ||
            s.contentReset.y ||
            (i('onOverflowYNone') && c.callbacks.onOverflowYNone.call(t[0]), (s.contentReset.y = 1)),
          '_resetX' !== o ||
            s.contentReset.x ||
            (i('onOverflowXNone') && c.callbacks.onOverflowXNone.call(t[0]), (s.contentReset.x = 1)),
          '_resetY' !== o && '_resetX' !== o)
        ) {
          if (
            ((!s.contentReset.y && t[0].mcs) ||
              !s.overflowed[0] ||
              (i('onOverflowY') && c.callbacks.onOverflowY.call(t[0]), (s.contentReset.x = null)),
            (!s.contentReset.x && t[0].mcs) ||
              !s.overflowed[1] ||
              (i('onOverflowX') && c.callbacks.onOverflowX.call(t[0]), (s.contentReset.x = null)),
            c.snapAmount)
          ) {
            var v = c.snapAmount instanceof Array ? ('x' === n.dir ? c.snapAmount[1] : c.snapAmount[0]) : c.snapAmount;
            o = V(o, v, c.snapOffset);
          }
          switch (n.dir) {
            case 'x':
              var x = e('#mCSB_' + s.idx + '_dragger_horizontal'),
                _ = 'left',
                w = h[0].offsetLeft,
                S = [f.width() - h.outerWidth(!1), x.parent().width() - x.width()],
                b = [o, 0 === o ? 0 : o / s.scrollRatio.x],
                y = p[1],
                B = g[1],
                T = y > 0 ? y / s.scrollRatio.x : 0,
                k = B > 0 ? B / s.scrollRatio.x : 0;
              break;
            case 'y':
              var x = e('#mCSB_' + s.idx + '_dragger_vertical'),
                _ = 'top',
                w = h[0].offsetTop,
                S = [f.height() - h.outerHeight(!1), x.parent().height() - x.height()],
                b = [o, 0 === o ? 0 : o / s.scrollRatio.y],
                y = p[0],
                B = g[0],
                T = y > 0 ? y / s.scrollRatio.y : 0,
                k = B > 0 ? B / s.scrollRatio.y : 0;
          }
          b[1] < 0 || (0 === b[0] && 0 === b[1]) ? (b = [0, 0]) : b[1] >= S[1] ? (b = [S[0], S[1]]) : (b[0] = -b[0]),
            t[0].mcs || (l(), i('onInit') && c.callbacks.onInit.call(t[0])),
            clearTimeout(h[0].onCompleteTimeout),
            J(x[0], _, Math.round(b[1]), u[1], n.scrollEasing),
            (!s.tweenRunning && ((0 === w && b[0] >= 0) || (w === S[0] && b[0] <= S[0]))) ||
              J(h[0], _, Math.round(b[0]), u[0], n.scrollEasing, n.overwrite, {
                onStart: function() {
                  n.callbacks &&
                    n.onStart &&
                    !s.tweenRunning &&
                    (i('onScrollStart') && (l(), c.callbacks.onScrollStart.call(t[0])),
                    (s.tweenRunning = !0),
                    C(x),
                    (s.cbOffsets = r()));
                },
                onUpdate: function() {
                  n.callbacks && n.onUpdate && i('whileScrolling') && (l(), c.callbacks.whileScrolling.call(t[0]));
                },
                onComplete: function() {
                  if (n.callbacks && n.onComplete) {
                    'yx' === c.axis && clearTimeout(h[0].onCompleteTimeout);
                    var e = h[0].idleTimer || 0;
                    h[0].onCompleteTimeout = setTimeout(function() {
                      i('onScroll') && (l(), c.callbacks.onScroll.call(t[0])),
                        i('onTotalScroll') &&
                          b[1] >= S[1] - T &&
                          s.cbOffsets[0] &&
                          (l(), c.callbacks.onTotalScroll.call(t[0])),
                        i('onTotalScrollBack') &&
                          b[1] <= k &&
                          s.cbOffsets[1] &&
                          (l(), c.callbacks.onTotalScrollBack.call(t[0])),
                        (s.tweenRunning = !1),
                        (h[0].idleTimer = 0),
                        C(x, 'hide');
                    }, e);
                  }
                },
              });
        }
      },
      J = function(e, t, o, a, n, i, r) {
        function l() {
          S.stop ||
            (x || m.call(),
            (x = K() - v),
            s(),
            x >= S.time &&
              ((S.time = x > S.time ? x + f - (x - S.time) : x + f - 1), S.time < x + 1 && (S.time = x + 1)),
            S.time < a ? (S.id = h(l)) : g.call());
        }
        function s() {
          a > 0 ? ((S.currVal = u(S.time, _, b, a, n)), (w[t] = Math.round(S.currVal) + 'px')) : (w[t] = o + 'px'),
            p.call();
        }
        function c() {
          (f = 1e3 / 60),
            (S.time = x + f),
            (h = window.requestAnimationFrame
              ? window.requestAnimationFrame
              : function(e) {
                  return s(), setTimeout(e, 0.01);
                }),
            (S.id = h(l));
        }
        function d() {
          null != S.id &&
            (window.requestAnimationFrame ? window.cancelAnimationFrame(S.id) : clearTimeout(S.id), (S.id = null));
        }
        function u(e, t, o, a, n) {
          switch (n) {
            case 'linear':
            case 'mcsLinear':
              return (o * e) / a + t;
            case 'mcsLinearOut':
              return (e /= a), e--, o * Math.sqrt(1 - e * e) + t;
            case 'easeInOutSmooth':
              return (e /= a / 2), 1 > e ? (o / 2) * e * e + t : (e--, (-o / 2) * (e * (e - 2) - 1) + t);
            case 'easeInOutStrong':
              return (
                (e /= a / 2),
                1 > e ? (o / 2) * Math.pow(2, 10 * (e - 1)) + t : (e--, (o / 2) * (-Math.pow(2, -10 * e) + 2) + t)
              );
            case 'easeInOut':
            case 'mcsEaseInOut':
              return (e /= a / 2), 1 > e ? (o / 2) * e * e * e + t : ((e -= 2), (o / 2) * (e * e * e + 2) + t);
            case 'easeOutSmooth':
              return (e /= a), e--, -o * (e * e * e * e - 1) + t;
            case 'easeOutStrong':
              return o * (-Math.pow(2, (-10 * e) / a) + 1) + t;
            case 'easeOut':
            case 'mcsEaseOut':
            default:
              var i = (e /= a) * e,
                r = i * e;
              return t + o * (0.499999999999997 * r * i + -2.5 * i * i + 5.5 * r + -6.5 * i + 4 * e);
          }
        }
        e._mTween || (e._mTween = { top: {}, left: {} });
        var f,
          h,
          r = r || {},
          m = r.onStart || function() {},
          p = r.onUpdate || function() {},
          g = r.onComplete || function() {},
          v = K(),
          x = 0,
          _ = e.offsetTop,
          w = e.style,
          S = e._mTween[t];
        'left' === t && (_ = e.offsetLeft);
        var b = o - _;
        (S.stop = 0), 'none' !== i && d(), c();
      },
      K = function() {
        return window.performance && window.performance.now
          ? window.performance.now()
          : window.performance && window.performance.webkitNow
          ? window.performance.webkitNow()
          : Date.now
          ? Date.now()
          : new Date().getTime();
      },
      Z = function() {
        var e = this;
        e._mTween || (e._mTween = { top: {}, left: {} });
        for (var t = ['top', 'left'], o = 0; o < t.length; o++) {
          var a = t[o];
          e._mTween[a].id &&
            (window.requestAnimationFrame
              ? window.cancelAnimationFrame(e._mTween[a].id)
              : clearTimeout(e._mTween[a].id),
            (e._mTween[a].id = null),
            (e._mTween[a].stop = 1));
        }
      },
      $ = function(e, t) {
        try {
          delete e[t];
        } catch (o) {
          e[t] = null;
        }
      },
      ee = function(e) {
        return !(e.which && 1 !== e.which);
      },
      te = function(e) {
        var t = e.originalEvent.pointerType;
        return !(t && 'touch' !== t && 2 !== t);
      },
      oe = function(e) {
        return !isNaN(parseFloat(e)) && isFinite(e);
      },
      ae = function(e) {
        var t = e.parents('.mCSB_container');
        return [e.offset().top - t.offset().top, e.offset().left - t.offset().left];
      },
      ne = function() {
        function e() {
          var e = ['webkit', 'moz', 'ms', 'o'];
          if ('hidden' in document) return 'hidden';
          for (var t = 0; t < e.length; t++) if (e[t] + 'Hidden' in document) return e[t] + 'Hidden';
          return null;
        }
        var t = e();
        return t ? document[t] : !1;
      };
    (e.fn[o] = function(t) {
      return u[t]
        ? u[t].apply(this, Array.prototype.slice.call(arguments, 1))
        : 'object' != typeof t && t
        ? void e.error('Method ' + t + ' does not exist')
        : u.init.apply(this, arguments);
    }),
      (e[o] = function(t) {
        return u[t]
          ? u[t].apply(this, Array.prototype.slice.call(arguments, 1))
          : 'object' != typeof t && t
          ? void e.error('Method ' + t + ' does not exist')
          : u.init.apply(this, arguments);
      }),
      (e[o].defaults = i),
      (window[o] = !0),
      e(window).bind('load', function() {
        e(n)[o](),
          e.extend(e.expr[':'], {
            mcsInView:
              e.expr[':'].mcsInView ||
              function(t) {
                var o,
                  a,
                  n = e(t),
                  i = n.parents('.mCSB_container');
                if (i.length)
                  return (
                    (o = i.parent()),
                    (a = [i[0].offsetTop, i[0].offsetLeft]),
                    a[0] + ae(n)[0] >= 0 &&
                      a[0] + ae(n)[0] < o.height() - n.outerHeight(!1) &&
                      a[1] + ae(n)[1] >= 0 &&
                      a[1] + ae(n)[1] < o.width() - n.outerWidth(!1)
                  );
              },
            mcsInSight:
              e.expr[':'].mcsInSight ||
              function(t, o, a) {
                var n,
                  i,
                  r,
                  l,
                  s = e(t),
                  c = s.parents('.mCSB_container'),
                  d =
                    'exact' === a[3]
                      ? [
                          [1, 0],
                          [1, 0],
                        ]
                      : [
                          [0.9, 0.1],
                          [0.6, 0.4],
                        ];
                if (c.length)
                  return (
                    (n = [s.outerHeight(!1), s.outerWidth(!1)]),
                    (r = [c[0].offsetTop + ae(s)[0], c[0].offsetLeft + ae(s)[1]]),
                    (i = [c.parent()[0].offsetHeight, c.parent()[0].offsetWidth]),
                    (l = [n[0] < i[0] ? d[0] : d[1], n[1] < i[1] ? d[0] : d[1]]),
                    r[0] - i[0] * l[0][0] < 0 &&
                      r[0] + n[0] - i[0] * l[0][1] >= 0 &&
                      r[1] - i[1] * l[1][0] < 0 &&
                      r[1] + n[1] - i[1] * l[1][1] >= 0
                  );
              },
            mcsOverflow:
              e.expr[':'].mcsOverflow ||
              function(t) {
                var o = e(t).data(a);
                if (o) return o.overflowed[0] || o.overflowed[1];
              },
          });
      });
  });
});

/**
 *  Zebra_DatePicker
 *
 *  Zebra_DatePicker is a small, compact and highly configurable date picker plugin for jQuery
 *
 *  Visit {@link http://stefangabos.ro/jquery/zebra-datepicker/} for more information.
 *
 *  For more resources visit {@link http://stefangabos.ro/}
 *
 *  @author     Stefan Gabos <contact@stefangabos.ro>
 *  @version    1.9.5 (last revision: May 13, 2016)
 *  @copyright  (c) 2011 - 2016 Stefan Gabos
 *  @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE
 *  @package    Zebra_DatePicker
 */
(function(factory) {
  'use strict';

  // AMD
  if (typeof define === 'function' && define.amd) define(['jquery'], factory);
  // CommonJS
  else if (typeof exports === 'object') factory(require('jquery'));
  // browser globals
  else factory(jQuery);
})(function($) {
  'use strict';

  $.Zebra_DatePicker = function(element, options) {
    var defaults = {
      //  setting this property to a jQuery element, will result in the date picker being always visible, the indicated
      //  element being the date picker's container;
      always_visible: false,

      //  by default, the date picker is injected into the <body>; use this property to tell the library to inject
      //  the date picker into a custom element - useful when you want the date picker to open at a specific position
      //
      //  must be a jQuery element
      //
      //  default is $('body')
      container: $('body'),

      //  dates that should have custom classes applied to them
      //  an object in the form of
      //  {
      //      'myclass1': [dates_to_apply_the_custom_class_to],
      //      'myclass2': [dates_to_apply_the_custom_class_to]
      //  }
      //  where "dates_to_apply_the_custom_class_to" is an array of dates in the same format as required for
      //  "disabled_dates" property.
      //
      //  custom classes will be applied *only* in the day picker view and not on month/year views!
      //  also note that the class name will have the "_disabled" suffix added if the day the class is applied to
      //  is disabled
      //
      //  in order for the styles in your custom classes to be applied, make sure you are using the following syntax:
      //
      //  .Zebra_DatePicker .dp_daypicker td.myclass1 { .. }
      //  .Zebra_DatePicker .dp_daypicker td.myclass1_disabled { .. }
      //
      //  default is FALSE, no custom classes
      custom_classes: false,

      //  days of the week; Sunday to Saturday
      days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],

      //  by default, the abbreviated name of a day consists of the first 2 letters from the day's full name;
      //  while this is common for most languages, there are also exceptions for languages like Thai, Loa, Myanmar,
      //  etc. where this is not correct; for these cases, specify an array with the abbreviations to be used for
      //  the 7 days of the week; leave it FALSE to use the first 2 letters of a day's name as the abbreviation.
      //
      //  default is FALSE
      days_abbr: false,

      //  the position of the date picker relative to the element it is attached to. note that, regardless of this
      //  setting, the date picker's position will be automatically adjusted to fit in the viewport, if needed.
      //
      //  possible values are "above" and "below"
      //
      //  default is "above"
      default_position: 'above',

      //  direction of the calendar
      //
      //  a positive or negative integer: n (a positive integer) creates a future-only calendar beginning at n days
      //  after today; -n (a negative integer); if n is 0, the calendar has no restrictions. use boolean true for
      //  a future-only calendar starting with today and use boolean false for a past-only calendar ending today.
      //
      //  you may also set this property to an array with two elements in the following combinations:
      //
      //  -   first item is boolean TRUE (calendar starts today), an integer > 0 (calendar starts n days after
      //      today), or a valid date given in the format defined by the "format" attribute, using English for
      //      month names (calendar starts at the specified date), and the second item is boolean FALSE (the calendar
      //      has no ending date), an integer > 0 (calendar ends n days after the starting date), or a valid date
      //      given in the format defined by the "format" attribute, using English for month names, and which occurs
      //      after the starting date (calendar ends at the specified date)
      //
      //  -   first item is boolean FALSE (calendar ends today), an integer < 0 (calendar ends n days before today),
      //      or a valid date given in the format defined by the "format" attribute, using English for month names
      //      (calendar ends at the specified date), and the second item is an integer > 0 (calendar ends n days
      //      before the ending date), or a valid date given in the format defined by the "format" attribute, using
      //      English for month names  and which occurs before the starting date (calendar starts at the specified
      //      date)
      //
      //  [1, 7] - calendar starts tomorrow and ends seven days after that
      //  [true, 7] - calendar starts today and ends seven days after that
      //  ['2013-01-01', false] - calendar starts on January 1st 2013 and has no ending date ("format" is YYYY-MM-DD)
      //  [false, '2012-01-01'] - calendar ends today and starts on January 1st 2012 ("format" is YYYY-MM-DD)
      //
      //  note that "disabled_dates" property will still apply!
      //
      //  default is 0 (no restrictions)
      direction: 0,

      //  an array of disabled dates in the following format: 'day month year weekday' where "weekday" is optional
      //  and can be 0-6 (Saturday to Sunday); the syntax is similar to cron's syntax: the values are separated by
      //  spaces and may contain * (asterisk) - (dash) and , (comma) delimiters:
      //
      //  ['1 1 2012'] would disable January 1, 2012;
      //  ['* 1 2012'] would disable all days in January 2012;
      //  ['1-10 1 2012'] would disable January 1 through 10 in 2012;
      //  ['1,10 1 2012'] would disable January 1 and 10 in 2012;
      //  ['1-10,20,22,24 1-3 *'] would disable 1 through 10, plus the 22nd and 24th of January through March for every year;
      //  ['* * * 0,6'] would disable all Saturdays and Sundays;
      //  ['01 07 2012', '02 07 2012', '* 08 2012'] would disable 1st and 2nd of July 2012, and all of August of 2012
      //
      //  default is FALSE, no disabled dates
      //
      //  DISABLING ALL DATES AND NOT SPECIFYING AT LEAST ONE ENABLED DATE WILL SEND THE SCRIPT INTO AN INFINITE
      //  LOOP SEARCHING FOR AN ENABLED DATE TO DISPLAY!
      disabled_dates: false,

      //  an array of enabled dates in the same format as required for "disabled_dates" property.
      //  to be used together with the "disabled_dates" property by first setting the "disabled_dates" property to
      //  something like "[* * * *]" (which will disable everything) and the setting the "enabled_dates" property to,
      //  say, "[* * * 0,6]" to enable just weekends.
      enabled_dates: false,

      //  week's starting day
      //
      //  valid values are 0 to 6, Sunday to Saturday
      //
      //  default is 1, Monday
      first_day_of_week: 1,

      //  format of the returned date
      //
      //  accepts the following characters for date formatting: d, D, j, l, N, w, S, F, m, M, n, Y, y borrowing
      //  syntax from PHP's "date" function.
      //
      //  note that when setting a date format without days ('d', 'j'), the users will be able to select only years
      //  and months, and when setting a format without months and days ('F', 'm', 'M', 'n', 'd', 'j'), the
      //  users will be able to select only years; likewise, when setting a date format with just months ('F', 'm',
      //  'M', 'n') or just years ('Y', 'y'), users will be able to select only months and years, respectively.
      //
      //  also note that the value of the "view" property (see below) may be overridden if it is the case: a value of
      //  "days" for the "view" property makes no sense if the date format doesn't allow the selection of days.
      //
      //  default is Y-m-d
      format: 'Y-m-d',

      //  captions in the datepicker's header, for the 3 possible views: days, months, years
      //
      //  for each of the 3 views the following special characters may be used borrowing from PHP's "date" function's
      //  syntax: m, n, F, M, y and Y; any of these will be replaced at runtime with the appropriate date fragment,
      //  depending on the currently viewed date. two more special characters are also available Y1 and Y2 (upper
      //  case representing years with 4 digits, lowercase representing years with 2 digits) which represent
      //  "currently selected year - 7" and "currently selected year + 4" and which only make sense used in the
      //  "years" view.
      //
      //  even though any of these special characters may be used in any of the 3 views, you should use m, n, F, M
      //  for the "days" view and y, Y, Y1, Y2, y1, y2 for the "months" and "years" view or you may get unexpected
      //  results!
      //
      //  Text and HTML can also be used, and will be rendered as it is, as in the example below (the library is
      //  smart enough to not replace special characters when used in words or HTML tags):
      //
      //  header_captions: {
      //      'days':     'Departure:<br>F, Y',
      //      'months':   'Departure:<br>Y',
      //      'years':    'Departure:<br>Y1 - Y2'
      //  }
      //
      //  Default is
      //
      //  header_captions: {
      //      'days':     'F, Y',
      //      'months':   'Y',
      //      'years':    'Y1 - Y2'
      //  }
      header_captions: {
        days: 'F, Y',
        months: 'Y',
        years: 'Y1 - Y2',
      },

      //  HTML to be used for the previous month/next month buttons
      //
      //  default is ['&#171;','&#187;']
      header_navigation: ['&#171;', '&#187;'],

      //  icon's position
      //  accepted values are "left" and "right"
      //
      //  default is "right"
      icon_position: 'right',

      //  should the icon for opening the datepicker be inside the element?
      //  if set to FALSE, the icon will be placed to the right of the parent element, while if set to TRUE it will
      //  be placed to the right of the parent element, but *inside* the element itself
      //
      //  default is TRUE
      inside: true,

      //  the caption for the "Clear" button
      lang_clear_date: 'Clear date',

      //  months names
      months: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
      ],

      //  by default, the abbreviated name of a month consists of the first 3 letters from the month's full name;
      //  while this is common for most languages, there are also exceptions for languages like Thai, Loa, Myanmar,
      //  etc. where this is not correct; for these cases, specify an array with the abbreviations to be used for
      //  the months of the year; leave it FALSE to use the first 3 letters of a month's name as the abbreviation.
      //
      //  default is FALSE
      months_abbr: false,

      //  the offset, in pixels (x, y), to shift the date picker's position relative to the top-right of the icon
      //  that toggles the date picker or, if the icon is disabled, relative to the top-right corner of the element
      //  the plugin is attached to.
      //
      //  note that this only applies if the position of element relative to the browser's viewport doesn't require
      //  the date picker to be placed automatically so that it is visible!
      //
      //  default is [5, -5]
      offset: [5, -5],

      //  set whether the date picker should be shown *only* when clicking the icon
      //  note that if you set the "show_icon" property to FALSE, you will not be able to show the date picker anymore!
      //
      //  default is FALSE
      open_icon_only: false,

      //  if set as a jQuery element with a Zebra_DatePicker attached, that particular date picker will use the
      //  current date picker's value as starting date
      //  note that the rules set in the "direction" property will still apply, only that the reference date will
      //  not be the current system date but the value selected in the current date picker
      //  default is FALSE (not paired with another date picker)
      pair: false,

      //  should the element the calendar is attached to, be read-only?
      //  if set to TRUE, a date can be set only through the date picker and cannot be entered manually
      //
      //  default is TRUE
      readonly_element: true,

      //  should days from previous and/or next month be selectable when visible?
      //  note that if the value of this property is set to TRUE, the value of "show_other_months" will be considered
      //  TRUE regardless of the actual value!
      //
      //  default is FALSE
      select_other_months: false,

      //  should the "Clear date" button be visible?
      //
      //  accepted values are:
      //
      //  - 0 (zero) - the button for clearing a previously selected date is shown only if a previously selected date
      //  already exists; this means that if the input the date picker is attached to is empty, and the user selects
      //  a date for the first time, this button will not be visible; once the user picked a date and opens the date
      //  picker again, this time the button will be visible.
      //
      //  - TRUE will make the button visible all the time
      //
      //  - FALSE will disable the button
      //
      //  default is "0" (without quotes)
      show_clear_date: 0,

      //  should a calendar icon be added to the elements the plugin is attached to?
      //
      //  default is TRUE
      show_icon: true,

      //  should days from previous and/or next month be visible?
      //
      //  default is TRUE
      show_other_months: true,

      //  should the "Today" button be visible?
      //  setting it to anything but boolean FALSE will enable the button and will use the property's value as
      //  caption for the button; setting it to FALSE will disable the button
      //
      //  default is "Today"
      show_select_today: 'Today',

      //  should an extra column be shown, showing the number of each week?
      //  anything other than FALSE will enable this feature, and use the given value as column title
      //  i.e. show_week_number: 'Wk' would enable this feature and have "Wk" as the column's title
      //
      //  default is FALSE
      show_week_number: false,

      //  a default date to start the date picker with
      //  must be specified in the format defined by the "format" property, or it will be ignored!
      //  note that this value is used only if there is no value in the field the date picker is attached to!
      start_date: false,

      //  should default values, in the input field the date picker is attached to, be deleted if they are not valid
      //  according to "direction" and/or "disabled_dates"?
      //
      //  default is FALSE
      strict: false,

      //  how should the date picker start; valid values are "days", "months" and "years"
      //  note that the date picker is always cycling days-months-years when clicking in the date picker's header,
      //  and years-months-days when selecting dates (unless one or more of the views are missing due to the date's
      //  format)
      //
      //  also note that the value of the "view" property may be overridden if the date's format requires so! (i.e.
      //  "days" for the "view" property makes no sense if the date format doesn't allow the selection of days)
      //
      //  default is "days"
      view: 'days',

      //  days of the week that are considered "weekend days"
      //  valid values are 0 to 6, Sunday to Saturday
      //
      //  default values are 0 and 6 (Saturday and Sunday)
      weekend_days: [0, 6],

      //  when set to TRUE, day numbers < 10 will be prefixed with 0; set to FALSE if you don't want that
      //
      //  default is TRUE
      zero_pad: false,

      //  callback function to be executed whenever the user changes the view (days/months/years), as well as when
      //  the user navigates by clicking on the "next"/"previous" icons in any of the views;
      //
      //  the callback function called by this event takes 3 arguments - the first argument represents the current
      //  view (can be "days", "months" or "years"), the second argument represents an array containing the "active"
      //  elements (not disabled) from the view, as jQuery elements, allowing for easy customization and interaction
      //  with particular cells in the date picker's view, while the third argument is a reference to the element
      //  the date picker is attached to, as a jQuery object (deprecated - use the "this" keyword inside the callback
      //  function to refer to the element the date picker is attached to)
      //
      //  for simplifying searching for particular dates, each element in the second argument will also have a
      //  "date" data attribute whose format depends on the value of the "view" argument:
      //  - YYYY-MM-DD for elements in the "days" view
      //  - YYYY-MM for elements in the "months" view
      //  - YYYY for elements in the "years" view
      //
      //  the "this" keyword inside the callback function refers to the element the date picker is attached to!
      onChange: null,

      //  callback function to be executed when the user clicks the "Clear" button
      //  the callback function takes a single argument:
      //  -   a reference to the element the date picker is attached to, as a jQuery object (deprecated - use the
      //      "this" keyword inside the callback function to refer to the element the date picker is attached to)
      //
      //  the "this" keyword inside the callback function refers to the element the date picker is attached to!
      onClear: null,

      //  callback function to be executed when the date picker is shown
      //  the callback function takes a single argument:
      //  -   a reference to the element the date picker is attached to, as a jQuery object (deprecated - use the
      //      "this" keyword inside the callback function to refer to the element the date picker is attached to)
      //
      //  the "this" keyword inside the callback function refers to the element the date picker is attached to!
      onOpen: null,

      //  callback function to be executed when the date picker is closed, but only when the "always_visible"
      //  property is set to FALSE
      //  the callback function takes a single argument:
      //  -   a reference to the element the date picker is attached to, as a jQuery object (deprecated - use the
      //      "this" keyword inside the callback function to refer to the element the date picker is attached to)
      //
      //  the "this" keyword inside the callback function refers to the element the date picker is attached to!
      onClose: null,

      //  callback function to be executed when a date is selected
      //  the callback function takes 5 arguments:
      //  -   the date in the format specified by the "format" attribute;
      //  -   the date in YYYY-MM-DD format
      //  -   the date as a JavaScript Date object
      //  -   a reference to the element the date picker is attached to, as a jQuery object (deprecated - use the
      //      "this" keyword inside the callback function to refer to the element the date picker is attached to)
      //  -   the ISO 8601 week number of the selected date
      //
      //  the "this" keyword inside the callback function refers to the element the date picker is attached to!
      onSelect: null,
    };

    // private properties
    var view,
      datepicker,
      icon,
      header,
      daypicker,
      monthpicker,
      yearpicker,
      cleardate,
      current_system_month,
      current_system_year,
      current_system_day,
      first_selectable_month,
      first_selectable_year,
      first_selectable_day,
      selected_month,
      selected_year,
      default_day,
      default_month,
      default_year,
      enabled_dates,
      disabled_dates,
      shim,
      start_date,
      end_date,
      last_selectable_day,
      last_selectable_year,
      last_selectable_month,
      daypicker_cells,
      monthpicker_cells,
      yearpicker_cells,
      views,
      clickables,
      selecttoday,
      footer,
      show_select_today,
      timeout,
      uniqueid,
      custom_classes,
      custom_class_names,
      original_attributes = {};

    var plugin = this;

    plugin.settings = {};

    // the jQuery version of the element
    // "element" (without the $) will point to the DOM element
    var $element = $(element);

    /**
     *  Constructor method. Initializes the date picker.
     *
     *  @return void
     */
    var init = function(update) {
      // generate a random ID for each date picker (we'll use this if later a certain date picker is destroyed to
      // remove related events)
      // the code is taken from http://stackoverflow.com/a/105074
      uniqueid = Math.floor((1 + Math.random()) * 0x10000).toString(16);

      // unless we're not just updating settings
      if (!update) {
        // merge default settings with user-settings (
        plugin.settings = $.extend({}, defaults, options);

        // preserve some of element's original attributes
        original_attributes['readonly'] = $element.attr('readonly');
        original_attributes['style'] = $element.attr('style');

        // iterate through the element's data attributes (if any)
        // if data attribute's name starts with "zdp_"
        for (var data in $element.data())
          if (data.indexOf('zdp_') === 0) {
            // remove the "zdp_" prefix
            data = data.replace(/^zdp\_/, '');

            // if such a property exists
            if (undefined !== defaults[data])
              // update the property's value
              // (note that for the "pair" property we need to convert the property to an element)
              plugin.settings[data] = data == 'pair' ? $($element.data('zdp_' + data)) : $element.data('zdp_' + data);
          }
      }

      // if the element should be read-only, set the "readonly" attribute
      if (plugin.settings.readonly_element) $element.attr('readonly', 'readonly');

      // determine the views the user can cycle through, depending on the format
      // that is, if the format doesn't contain the day, the user will be able to cycle only through years and months,
      // whereas if the format doesn't contain months nor days, the user will only be able to select years

      var // the characters that may be present in the date format and that represent days, months and years
        date_chars = {
          days: ['d', 'j', 'D'],
          months: ['F', 'm', 'M', 'n', 't'],
          years: ['o', 'Y', 'y'],
        },
        // some defaults
        has_days = false,
        has_months = false,
        has_years = false,
        type = null;

      // iterate through all the character blocks
      // iterate through the characters of each block
      for (type in date_chars)
        $.each(date_chars[type], function(index, character) {
          // if current character exists in the "format" property
          if (plugin.settings.format.indexOf(character) > -1)
            if (type == 'days')
              // set to TRUE the appropriate flag
              has_days = true;
            else if (type == 'months') has_months = true;
            else if (type == 'years') has_years = true;
        });

      // if user can cycle through all the views, set the flag accordingly
      if (has_days && has_months && has_years) views = ['years', 'months', 'days'];
      // if user can cycle only through year and months, set the flag accordingly
      else if (!has_days && has_months && has_years) views = ['years', 'months'];
      // if user can cycle only through months and days, set the flag accordingly
      else if (has_days && has_months && !has_years) views = ['months', 'days'];
      // if user can only see the year picker, set the flag accordingly
      else if (!has_days && !has_months && has_years) views = ['years'];
      // if user can only see the month picker, set the flag accordingly
      else if (!has_days && has_months && !has_years) views = ['months'];
      // if invalid format (no days, no months, no years) use the default where the user is able to cycle through
      // all the views
      else views = ['years', 'months', 'days'];

      // if the starting view is not amongst the views the user can cycle through, set the correct starting view
      if ($.inArray(plugin.settings.view, views) == -1) plugin.settings.view = views[views.length - 1];

      // parse the rules for disabling dates and turn them into arrays of arrays

      // array that will hold the rules for enabling/disabling dates
      disabled_dates = [];
      enabled_dates = [];
      custom_classes = {};
      custom_class_names = [];

      var dates;

      for (var k in plugin.settings.custom_classes)
        if (plugin.settings.custom_classes.hasOwnProperty(k)) custom_class_names.push(k);

      // it's the same logic for preparing the enabled/disable dates, as well as dates that have custom classes
      for (var l = 0; l < 2 + custom_class_names.length; l++) {
        // first time we're doing disabled dates,
        if (l === 0) dates = plugin.settings.disabled_dates;
        // second time we're doing enabled_dates
        else if (l == 1) dates = plugin.settings.enabled_dates;
        // otherwise, we're doing dates that will have custom classes
        else dates = plugin.settings.custom_classes[custom_class_names[l - 2]];

        // if we have a non-empty array
        if ($.isArray(dates) && dates.length > 0)
          // iterate through the rules
          $.each(dates, function() {
            // split the values in rule by white space
            var rules = this.split(' ');

            // there can be a maximum of 4 rules (days, months, years and, optionally, day of the week)
            for (var i = 0; i < 4; i++) {
              // if one of the values is not available
              // replace it with a * (wildcard)
              if (!rules[i]) rules[i] = '*';

              // if rule contains a comma, create a new array by splitting the rule by commas
              // if there are no commas create an array containing the rule's string
              rules[i] = rules[i].indexOf(',') > -1 ? rules[i].split(',') : new Array(rules[i]);

              // iterate through the items in the rule
              for (var j = 0; j < rules[i].length; j++)
                // if item contains a dash (defining a range)
                if (rules[i][j].indexOf('-') > -1) {
                  // get the lower and upper limits of the range
                  var limits = rules[i][j].match(/^([0-9]+)\-([0-9]+)/);

                  // if range is valid
                  if (null !== limits) {
                    // iterate through the range
                    for (var k = to_int(limits[1]); k <= to_int(limits[2]); k++)
                      // if value is not already among the values of the rule
                      // add it to the rule
                      if ($.inArray(k, rules[i]) == -1) rules[i].push(k + '');

                    // remove the range indicator
                    rules[i].splice(j, 1);
                  }
                }

              // iterate through the items in the rule
              // and make sure that numbers are numbers
              for (j = 0; j < rules[i].length; j++)
                rules[i][j] = isNaN(to_int(rules[i][j])) ? rules[i][j] : to_int(rules[i][j]);
            }

            // add to the correct list of processed rules
            // first time we're doing disabled dates,
            if (l === 0) disabled_dates.push(rules);
            // second time we're doing enabled_dates
            else if (l == 1) enabled_dates.push(rules);
            // otherwise, we're doing the dates to which custom classes need to be applied
            else {
              if (undefined === custom_classes[custom_class_names[l - 2]])
                custom_classes[custom_class_names[l - 2]] = [];
              custom_classes[custom_class_names[l - 2]].push(rules);
            }
          });
      }

      var // cache the current system date
        date = new Date(),
        // when the date picker's starting date depends on the value of another date picker, this value will be
        // set by the other date picker
        // this value will be used as base for all calculations (if not set, will be the same as the current
        // system date)
        reference_date = !plugin.settings.reference_date
          ? $element.data('zdp_reference_date') && undefined !== $element.data('zdp_reference_date')
            ? $element.data('zdp_reference_date')
            : date
          : plugin.settings.reference_date,
        tmp_start_date,
        tmp_end_date;

      // reset these values here as this method might be called more than once during a date picker's lifetime
      // (when the selectable dates depend on the values from another date picker)
      start_date = undefined;
      end_date = undefined;

      // extract the date parts
      // also, save the current system month/day/year - we'll use them to highlight the current system date
      first_selectable_month = reference_date.getMonth();
      current_system_month = date.getMonth();
      first_selectable_year = reference_date.getFullYear();
      current_system_year = date.getFullYear();
      first_selectable_day = reference_date.getDate();
      current_system_day = date.getDate();

      // check if the calendar has any restrictions

      // calendar is future-only, starting today
      // it means we have a starting date (the current system date), but no ending date
      if (plugin.settings.direction === true) start_date = reference_date;
      // calendar is past only, ending today
      else if (plugin.settings.direction === false) {
        // it means we have an ending date (the reference date), but no starting date
        end_date = reference_date;

        // extract the date parts
        last_selectable_month = end_date.getMonth();
        last_selectable_year = end_date.getFullYear();
        last_selectable_day = end_date.getDate();
      } else if (
        // if direction is not given as an array and the value is an integer > 0
        (!$.isArray(plugin.settings.direction) &&
          is_integer(plugin.settings.direction) &&
          to_int(plugin.settings.direction) > 0) ||
        // or direction is given as an array
        ($.isArray(plugin.settings.direction) &&
          // and first entry is a valid date
          ((tmp_start_date = check_date(plugin.settings.direction[0])) ||
            // or a boolean TRUE
            plugin.settings.direction[0] === true ||
            // or an integer > 0
            (is_integer(plugin.settings.direction[0]) && plugin.settings.direction[0] > 0)) &&
          // and second entry is a valid date
          ((tmp_end_date = check_date(plugin.settings.direction[1])) ||
            // or a boolean FALSE
            plugin.settings.direction[1] === false ||
            // or integer >= 0
            (is_integer(plugin.settings.direction[1]) && plugin.settings.direction[1] >= 0)))
      ) {
        // if an exact starting date was given, use that as a starting date
        if (tmp_start_date) start_date = tmp_start_date;
        // otherwise
        // figure out the starting date
        // use the Date object to normalize the date
        // for example, 2011 05 33 will be transformed to 2011 06 02
        else
          start_date = new Date(
            first_selectable_year,
            first_selectable_month,
            first_selectable_day +
              (!$.isArray(plugin.settings.direction)
                ? to_int(plugin.settings.direction)
                : to_int(plugin.settings.direction[0] === true ? 0 : plugin.settings.direction[0]))
          );

        // re-extract the date parts
        first_selectable_month = start_date.getMonth();
        first_selectable_year = start_date.getFullYear();
        first_selectable_day = start_date.getDate();

        // if an exact ending date was given and the date is after the starting date, use that as a ending date
        if (tmp_end_date && +tmp_end_date >= +start_date) end_date = tmp_end_date;
        // if have information about the ending date
        else if (!tmp_end_date && plugin.settings.direction[1] !== false && $.isArray(plugin.settings.direction))
          // figure out the ending date
          // use the Date object to normalize the date
          // for example, 2011 05 33 will be transformed to 2011 06 02
          end_date = new Date(
            first_selectable_year,
            first_selectable_month,
            first_selectable_day + to_int(plugin.settings.direction[1])
          );

        // if a valid ending date exists
        if (end_date) {
          // extract the date parts
          last_selectable_month = end_date.getMonth();
          last_selectable_year = end_date.getFullYear();
          last_selectable_day = end_date.getDate();
        }
      } else if (
        // if direction is not given as an array and the value is an integer < 0
        (!$.isArray(plugin.settings.direction) &&
          is_integer(plugin.settings.direction) &&
          to_int(plugin.settings.direction) < 0) ||
        // or direction is given as an array
        ($.isArray(plugin.settings.direction) &&
          // and first entry is boolean FALSE
          (plugin.settings.direction[0] === false ||
            // or an integer < 0
            (is_integer(plugin.settings.direction[0]) && plugin.settings.direction[0] < 0)) &&
          // and second entry is a valid date
          ((tmp_start_date = check_date(plugin.settings.direction[1])) ||
            // or an integer >= 0
            (is_integer(plugin.settings.direction[1]) && plugin.settings.direction[1] >= 0)))
      ) {
        // figure out the ending date
        // use the Date object to normalize the date
        // for example, 2011 05 33 will be transformed to 2011 06 02
        end_date = new Date(
          first_selectable_year,
          first_selectable_month,
          first_selectable_day +
            (!$.isArray(plugin.settings.direction)
              ? to_int(plugin.settings.direction)
              : to_int(plugin.settings.direction[0] === false ? 0 : plugin.settings.direction[0]))
        );

        // re-extract the date parts
        last_selectable_month = end_date.getMonth();
        last_selectable_year = end_date.getFullYear();
        last_selectable_day = end_date.getDate();

        // if an exact starting date was given, and the date is before the ending date, use that as a starting date
        if (tmp_start_date && +tmp_start_date < +end_date) start_date = tmp_start_date;
        // if have information about the starting date
        else if (!tmp_start_date && $.isArray(plugin.settings.direction))
          // figure out the staring date
          // use the Date object to normalize the date
          // for example, 2011 05 33 will be transformed to 2011 06 02
          start_date = new Date(
            last_selectable_year,
            last_selectable_month,
            last_selectable_day - to_int(plugin.settings.direction[1])
          );

        // if a valid starting date exists
        if (start_date) {
          // extract the date parts
          first_selectable_month = start_date.getMonth();
          first_selectable_year = start_date.getFullYear();
          first_selectable_day = start_date.getDate();
        }

        // if there are disabled dates
      } else if ($.isArray(plugin.settings.disabled_dates) && plugin.settings.disabled_dates.length > 0)
        // iterate through the rules for disabling dates
        // only if there is a rule that disables *everything*
        for (var interval in disabled_dates)
          if (
            disabled_dates[interval][0] == '*' &&
            disabled_dates[interval][1] == '*' &&
            disabled_dates[interval][2] == '*' &&
            disabled_dates[interval][3] == '*'
          ) {
            var tmpDates = [];

            // iterate through the rules for enabling dates
            // looking for the minimum/maximum selectable date (if it's the case)
            $.each(enabled_dates, function() {
              var rule = this;

              // if the rule doesn't apply to all years
              if (rule[2][0] != '*')
                // format date and store it in our stack
                tmpDates.push(
                  parseInt(
                    rule[2][0] +
                      (rule[1][0] == '*' ? '12' : str_pad(rule[1][0], 2)) +
                      (rule[0][0] == '*'
                        ? rule[1][0] == '*'
                          ? '31'
                          : new Date(rule[2][0], rule[1][0], 0).getDate()
                        : str_pad(rule[0][0], 2)),
                    10
                  )
                );
            });

            // sort dates ascending
            tmpDates.sort();

            // if we have any rules
            if (tmpDates.length > 0) {
              // get date parts
              var matches = (tmpDates[0] + '').match(/([0-9]{4})([0-9]{2})([0-9]{2})/);

              // assign the date parts to the appropriate variables
              first_selectable_year = parseInt(matches[1], 10);
              first_selectable_month = parseInt(matches[2], 10) - 1;
              first_selectable_day = parseInt(matches[3], 10);
            }

            // don't look further
            break;
          }

      // if first selectable date exists but is disabled, find the actual first selectable date
      if (is_disabled(first_selectable_year, first_selectable_month, first_selectable_day)) {
        // loop until we find the first selectable year
        while (is_disabled(first_selectable_year)) {
          // if calendar is past-only,
          if (!start_date) {
            // decrement the year
            first_selectable_year--;

            // because we've changed years, reset the month to December
            first_selectable_month = 11;

            // otherwise
          } else {
            // increment the year
            first_selectable_year++;

            // because we've changed years, reset the month to January
            first_selectable_month = 0;
          }
        }

        // loop until we find the first selectable month
        while (is_disabled(first_selectable_year, first_selectable_month)) {
          // if calendar is past-only
          if (!start_date) {
            // decrement the month
            first_selectable_month--;

            // because we've changed months, reset the day to the last day of the month
            first_selectable_day = new Date(first_selectable_year, first_selectable_month + 1, 0).getDate();

            // otherwise
          } else {
            // increment the month
            first_selectable_month++;

            // because we've changed months, reset the day to the first day of the month
            first_selectable_day = 1;
          }

          // if we moved to a following year
          if (first_selectable_month > 11) {
            // increment the year
            first_selectable_year++;

            // reset the month to January
            first_selectable_month = 0;

            // because we've changed months, reset the day to the first day of the month
            first_selectable_day = 1;

            // if we moved to a previous year
          } else if (first_selectable_month < 0) {
            // decrement the year
            first_selectable_year--;

            // reset the month to December
            first_selectable_month = 11;

            // because we've changed months, reset the day to the last day of the month
            first_selectable_day = new Date(first_selectable_year, first_selectable_month + 1, 0).getDate();
          }
        }

        // loop until we find the first selectable day
        while (is_disabled(first_selectable_year, first_selectable_month, first_selectable_day)) {
          // if calendar is past-only, decrement the day
          if (!start_date) first_selectable_day--;
          // otherwise, increment the day
          else first_selectable_day++;

          // use the Date object to normalize the date
          // for example, 2011 05 33 will be transformed to 2011 06 02
          date = new Date(first_selectable_year, first_selectable_month, first_selectable_day);

          // re-extract date parts from the normalized date
          // as we use them in the current loop
          first_selectable_year = date.getFullYear();
          first_selectable_month = date.getMonth();
          first_selectable_day = date.getDate();
        }

        // use the Date object to normalize the date
        // for example, 2011 05 33 will be transformed to 2011 06 02
        date = new Date(first_selectable_year, first_selectable_month, first_selectable_day);

        // re-extract date parts from the normalized date
        // as we use them in the current loop
        first_selectable_year = date.getFullYear();
        first_selectable_month = date.getMonth();
        first_selectable_day = date.getDate();
      }

      // get the default date, from the element, and check if it represents a valid date, according to the required format
      var default_date = check_date($element.val() || (plugin.settings.start_date ? plugin.settings.start_date : ''));

      // if there is a default date, date picker is in "strict" mode, and the default date is disabled
      if (
        default_date &&
        plugin.settings.strict &&
        is_disabled(default_date.getFullYear(), default_date.getMonth(), default_date.getDate())
      )
        // clear the value of the parent element
        $element.val('');

      // updates value for the date picker whose starting date depends on the selected date (if any)
      if (!update && (undefined !== start_date || undefined !== default_date))
        update_dependent(undefined !== default_date ? default_date : start_date);

      // if date picker is not always visible
      if (!plugin.settings.always_visible) {
        // if we're just creating the date picker
        if (!update) {
          // if a calendar icon should be added to the element the plugin is attached to, create the icon now
          if (plugin.settings.show_icon) {
            // strangely, in Firefox 21+ (or maybe even earlier) input elements have their "display" property
            // set to "inline" instead of "inline-block" as do all the other browsers.
            // because this behavior brakes the positioning of the icon, we'll set the "display" property to
            // "inline-block" before anything else;
            if (browser.name == 'firefox' && $element.is('input[type="text"]') && $element.css('display') == 'inline')
              $element.css('display', 'inline-block');

            // we create a wrapper for the parent element so that we can later position the icon
            // also, make sure the wrapper inherits some important css properties of the parent element
            var icon_wrapper = $('<span class="Zebra_DatePicker_Icon_Wrapper"></span>').css({
              display: $element.css('display'),
              position: $element.css('position') == 'static' ? 'relative' : $element.css('position'),
              float: $element.css('float'),
              top: $element.css('top'),
              right: $element.css('right'),
              bottom: $element.css('bottom'),
              left: $element.css('left'),
            });

            // if parent element has its "display" property set to "block"
            // the wrapper has to have its "width" set
            if ($element.css('display') == 'block') icon_wrapper.css('width', $element.outerWidth(true));

            // put wrapper around the element
            // also, make sure we set some important css properties for it
            $element.wrap(icon_wrapper).css({
              position: 'relative',
              top: 'auto',
              right: 'auto',
              bottom: 'auto',
              left: 'auto',
            });

            // create the actual calendar icon (show a disabled icon if the element is disabled)
            icon = $(
              '<button type="button" class="Zebra_DatePicker_Icon' +
                ($element.attr('disabled') == 'disabled' ? ' Zebra_DatePicker_Icon_Disabled' : '') +
                '">Pick a date</button>'
            );

            // a reference to the icon, as a global property
            plugin.icon = icon;

            // the date picker will open when clicking both the icon and the element the plugin is attached to
            // (or the icon only, if set so)
            clickables = plugin.settings.open_icon_only ? icon : icon.add($element);

            // if calendar icon is not visible, the date picker will open when clicking the element
          } else clickables = $element;

          // attach the click event to the clickable elements (icon and/or element)
          clickables.bind('click.Zebra_DatePicker_' + uniqueid, function(e) {
            e.preventDefault();

            // if element is not disabled
            if (!$element.attr('disabled'))
              if (datepicker.hasClass('dp_visible'))
                // if the date picker is visible, hide it
                plugin.hide();
              // if the date picker is not visible, show it
              else plugin.show();
          });

          // if users can manually enter dates and a pair date element exists
          if (!plugin.settings.readonly_element && plugin.settings.pair)
            // whenever the element looses focus
            $element.bind('blur.Zebra_DatePicker_' + uniqueid, function() {
              var date;

              // if a valid date was entered, update the paired date picker
              if (
                (date = check_date($(this).val())) &&
                !is_disabled(date.getFullYear(), date.getMonth(), date.getDate())
              )
                update_dependent(date);
            });

          // if icon exists, inject it into the DOM, right after the parent element (and inside the wrapper)
          if (undefined !== icon) icon.insertAfter($element);
        }

        // if calendar icon exists
        if (undefined !== icon) {
          // needed when updating: remove any inline style set previously by library,
          // so we get the right values below
          icon.attr('style', '');

          // if calendar icon is to be placed *inside* the element
          // add an extra class to the icon
          if (plugin.settings.inside)
            icon.addClass(
              'Zebra_DatePicker_Icon_Inside_' + (plugin.settings.icon_position == 'right' ? 'Right' : 'Left')
            );

          var // get element's width and height (including margins)
            element_width = $element.outerWidth(),
            element_height = $element.outerHeight(),
            element_margin_left = parseInt($element.css('marginLeft'), 10) || 0,
            element_margin_top = parseInt($element.css('marginTop'), 10) || 0,
            // get icon's width, height and margins
            icon_width = icon.outerWidth(),
            icon_height = icon.outerHeight(),
            icon_margin_left = parseInt(icon.css('marginLeft'), 10) || 0,
            icon_margin_right = parseInt(icon.css('marginRight'), 10) || 0;

          // if icon is to be placed *inside* the element
          // position the icon accordingly
          if (plugin.settings.inside) {
            // set icon's top
            icon.css('top', element_margin_top + (element_height - icon_height) / 2);

            // place icon to the right or to the left, according to the settings
            if (plugin.settings.icon_position == 'right') icon.css('right', 0);
            else icon.css('left', 0);

            // if icon is to be placed to the right of the element
            // position the icon accordingly
          } else
            icon.css({
              top: element_margin_top + (element_height - icon_height) / 2,
              left: element_margin_left + element_width + icon_margin_left,
            });

          // assume the datepicker is not disabled
          icon.removeClass(' Zebra_DatePicker_Icon_Disabled');

          // if element the datepicker is attached to became disabled, disable the calendar icon, too
          if ($element.attr('disabled') == 'disabled') icon.addClass('Zebra_DatePicker_Icon_Disabled');
        }
      }

      // if the "Today" button is to be shown and it makes sense to be shown
      // (the "days" view is available and "today" is not a disabled date)
      show_select_today =
        plugin.settings.show_select_today !== false &&
        $.inArray('days', views) > -1 &&
        !is_disabled(current_system_year, current_system_month, current_system_day)
          ? plugin.settings.show_select_today
          : false;

      // if we just needed to recompute the things above
      if (update) {
        // make sure we update these strings, in case they've changed
        $('.dp_previous', datepicker).html(plugin.settings.header_navigation[0]);
        $('.dp_next', datepicker).html(plugin.settings.header_navigation[1]);
        $('.dp_clear', datepicker).html(plugin.settings.lang_clear_date);
        $('.dp_today', datepicker).html(plugin.settings.show_select_today);

        // don't go further
        return;
      }

      // update icon/date picker position on resize and/or changing orientation
      $(window).bind(
        'resize.Zebra_DatePicker_' + uniqueid + ', orientationchange.Zebra_DatePicker_' + uniqueid,
        function() {
          // hide the date picker
          plugin.hide();

          // if the icon is visible, update its position as the parent element might have changed position
          if (icon !== undefined) {
            // we use timeouts so that we do not call the "update" method on *every* step of the resize event

            // clear a previously set timeout
            clearTimeout(timeout);

            // set timeout again
            timeout = setTimeout(function() {
              // update the date picker
              plugin.update();
            }, 100);
          }
        }
      );

      // generate the container that will hold everything
      var html =
        '' +
        '<div class="Zebra_DatePicker">' +
        '<table class="dp_header">' +
        '<tr>' +
        '<td class="dp_previous">' +
        plugin.settings.header_navigation[0] +
        '</td>' +
        '<td class="dp_caption">&#032;</td>' +
        '<td class="dp_next">' +
        plugin.settings.header_navigation[1] +
        '</td>' +
        '</tr>' +
        '</table>' +
        '<table class="dp_daypicker"></table>' +
        '<table class="dp_monthpicker"></table>' +
        '<table class="dp_yearpicker"></table>' +
        '<table class="dp_footer"><tr>' +
        '<td class="dp_today"' +
        (plugin.settings.show_clear_date !== false ? ' style="width:50%"' : '') +
        '>' +
        show_select_today +
        '</td>' +
        '<td class="dp_clear"' +
        (show_select_today !== false ? ' style="width:50%"' : '') +
        '>' +
        plugin.settings.lang_clear_date +
        '</td>' +
        '</tr></table>' +
        '</div>';

      // create a jQuery object out of the HTML above and create a reference to it
      datepicker = $(html);

      // a reference to the calendar, as a global property
      plugin.datepicker = datepicker;

      // create references to the different parts of the date picker
      header = $('table.dp_header', datepicker);
      daypicker = $('table.dp_daypicker', datepicker);
      monthpicker = $('table.dp_monthpicker', datepicker);
      yearpicker = $('table.dp_yearpicker', datepicker);
      footer = $('table.dp_footer', datepicker);
      selecttoday = $('td.dp_today', footer);
      cleardate = $('td.dp_clear', footer);

      // if date picker is not always visible
      if (!plugin.settings.always_visible)
        // inject the container into the DOM
        plugin.settings.container.append(datepicker);
      // otherwise, if element is not disabled
      else if (!$element.attr('disabled')) {
        // inject the date picker into the designated container element
        plugin.settings.always_visible.append(datepicker);

        // and make it visible right away
        plugin.show();
      }

      // add the mouseover/mousevents to all to the date picker's cells
      // except those that are not selectable
      datepicker
        .delegate(
          'td:not(.dp_disabled, .dp_weekend_disabled, .dp_not_in_month, .dp_week_number)',
          'mouseover',
          function() {
            $(this).addClass('dp_hover');
          }
        )
        .delegate(
          'td:not(.dp_disabled, .dp_weekend_disabled, .dp_not_in_month, .dp_week_number)',
          'mouseout',
          function() {
            $(this).removeClass('dp_hover');
          }
        );

      // prevent text highlighting for the text in the header
      // (for the case when user keeps clicking the "next" and "previous" buttons)
      disable_text_select($('td', header));

      // event for when clicking the "previous" button
      $('.dp_previous', header).bind('click', function() {
        // if view is "months"
        // decrement year by one
        if (view == 'months') selected_year--;
        // if view is "years"
        // decrement years by 12
        else if (view == 'years') selected_year -= 12;
        // if view is "days"
        // decrement the month and
        // if month is out of range
        else if (--selected_month < 0) {
          // go to the last month of the previous year
          selected_month = 11;
          selected_year--;
        }

        // generate the appropriate view
        manage_views();
      });

      // attach a click event to the caption in header
      $('.dp_caption', header).bind('click', function() {
        // if current view is "days", take the user to the next view, depending on the format
        if (view == 'days')
          view = $.inArray('months', views) > -1 ? 'months' : $.inArray('years', views) > -1 ? 'years' : 'days';
        // if current view is "months", take the user to the next view, depending on the format
        else if (view == 'months')
          view = $.inArray('years', views) > -1 ? 'years' : $.inArray('days', views) > -1 ? 'days' : 'months';
        // if current view is "years", take the user to the next view, depending on the format
        else view = $.inArray('days', views) > -1 ? 'days' : $.inArray('months', views) > -1 ? 'months' : 'years';

        // generate the appropriate view
        manage_views();
      });

      // event for when clicking the "next" button
      $('.dp_next', header).bind('click', function() {
        // if view is "months"
        // increment year by 1
        if (view == 'months') selected_year++;
        // if view is "years"
        // increment years by 12
        else if (view == 'years') selected_year += 12;
        // if view is "days"
        // increment the month and
        // if month is out of range
        else if (++selected_month == 12) {
          // go to the first month of the next year
          selected_month = 0;
          selected_year++;
        }

        // generate the appropriate view
        manage_views();
      });

      // attach a click event for the cells in the day picker
      daypicker.delegate(
        'td:not(.dp_disabled, .dp_weekend_disabled, .dp_not_in_month, .dp_week_number)',
        'click',
        function() {
          // if other months are selectable and currently clicked cell contains a class with the cell's date
          if (
            plugin.settings.select_other_months &&
            $(this).attr('class') &&
            null !==
              (matches = $(this)
                .attr('class')
                .match(/date\_([0-9]{4})(0[1-9]|1[012])(0[1-9]|[12][0-9]|3[01])/))
          )
            // use the stored date
            select_date(matches[1], matches[2] - 1, matches[3], 'days', $(this));
          // put selected date in the element the plugin is attached to, and hide the date picker
          else select_date(selected_year, selected_month, to_int($(this).html()), 'days', $(this));
        }
      );

      // attach a click event for the cells in the month picker
      monthpicker.delegate('td:not(.dp_disabled)', 'click', function() {
        // get the month we've clicked on
        var matches = $(this)
          .attr('class')
          .match(/dp\_month\_([0-9]+)/);

        // set the selected month
        selected_month = to_int(matches[1]);

        // if user can select only years and months
        if ($.inArray('days', views) == -1)
          // put selected date in the element the plugin is attached to, and hide the date picker
          select_date(selected_year, selected_month, 1, 'months', $(this));
        else {
          // direct the user to the "days" view
          view = 'days';

          // if date picker is always visible
          // empty the value in the text box the date picker is attached to
          if (plugin.settings.always_visible) $element.val('');

          // generate the appropriate view
          manage_views();
        }
      });

      // attach a click event for the cells in the year picker
      yearpicker.delegate('td:not(.dp_disabled)', 'click', function() {
        // set the selected year
        selected_year = to_int($(this).html());

        // if user can select only years
        if ($.inArray('months', views) == -1)
          // put selected date in the element the plugin is attached to, and hide the date picker
          select_date(selected_year, 1, 1, 'years', $(this));
        else {
          // direct the user to the "months" view
          view = 'months';

          // if date picker is always visible
          // empty the value in the text box the date picker is attached to
          if (plugin.settings.always_visible) $element.val('');

          // generate the appropriate view
          manage_views();
        }
      });

      // function to execute when the "Today" button is clicked
      $(selecttoday).bind('click', function(e) {
        e.preventDefault();

        // select the current date
        select_date(current_system_year, current_system_month, current_system_day, 'days', $('.dp_current', daypicker));

        // if date picker is always visible
        if (plugin.settings.always_visible)
          // repaint the datepicker so it centers on the currently selected date
          plugin.show();

        // hide the date picker
        plugin.hide();
      });

      // function to execute when the "Clear" button is clicked
      $(cleardate).bind('click', function(e) {
        e.preventDefault();

        // clear the element's value
        $element.val('');

        // if date picker is not always visible
        if (!plugin.settings.always_visible) {
          // reset these values
          default_day = null;
          default_month = null;
          default_year = null;
          selected_month = null;
          selected_year = null;

          // if date picker is always visible
        } else {
          // reset these values
          default_day = null;
          default_month = null;
          default_year = null;

          // remove the "selected" class from all cells that have it
          $('td.dp_selected', datepicker).removeClass('dp_selected');
        }

        // hide the date picker
        plugin.hide();

        // if a callback function exists for when clearing a date
        if (plugin.settings.onClear && typeof plugin.settings.onClear == 'function')
          // execute the callback function and pass as argument the element the plugin is attached to
          plugin.settings.onClear.call($element, $element);
      });

      // if date picker is not always visible
      if (!plugin.settings.always_visible) {
        //whenever anything is clicked on the page
        $(document).bind(
          'mousedown.Zebra_DatePicker_' + uniqueid + ', touchstart.Zebra_DatePicker_' + uniqueid,
          function(e) {
            // if the date picker is visible
            if (datepicker.hasClass('dp_visible')) {
              // if the calendar icon is visible and we clicked it, let the onClick event of the icon to handle the event
              // (we want it to toggle the date picker)
              if (plugin.settings.show_icon && $(e.target).get(0) === icon.get(0)) return true;

              // if what's clicked is not inside the date picker
              // hide the date picker
              if (
                $(e.target)
                  .parents()
                  .filter('.Zebra_DatePicker').length === 0
              )
                plugin.hide();
            }
          }
        );

        //whenever a key is pressed on the page
        $(document).bind('keyup.Zebra_DatePicker_' + uniqueid, function(e) {
          // if the date picker is visible
          // and the pressed key is ESC
          // hide the date picker
          if (datepicker.hasClass('dp_visible') && e.which == 27) plugin.hide();
        });
      }

      // last thing is to pre-render some of the date picker right away
      manage_views();
    };

    /**
     *  Clears the selected date.
     *
     *  @return void
     */
    plugin.clear_date = function() {
      $(cleardate).trigger('click');
    };

    /**
     *  Destroys the date picker.
     *
     *  @return void
     */
    plugin.destroy = function() {
      // remove the attached icon (if it exists)...
      if (undefined !== plugin.icon) plugin.icon.remove();

      // ...and the calendar
      plugin.datepicker.remove();

      // if calendar icon was shown and the date picker was not always visible,
      // also remove the wrapper needed for positioning it
      if (plugin.settings.show_icon && !plugin.settings.always_visible) $element.unwrap();

      // remove associated event handlers from the element
      $element.unbind('click.Zebra_DatePicker_' + uniqueid);
      $element.unbind('blur.Zebra_DatePicker_' + uniqueid);

      // remove associated event handlers from the document
      $(document).unbind('keyup.Zebra_DatePicker_' + uniqueid);
      $(document).unbind('mousedown.Zebra_DatePicker_' + uniqueid);
      $(window).unbind('resize.Zebra_DatePicker_' + uniqueid);
      $(window).unbind('orientationchange.Zebra_DatePicker_' + uniqueid);

      // remove association with the element
      $element.removeData('Zebra_DatePicker');

      // restore element's modified attributes
      $element.attr('readonly', original_attributes['readonly'] ? true : false);
      $element.attr('style', original_attributes['style'] ? original_attributes['style'] : '');
    };

    /**
     *  Hides the date picker.
     *
     *  @return void
     */
    plugin.hide = function() {
      // if date picker is not always visible
      if (!plugin.settings.always_visible) {
        // hide the iFrameShim in Internet Explorer 6
        iframeShim('hide');

        // hide the date picker
        datepicker.removeClass('dp_visible').addClass('dp_hidden');

        // if a callback function exists for when hiding the date picker
        if (plugin.settings.onClose && typeof plugin.settings.onClose == 'function')
          // execute the callback function and pass as argument the element the plugin is attached to
          plugin.settings.onClose.call($element, $element);
      }
    };

    /**
     *  Set the date picker's value
     *
     *  Must be in the format set by the "format" property!
     *
     *  @return void
     */
    plugin.set_date = function(date) {
      var dateObj;

      // if a valid date was entered, and date is not disabled
      if ((dateObj = check_date(date)) && !is_disabled(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate())) {
        // set the element's value
        $element.val(date);

        // update the paired date picker (if any)
        update_dependent(dateObj);
      }
    };

    /**
     *  Shows the date picker.
     *
     *  @return void
     */
    plugin.show = function() {
      // always show the view defined in settings
      view = plugin.settings.view;

      // get the default date, from the element, and check if it represents a valid date, according to the required format
      var default_date = check_date($element.val() || (plugin.settings.start_date ? plugin.settings.start_date : ''));

      // if the value represents a valid date
      if (default_date) {
        // extract the date parts
        // we'll use these to highlight the default date in the date picker and as starting point to
        // what year and month to start the date picker with
        // why separate values? because selected_* will change as user navigates within the date picker
        default_month = default_date.getMonth();
        selected_month = default_date.getMonth();
        default_year = default_date.getFullYear();
        selected_year = default_date.getFullYear();
        default_day = default_date.getDate();

        // if the default date represents a disabled date
        if (is_disabled(default_year, default_month, default_day)) {
          // if date picker is in "strict" mode, clear the value of the parent element
          if (plugin.settings.strict) $element.val('');

          // the calendar will start with the first selectable year/month
          selected_month = first_selectable_month;
          selected_year = first_selectable_year;
        }

        // if a default value is not available, or value does not represent a valid date
      } else {
        // the calendar will start with the first selectable year/month
        selected_month = first_selectable_month;
        selected_year = first_selectable_year;
      }

      // generate the appropriate view
      manage_views();

      // if date picker is not always visible and the calendar icon is visible
      if (!plugin.settings.always_visible) {
        // if date picker is to be injected into the <body>
        if (plugin.settings.container.is('body')) {
          var // get the date picker width and height
            datepicker_width = datepicker.outerWidth(),
            datepicker_height = datepicker.outerHeight(),
            // compute the date picker's default left and top
            // this will be computed relative to the icon's top-right corner (if the calendar icon exists), or
            // relative to the element's top-right corner otherwise, to which the offsets given at initialization
            // are added/subtracted
            left =
              (undefined !== icon
                ? icon.offset().left + icon.outerWidth(true)
                : $element.offset().left + $element.outerWidth(true)) + plugin.settings.offset[0],
            top =
              (undefined !== icon ? icon.offset().top : $element.offset().top) -
              datepicker_height +
              plugin.settings.offset[1],
            // get browser window's width and height
            window_width = $(window).width(),
            window_height = $(window).height(),
            // get browser window's horizontal and vertical scroll offsets
            window_scroll_top = $(window).scrollTop(),
            window_scroll_left = $(window).scrollLeft();

          if (plugin.settings.default_position == 'below')
            top = (undefined !== icon ? icon.offset().top : $element.offset().top) + plugin.settings.offset[1];

          // if date picker is outside the viewport, adjust its position so that it is visible
          if (left + datepicker_width > window_scroll_left + window_width)
            left = window_scroll_left + window_width - datepicker_width;
          if (left < window_scroll_left) left = window_scroll_left;

          if (top + datepicker_height > window_scroll_top + window_height)
            top = window_scroll_top + window_height - datepicker_height;
          if (top < window_scroll_top) top = window_scroll_top;

          // make the date picker visible
          datepicker.css({
            left: left,
            top: top,
          });

          // if date picker is to be injected into a custom container element
        } else
          datepicker.css({
            left: 0,
            top: 0,
          });

        // fade-in the date picker
        // for Internet Explorer < 9 show the date picker instantly or fading alters the font's weight
        datepicker.removeClass('dp_hidden').addClass('dp_visible');

        // show the iFrameShim in Internet Explorer 6
        iframeShim();

        // if date picker is always visible, show it
      } else datepicker.removeClass('dp_hidden').addClass('dp_visible');

      // if a callback function exists for when showing the date picker
      if (plugin.settings.onOpen && typeof plugin.settings.onOpen == 'function')
        // execute the callback function and pass as argument the element the plugin is attached to
        plugin.settings.onOpen.call($element, $element);
    };

    /**
     *  Updates the configuration options given as argument
     *
     *  @param  object  values  An object containing any number of configuration options to be updated
     *
     *  @return void
     */
    plugin.update = function(values) {
      // if original direction not saved, save it now
      if (plugin.original_direction) plugin.original_direction = plugin.direction;

      // update configuration options
      plugin.settings = $.extend(plugin.settings, values);

      // reinitialize the object with the new options
      init(true);
    };

    /**
     *  Checks if a string represents a valid date according to the format defined by the "format" property.
     *
     *  @param  string  str_date    A string representing a date, formatted accordingly to the "format" property.
     *                              For example, if "format" is "Y-m-d" the string should look like "2011-06-01"
     *
     *  @return mixed               Returns a JavaScript Date object if string represents a valid date according
     *                              formatted according to the "format" property, or FALSE otherwise.
     *
     *  @access private
     */
    var check_date = function(str_date) {
      // treat argument as a string
      str_date += '';

      // if value is given
      if ($.trim(str_date) !== '') {
        var // prepare the format by removing white space from it
          // and also escape characters that could have special meaning in a regular expression
          format = escape_regexp(plugin.settings.format),
          // allowed characters in date's format
          format_chars = ['d', 'D', 'j', 'l', 'N', 'S', 'w', 'F', 'm', 'M', 'n', 'Y', 'y'],
          // "matches" will contain the characters defining the date's format
          matches = [],
          // "regexp" will contain the regular expression built for each of the characters used in the date's format
          regexp = [],
          // "position" will contain the position of the caracter found in the date's format
          position = null,
          // "segments" will contain the matches of the regular expression
          segments = null;

        // iterate through the allowed characters in date's format
        for (var i = 0; i < format_chars.length; i++)
          // if character is found in the date's format
          if ((position = format.indexOf(format_chars[i])) > -1)
            // save it, alongside the character's position
            matches.push({ character: format_chars[i], position: position });

        // sort characters defining the date's format based on their position, ascending
        matches.sort(function(a, b) {
          return a.position - b.position;
        });

        // iterate through the characters defining the date's format
        $.each(matches, function(index, match) {
          // add to the array of regular expressions, based on the character
          switch (match.character) {
            case 'd':
              regexp.push('0[1-9]|[12][0-9]|3[01]');
              break;
            case 'D':
              regexp.push('[a-z]{3}');
              break;
            case 'j':
              regexp.push('[1-9]|[12][0-9]|3[01]');
              break;
            case 'l':
              regexp.push('[a-z]+');
              break;
            case 'N':
              regexp.push('[1-7]');
              break;
            case 'S':
              regexp.push('st|nd|rd|th');
              break;
            case 'w':
              regexp.push('[0-6]');
              break;
            case 'F':
              regexp.push('[a-z]+');
              break;
            case 'm':
              regexp.push('0[1-9]|1[012]+');
              break;
            case 'M':
              regexp.push('[a-z]{3}');
              break;
            case 'n':
              regexp.push('[1-9]|1[012]');
              break;
            case 'Y':
              regexp.push('[0-9]{4}');
              break;
            case 'y':
              regexp.push('[0-9]{2}');
              break;
          }
        });

        // if we have an array of regular expressions
        if (regexp.length) {
          // we will replace characters in the date's format in reversed order
          matches.reverse();

          // iterate through the characters in date's format
          $.each(matches, function(index, match) {
            // replace each character with the appropriate regular expression
            format = format.replace(match.character, '(' + regexp[regexp.length - index - 1] + ')');
          });

          // the final regular expression
          regexp = new RegExp('^' + format + '$', 'ig');

          // if regular expression was matched
          if ((segments = regexp.exec(str_date))) {
            // check if date is a valid date (i.e. there's no February 31)

            var tmpdate = new Date(),
              original_day = 1,
              original_month = tmpdate.getMonth() + 1,
              original_year = tmpdate.getFullYear(),
              english_days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
              english_months = [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December',
              ],
              iterable,
              // by default, we assume the date is valid
              valid = true;

            // reverse back the characters in the date's format
            matches.reverse();

            // iterate through the characters in the date's format
            $.each(matches, function(index, match) {
              // if the date is not valid, don't look further
              if (!valid) return true;

              // based on the character
              switch (match.character) {
                case 'm':
                case 'n':
                  // extract the month from the value entered by the user
                  original_month = to_int(segments[index + 1]);

                  break;

                case 'd':
                case 'j':
                  // extract the day from the value entered by the user
                  original_day = to_int(segments[index + 1]);

                  break;

                case 'D':
                case 'l':
                case 'F':
                case 'M':
                  // if day is given as day name, we'll check against the names in the used language
                  if (match.character == 'D' || match.character == 'l') iterable = plugin.settings.days;
                  // if month is given as month name, we'll check against the names in the used language
                  else iterable = plugin.settings.months;

                  // by default, we assume the day or month was not entered correctly
                  valid = false;

                  // iterate through the month/days in the used language
                  $.each(iterable, function(key, value) {
                    // if month/day was entered correctly, don't look further
                    if (valid) return true;

                    // if month/day was entered correctly
                    if (
                      segments[index + 1].toLowerCase() ==
                      value
                        .substring(0, match.character == 'D' || match.character == 'M' ? 3 : value.length)
                        .toLowerCase()
                    ) {
                      // extract the day/month from the value entered by the user
                      switch (match.character) {
                        case 'D':
                          segments[index + 1] = english_days[key].substring(0, 3);
                          break;
                        case 'l':
                          segments[index + 1] = english_days[key];
                          break;
                        case 'F':
                          segments[index + 1] = english_months[key];
                          original_month = key + 1;
                          break;
                        case 'M':
                          segments[index + 1] = english_months[key].substring(0, 3);
                          original_month = key + 1;
                          break;
                      }

                      // day/month value is valid
                      valid = true;
                    }
                  });

                  break;

                case 'Y':
                  // extract the year from the value entered by the user
                  original_year = to_int(segments[index + 1]);

                  break;

                case 'y':
                  // extract the year from the value entered by the user
                  original_year = '19' + to_int(segments[index + 1]);

                  break;
              }
            });

            // if everything is ok so far
            if (valid) {
              // generate a Date object using the values entered by the user
              // (handle also the case when original_month and/or original_day are undefined - i.e date format is "Y-m" or "Y")
              var date = new Date(original_year, (original_month || 1) - 1, original_day || 1);

              // if, after that, the date is the same as the date entered by the user
              if (
                date.getFullYear() == original_year &&
                date.getDate() == (original_day || 1) &&
                date.getMonth() == (original_month || 1) - 1
              )
                // return the date as JavaScript date object
                return date;
            }
          }
        }

        // if script gets this far, return false as something must've went wrong
        return false;
      }
    };

    /**
     *  Prevents the possibility of selecting text on a given element. Used on the "previous" and "next" buttons
     *  where text might get accidentally selected when user quickly clicks on the buttons.
     *
     *  Code by http://chris-barr.com/index.php/entry/disable_text_selection_with_jquery/
     *
     *  @param  jQuery Element  el  A jQuery element on which to prevents text selection.
     *
     *  @return void
     *
     *  @access private
     */
    var disable_text_select = function(el) {
      // if browser is Firefox
      if (browser.name == 'firefox') el.css('MozUserSelect', 'none');
      // if browser is Internet Explorer
      else if (browser.name == 'explorer')
        el.bind('selectstart', function() {
          return false;
        });
      // for the other browsers
      else
        el.mousedown(function() {
          return false;
        });
    };

    /**
     *  Escapes special characters in a string, preparing it for use in a regular expression.
     *
     *  @param  string  str     The string in which special characters should be escaped.
     *
     *  @return string          Returns the string with escaped special characters.
     *
     *  @access private
     */
    var escape_regexp = function(str) {
      // return string with special characters escaped
      return str.replace(/([-.,*+?^${}()|[\]\/\\])/g, '\\$1');
    };

    /**
     *  Formats a JavaScript date object to the format specified by the "format" property.
     *  Code taken from http://electricprism.com/aeron/calendar/
     *
     *  @param  date    date    A valid JavaScript date object
     *
     *  @return string          Returns a string containing the formatted date
     *
     *  @access private
     */
    var format = function(date) {
      var result = '',
        // extract parts of the date:
        // day number, 1 - 31
        j = date.getDate(),
        // day of the week, 0 - 6, Sunday - Saturday
        w = date.getDay(),
        // the name of the day of the week Sunday - Saturday
        l = plugin.settings.days[w],
        // the month number, 1 - 12
        n = date.getMonth() + 1,
        // the month name, January - December
        f = plugin.settings.months[n - 1],
        // the year (as a string)
        y = date.getFullYear() + '';

      // iterate through the characters in the format
      for (var i = 0; i < plugin.settings.format.length; i++) {
        // extract the current character
        var chr = plugin.settings.format.charAt(i);

        // see what character it is
        switch (chr) {
          // year as two digits
          case 'y':
            y = y.substr(2);

          // year as four digits
          case 'Y':
            result += y;
            break;

          // month number, prefixed with 0
          case 'm':
            n = str_pad(n, 2);

          // month number, not prefixed with 0
          case 'n':
            result += n;
            break;

          // month name, three letters
          case 'M':
            f =
              $.isArray(plugin.settings.months_abbr) && undefined !== plugin.settings.months_abbr[n - 1]
                ? plugin.settings.months_abbr[n - 1]
                : plugin.settings.months[n - 1].substr(0, 3);

          // full month name
          case 'F':
            result += f;
            break;

          // day number, prefixed with 0
          case 'd':
            j = str_pad(j, 2);

          // day number not prefixed with 0
          case 'j':
            result += j;
            break;

          // day name, three letters
          case 'D':
            l =
              $.isArray(plugin.settings.days_abbr) && undefined !== plugin.settings.days_abbr[w]
                ? plugin.settings.days_abbr[w]
                : plugin.settings.days[w].substr(0, 3);

          // full day name
          case 'l':
            result += l;
            break;

          // ISO-8601 numeric representation of the day of the week, 1 - 7
          case 'N':
            w++;

          // day of the week, 0 - 6
          case 'w':
            result += w;
            break;

          // English ordinal suffix for the day of the month, 2 characters
          // (st, nd, rd or th (works well with j))
          case 'S':
            if (j % 10 == 1 && j != '11') result += 'st';
            else if (j % 10 == 2 && j != '12') result += 'nd';
            else if (j % 10 == 3 && j != '13') result += 'rd';
            else result += 'th';

            break;

          // this is probably the separator
          default:
            result += chr;
        }
      }

      // return formated date
      return result;
    };

    /**
     *  Generates the day picker view, and displays it
     *
     *  @return void
     *
     *  @access private
     */
    var generate_daypicker = function() {
      var // get the number of days in the selected month
        days_in_month = new Date(selected_year, selected_month + 1, 0).getDate(),
        // get the selected month's starting day (from 0 to 6)
        first_day = new Date(selected_year, selected_month, 1).getDay(),
        // how many days are there in the previous month
        days_in_previous_month = new Date(selected_year, selected_month, 0).getDate(),
        // how many days are there to be shown from the previous month
        days_from_previous_month = first_day - plugin.settings.first_day_of_week;

      // the final value of how many days are there to be shown from the previous month
      days_from_previous_month = days_from_previous_month < 0 ? 7 + days_from_previous_month : days_from_previous_month;

      // manage header caption and enable/disable navigation buttons if necessary
      manage_header(plugin.settings.header_captions['days']);

      // start generating the HTML
      var html = '<tr>';

      // if a column featuring the number of the week is to be shown
      if (plugin.settings.show_week_number)
        // column title
        html += '<th>' + plugin.settings.show_week_number + '</th>';

      // name of week days
      // show the abbreviated day names (or only the first two letters of the full name if no abbreviations are specified)
      // and also, take in account the value of the "first_day_of_week" property
      for (var i = 0; i < 7; i++)
        html +=
          '<th>' +
          ($.isArray(plugin.settings.days_abbr) &&
          undefined !== plugin.settings.days_abbr[(plugin.settings.first_day_of_week + i) % 7]
            ? plugin.settings.days_abbr[(plugin.settings.first_day_of_week + i) % 7]
            : plugin.settings.days[(plugin.settings.first_day_of_week + i) % 7].substr(0, 2)) +
          '</th>';

      html += '</tr><tr>';

      // the calendar shows a total of 42 days
      for (i = 0; i < 42; i++) {
        // seven days per row
        if (i > 0 && i % 7 === 0) html += '</tr><tr>';

        // if week number is to be shown
        if (i % 7 === 0 && plugin.settings.show_week_number)
          // show ISO 8601 week number
          html +=
            '<td class="dp_week_number">' +
            getWeekNumber(new Date(selected_year, selected_month, i - days_from_previous_month + 1)) +
            '</td>';

        // the number of the day in month
        var day = i - days_from_previous_month + 1;

        // if dates in previous/next month can be selected, and this is one of those days
        if (plugin.settings.select_other_months && (i < days_from_previous_month || day > days_in_month)) {
          // use the Date object to normalize the date
          // for example, 2011 05 33 will be transformed to 2011 06 02
          var real_date = new Date(selected_year, selected_month, day),
            real_year = real_date.getFullYear(),
            real_month = real_date.getMonth(),
            real_day = real_date.getDate();

          // extract normalized date parts and merge them
          real_date = real_year + str_pad(real_month + 1, 2) + str_pad(real_day, 2);
        }

        // if this is a day from the previous month
        if (i < days_from_previous_month)
          html +=
            '<td class="' +
            (plugin.settings.select_other_months && !is_disabled(real_year, real_month, real_day)
              ? 'dp_not_in_month_selectable date_' + real_date
              : 'dp_not_in_month') +
            '">' +
            (plugin.settings.select_other_months || plugin.settings.show_other_months
              ? str_pad(days_in_previous_month - days_from_previous_month + i + 1, plugin.settings.zero_pad ? 2 : 0)
              : '&nbsp;') +
            '</td>';
        // if this is a day from the next month
        else if (day > days_in_month)
          html +=
            '<td class="' +
            (plugin.settings.select_other_months && !is_disabled(real_year, real_month, real_day)
              ? 'dp_not_in_month_selectable date_' + real_date
              : 'dp_not_in_month') +
            '">' +
            (plugin.settings.select_other_months || plugin.settings.show_other_months
              ? str_pad(day - days_in_month, plugin.settings.zero_pad ? 2 : 0)
              : '&nbsp;') +
            '</td>';
        // if this is a day from the current month
        else {
          var // get the week day (0 to 6, Sunday to Saturday)
            weekday = (plugin.settings.first_day_of_week + i) % 7,
            class_name = '',
            // custom class, if any
            custom_class_name = get_custom_class(selected_year, selected_month, day);

          // if date needs to be disabled
          if (is_disabled(selected_year, selected_month, day)) {
            // if day is in weekend
            if ($.inArray(weekday, plugin.settings.weekend_days) > -1) class_name = 'dp_weekend_disabled';
            // if work day
            else class_name += ' dp_disabled';

            // highlight the current system date
            if (
              selected_month == current_system_month &&
              selected_year == current_system_year &&
              current_system_day == day
            )
              class_name += ' dp_disabled_current';

            // apply custom class, with the "_disabled" suffix, if a custom class exists
            if (custom_class_name != '') class_name += ' ' + custom_class_name + '_disabled';

            // if there are no restrictions
          } else {
            // if day is in weekend
            if ($.inArray(weekday, plugin.settings.weekend_days) > -1) class_name = 'dp_weekend';

            // highlight the currently selected date
            if (selected_month == default_month && selected_year == default_year && default_day == day)
              class_name += ' dp_selected';

            // highlight the current system date
            if (
              selected_month == current_system_month &&
              selected_year == current_system_year &&
              current_system_day == day
            )
              class_name += ' dp_current';

            // apply custom class, if a custom class exists
            if (custom_class_name != '') class_name += ' ' + custom_class_name;
          }

          // print the day of the month (if "day" is NaN, use an empty string instead)
          html +=
            '<td' +
            (class_name !== '' ? ' class="' + $.trim(class_name) + '"' : '') +
            '>' +
            ((plugin.settings.zero_pad ? str_pad(day, 2) : day) || '&nbsp;') +
            '</td>';
        }
      }

      // wrap up generating the day picker
      html += '</tr>';

      // inject the day picker into the DOM
      daypicker.html($(html));

      // if date picker is always visible
      if (plugin.settings.always_visible)
        // cache all the cells
        // (we need them so that we can easily remove the "dp_selected" class from all of them when user selects a date)
        daypicker_cells = $('td:not(.dp_disabled, .dp_weekend_disabled, .dp_not_in_month, .dp_week_number)', daypicker);

      // make the day picker visible
      daypicker.show();
    };

    /**
     *  Generates the month picker view, and displays it
     *
     *  @return void
     *
     *  @access private
     */
    var generate_monthpicker = function() {
      // manage header caption and enable/disable navigation buttons if necessary
      manage_header(plugin.settings.header_captions['months']);

      // start generating the HTML
      var html = '<tr>';

      // iterate through all the months
      for (var i = 0; i < 12; i++) {
        // three month per row
        if (i > 0 && i % 3 === 0) html += '</tr><tr>';

        var class_name = 'dp_month_' + i;

        // if month needs to be disabled
        if (is_disabled(selected_year, i)) class_name += ' dp_disabled';
        // else, if a date is already selected and this is that particular month, highlight it
        else if (default_month !== false && default_month == i && selected_year == default_year)
          class_name += ' dp_selected';
        // else, if this the current system month, highlight it
        else if (current_system_month == i && current_system_year == selected_year) class_name += ' dp_current';

        // first three letters of the month's name
        html +=
          '<td class="' +
          $.trim(class_name) +
          '">' +
          ($.isArray(plugin.settings.months_abbr) && undefined !== plugin.settings.months_abbr[i]
            ? plugin.settings.months_abbr[i]
            : plugin.settings.months[i].substr(0, 3)) +
          '</td>';
      }

      // wrap up
      html += '</tr>';

      // inject into the DOM
      monthpicker.html($(html));

      // if date picker is always visible
      if (plugin.settings.always_visible)
        // cache all the cells
        // (we need them so that we can easily remove the "dp_selected" class from all of them when user selects a month)
        monthpicker_cells = $('td:not(.dp_disabled)', monthpicker);

      // make the month picker visible
      monthpicker.show();
    };

    /**
     *  Generates the year picker view, and displays it
     *
     *  @return void
     *
     *  @access private
     */
    var generate_yearpicker = function() {
      // manage header caption and enable/disable navigation buttons if necessary
      manage_header(plugin.settings.header_captions['years']);

      // start generating the HTML
      var html = '<tr>';

      // we're showing 9 years at a time, current year in the middle
      for (var i = 0; i < 12; i++) {
        // three years per row
        if (i > 0 && i % 3 === 0) html += '</tr><tr>';

        var class_name = '';

        // if year needs to be disabled
        if (is_disabled(selected_year - 7 + i)) class_name += ' dp_disabled';
        // else, if a date is already selected and this is that particular year, highlight it
        else if (default_year && default_year == selected_year - 7 + i) class_name += ' dp_selected';
        // else, if this is the current system year, highlight it
        else if (current_system_year == selected_year - 7 + i) class_name += ' dp_current';

        // first three letters of the month's name
        html +=
          '<td' +
          ($.trim(class_name) !== '' ? ' class="' + $.trim(class_name) + '"' : '') +
          '>' +
          (selected_year - 7 + i) +
          '</td>';
      }

      // wrap up
      html += '</tr>';

      // inject into the DOM
      yearpicker.html($(html));

      // if date picker is always visible
      if (plugin.settings.always_visible)
        // cache all the cells
        // (we need them so that we can easily remove the "dp_selected" class from all of them when user selects a year)
        yearpicker_cells = $('td:not(.dp_disabled)', yearpicker);

      // make the year picker visible
      yearpicker.show();
    };

    /**
     *  Return the name of a custom class to be applied to the given date.
     *
     *  @return string  The name of a custom class to be applied to the given date, or an empty string if no custom
     *                  class needs to be applied.
     *
     *  @param  integer     year    The year to check
     *  @param  integer     month   The month to check
     *  @param  integer     day     The day to check
     *
     *  @access private
     */
    var get_custom_class = function(year, month, day) {
      var class_name, i, found;

      // if month is given as argument, increment it (as JavaScript uses 0 for January, 1 for February...)
      if (typeof month != 'undefined') month = month + 1;

      // iterate through the custom classes
      for (i in custom_class_names) {
        // the class name we're currently checking
        class_name = custom_class_names[i];
        found = false;

        // if there are any custom classes defined
        if ($.isArray(custom_classes[class_name]))
          // iterate through the rules for which the custom class to be applied
          $.each(custom_classes[class_name], function() {
            // if a custom class needs to be applied to the date we're checking, don't look further
            if (found) return;

            var rule = this;

            // if the rules apply for the current year
            if ($.inArray(year, rule[2]) > -1 || $.inArray('*', rule[2]) > -1)
              if ((typeof month != 'undefined' && $.inArray(month, rule[1]) > -1) || $.inArray('*', rule[1]) > -1)
                // if the rules apply for the current month
                if ((typeof day != 'undefined' && $.inArray(day, rule[0]) > -1) || $.inArray('*', rule[0]) > -1) {
                  // if the rules apply for the current day
                  // if custom class is to be applied whatever the day
                  // don't look any further
                  if (rule[3] == '*') return (found = class_name);

                  // get the weekday
                  var weekday = new Date(year, month - 1, day).getDay();

                  // if custom class is to be applied to weekday
                  // don't look any further
                  if ($.inArray(weekday, rule[3]) > -1) return (found = class_name);
                }
          });

        // if a custom class needs to be applied to the date we're checking, don't look further
        if (found) return found;
      }

      // return what we've found
      return found || '';
    };

    /**
     *  Generates an iFrame shim in Internet Explorer 6 so that the date picker appears above select boxes.
     *
     *  @return void
     *
     *  @access private
     */
    var iframeShim = function(action) {
      // this is necessary only if browser is Internet Explorer 6
      if (browser.name == 'explorer' && browser.version == 6) {
        // if the iFrame was not yet created
        // "undefined" evaluates as FALSE
        if (!shim) {
          // the iFrame has to have the element's zIndex minus 1
          var zIndex = to_int(datepicker.css('zIndex')) - 1;

          // create the iFrame
          shim = $('<iframe>', {
            src: 'javascript:document.write("")',
            scrolling: 'no',
            frameborder: 0,
            css: {
              zIndex: zIndex,
              position: 'absolute',
              top: -1000,
              left: -1000,
              width: datepicker.outerWidth(),
              height: datepicker.outerHeight(),
              filter: 'progid:DXImageTransform.Microsoft.Alpha(opacity=0)',
              display: 'none',
            },
          });

          // inject iFrame into DOM
          $('body').append(shim);
        }

        // what do we need to do
        switch (action) {
          // hide the iFrame?
          case 'hide':
            // set the iFrame's display property to "none"
            shim.hide();

            break;

          // show the iFrame?
          default:
            // get date picker top and left position
            var offset = datepicker.offset();

            // position the iFrame shim right underneath the date picker
            // and set its display to "block"
            shim.css({
              top: offset.top,
              left: offset.left,
              display: 'block',
            });
        }
      }
    };

    /**
     *  Checks if, according to the restrictions of the calendar and/or the values defined by the "disabled_dates"
     *  property, a day, a month or a year needs to be disabled.
     *
     *  @param  integer     year    The year to check
     *  @param  integer     month   The month to check
     *  @param  integer     day     The day to check
     *
     *  @return boolean         Returns TRUE if the given value is not disabled or FALSE otherwise
     *
     *  @access private
     */
    var is_disabled = function(year, month, day) {
      // don't check bogus values
      if (
        (undefined === year || isNaN(year)) &&
        (undefined === month || isNaN(month)) &&
        (undefined === day || isNaN(day))
      )
        return false;
      // this date picker cannot handle years before 1000, so we return false in this case
      else if (year < 1000) return true;

      // if calendar has direction restrictions
      if (!(!$.isArray(plugin.settings.direction) && to_int(plugin.settings.direction) === 0)) {
        var // normalize and merge arguments then transform the result to an integer
          now = to_int(
            str_concat(
              year,
              typeof month != 'undefined' ? str_pad(month, 2) : '',
              typeof day != 'undefined' ? str_pad(day, 2) : ''
            )
          ),
          // get the length of the argument
          len = (now + '').length;

        // if we're checking days
        if (
          len == 8 &&
          // day is before the first selectable date
          ((typeof start_date != 'undefined' &&
            now <
              to_int(
                str_concat(first_selectable_year, str_pad(first_selectable_month, 2), str_pad(first_selectable_day, 2))
              )) ||
            // or day is after the last selectable date
            (typeof end_date != 'undefined' &&
              now >
                to_int(
                  str_concat(last_selectable_year, str_pad(last_selectable_month, 2), str_pad(last_selectable_day, 2))
                )))

          // day needs to be disabled
        )
          return true;
        // if we're checking months
        else if (
          len == 6 &&
          // month is before the first selectable month
          ((typeof start_date != 'undefined' &&
            now < to_int(str_concat(first_selectable_year, str_pad(first_selectable_month, 2)))) ||
            // or day is after the last selectable date
            (typeof end_date != 'undefined' &&
              now > to_int(str_concat(last_selectable_year, str_pad(last_selectable_month, 2)))))

          // month needs to be disabled
        )
          return true;
        // if we're checking years
        else if (
          len == 4 &&
          // year is before the first selectable year
          ((typeof start_date != 'undefined' && now < first_selectable_year) ||
            // or day is after the last selectable date
            (typeof end_date != 'undefined' && now > last_selectable_year))

          // year needs to be disabled
        )
          return true;
      }

      // if month is given as argument, increment it (as JavaScript uses 0 for January, 1 for February...)
      if (typeof month != 'undefined') month = month + 1;

      // by default, we assume the day/month/year is not enabled nor disabled
      var disabled = false,
        enabled = false;

      // if there are rules for disabling dates
      if ($.isArray(disabled_dates) && disabled_dates.length)
        // iterate through the rules for disabling dates
        $.each(disabled_dates, function() {
          // if the date is to be disabled, don't look any further
          if (disabled) return;

          var rule = this;

          // if the rules apply for the current year
          if ($.inArray(year, rule[2]) > -1 || $.inArray('*', rule[2]) > -1)
            if ((typeof month != 'undefined' && $.inArray(month, rule[1]) > -1) || $.inArray('*', rule[1]) > -1)
              // if the rules apply for the current month
              if ((typeof day != 'undefined' && $.inArray(day, rule[0]) > -1) || $.inArray('*', rule[0]) > -1) {
                // if the rules apply for the current day
                // if day is to be disabled whatever the day
                // don't look any further
                if (rule[3] == '*') return (disabled = true);

                // get the weekday
                var weekday = new Date(year, month - 1, day).getDay();

                // if weekday is to be disabled
                // don't look any further
                if ($.inArray(weekday, rule[3]) > -1) return (disabled = true);
              }
        });

      // if there are rules that explicitly enable dates
      if (enabled_dates)
        // iterate through the rules for enabling dates
        $.each(enabled_dates, function() {
          // if the date is to be enabled, don't look any further
          if (enabled) return;

          var rule = this;

          // if the rules apply for the current year
          if ($.inArray(year, rule[2]) > -1 || $.inArray('*', rule[2]) > -1) {
            // the year is enabled
            enabled = true;

            // if we're also checking months
            if (typeof month != 'undefined') {
              // we assume the month is enabled
              enabled = true;

              // if the rules apply for the current month
              if ($.inArray(month, rule[1]) > -1 || $.inArray('*', rule[1]) > -1) {
                // if we're also checking days
                if (typeof day != 'undefined') {
                  // we assume the day is enabled
                  enabled = true;

                  // if the rules apply for the current day
                  if ($.inArray(day, rule[0]) > -1 || $.inArray('*', rule[0]) > -1) {
                    // if day is to be enabled whatever the day
                    // don't look any further
                    if (rule[3] == '*') return (enabled = true);

                    // get the weekday
                    var weekday = new Date(year, month - 1, day).getDay();

                    // if weekday is to be enabled
                    // don't look any further
                    if ($.inArray(weekday, rule[3]) > -1) return (enabled = true);

                    // if we get this far, it means the day is not enabled
                    enabled = false;

                    // if day is not enabled
                  } else enabled = false;
                }

                // if month is not enabled
              } else enabled = false;
            }
          }
        });

      // if checked date is enabled, return false
      if (enabled_dates && enabled) return false;
      // if checked date is disabled return false
      else if (disabled_dates && disabled) return true;

      // if script gets this far it means that the day/month/year doesn't need to be disabled
      return false;
    };

    /**
     *  Checks whether a value is an integer number.
     *
     *  @param  mixed   value   Value to check
     *
     *  @return                 Returns TRUE if the value represents an integer number, or FALSE otherwise
     *
     *  @access private
     */
    var is_integer = function(value) {
      // return TRUE if value represents an integer number, or FALSE otherwise
      return (value + '').match(/^\-?[0-9]+$/) ? true : false;
    };

    /**
     *  Sets the caption in the header of the date picker and enables or disables navigation buttons when necessary.
     *
     *  @param  string  caption     String that needs to be displayed in the header
     *
     *  @return void
     *
     *  @access private
     */
    var manage_header = function(caption) {
      // if "selected_month" has a value
      // $.isNumeric is available only from jQuery 1.7 - thanks to birla for the fix!
      if (!isNaN(parseFloat(selected_month)) && isFinite(selected_month))
        caption = caption.replace(/\bm\b|\bn\b|\bF\b|\bM\b/, function(match) {
          switch (match) {
            // month number, prefixed with 0
            case 'm':
              return str_pad(selected_month + 1, 2);

            // month number, not prefixed with 0
            case 'n':
              return selected_month + 1;

            // full month name
            case 'F':
              return plugin.settings.months[selected_month];

            // month name, three letters
            case 'M':
              return $.isArray(plugin.settings.months_abbr) && undefined !== plugin.settings.months_abbr[selected_month]
                ? plugin.settings.months_abbr[selected_month]
                : plugin.settings.months[selected_month].substr(0, 3);

            // unknown replace
            default:
              return match;
          }
        });

      // if "selected_year" has a value
      // $.isNumeric is available only from jQuery 1.7 - thanks to birla for the fix!
      if (!isNaN(parseFloat(selected_year)) && isFinite(selected_year))
        // replace year-related patterns
        caption = caption
          // year as four digits
          .replace(/\bY\b/, selected_year)
          // year as two digits
          .replace(/\by\b/, (selected_year + '').substr(2))
          // lower limit of year as two or four digits
          .replace(/\bY1\b/i, selected_year - 7)
          // upper limit of year as two or four digits
          .replace(/\bY2\b/i, selected_year + 4);

      // update the caption in the header
      $('.dp_caption', header).html(caption);
    };

    /**
     *  Shows the appropriate view (days, months or years) according to the current value of the "view" property.
     *
     *  @return void
     *
     *  @access private
     */
    var manage_views = function() {
      // if the day picker was not yet generated
      if (daypicker.text() === '' || view == 'days') {
        // if the day picker was not yet generated
        if (daypicker.text() === '') {
          // if date picker is not always visible
          if (!plugin.settings.always_visible)
            // temporarily set the date picker's left outside of view
            // so that we can later grab its width and height
            datepicker.css('left', -1000);

          // temporarily make the date picker visible
          // so that we can later grab its width and height
          datepicker.css('visibility', 'visible');

          // generate the day picker
          generate_daypicker();

          // get the day picker's width and height
          var width = daypicker.outerWidth(),
            height = daypicker.outerHeight();

          // make the month picker have the same size as the day picker
          monthpicker.css({
            width: width,
            height: height,
          });

          // make the year picker have the same size as the day picker
          yearpicker.css({
            width: width,
            height: height,
          });

          // make the header and the footer have the same size as the day picker
          header.css('width', width);
          footer.css('width', width);

          // hide the date picker again
          datepicker.css('visibility', '').addClass('dp_hidden');

          // if the day picker was previously generated at least once
          // generate the day picker
        } else generate_daypicker();

        // hide the year and the month pickers
        monthpicker.hide();
        yearpicker.hide();

        // if the view is "months"
      } else if (view == 'months') {
        // generate the month picker
        generate_monthpicker();

        // hide the day and the year pickers
        daypicker.hide();
        yearpicker.hide();

        // if the view is "years"
      } else if (view == 'years') {
        // generate the year picker
        generate_yearpicker();

        // hide the day and the month pickers
        daypicker.hide();
        monthpicker.hide();
      }

      // if a callback function exists for when navigating through months/years
      if (plugin.settings.onChange && typeof plugin.settings.onChange == 'function' && undefined !== view) {
        // get the "active" elements in the view (ignoring the disabled ones)
        var elements =
          view == 'days'
            ? daypicker.find('td:not(.dp_disabled, .dp_weekend_disabled, .dp_not_in_month)')
            : view == 'months'
            ? monthpicker.find('td:not(.dp_disabled, .dp_weekend_disabled, .dp_not_in_month)')
            : yearpicker.find('td:not(.dp_disabled, .dp_weekend_disabled, .dp_not_in_month)');

        // iterate through the active elements
        // and attach a "date" data attribute to each element in the form of
        // YYYY-MM-DD if the view is "days"
        // YYYY-MM if the view is "months"
        // YYYY if the view is "years"
        // so it's easy to identify elements in the list
        elements.each(function() {
          var matches;

          // if view is "days"
          if (view == 'days') {
            // if date is from a next/previous month and is selectable
            if ($(this).hasClass('dp_not_in_month_selectable')) {
              // extract date from the attached class
              matches = $(this)
                .attr('class')
                .match(/date\_([0-9]{4})(0[1-9]|1[012])(0[1-9]|[12][0-9]|3[01])/);

              // attach a "date" data attribute to each element in the form of of YYYY-MM-DD for easily identifying sought elements
              $(this).data('date', matches[1] + '-' + matches[2] + '-' + matches[3]);

              // if date is from the currently selected month
            }

            // attach a "date" data attribute to each element in the form of of YYYY-MM-DD for easily identifying sought elements
            else
              $(this).data(
                'date',
                selected_year + '-' + str_pad(selected_month + 1, 2) + '-' + str_pad(to_int($(this).text()), 2)
              );

            // if view is "months"
          } else if (view == 'months') {
            // get the month's number for the element's class
            matches = $(this)
              .attr('class')
              .match(/dp\_month\_([0-9]+)/);

            // attach a "date" data attribute to each element in the form of of YYYY-MM for easily identifying sought elements
            $(this).data('date', selected_year + '-' + str_pad(to_int(matches[1]) + 1, 2));

            // if view is "years"
          }

          // attach a "date" data attribute to each element in the form of of YYYY for easily identifying sought elements
          else $(this).data('date', to_int($(this).text()));
        });

        // execute the callback function and send as arguments the current view, the elements in the view, and
        // the element the plugin is attached to
        plugin.settings.onChange.call($element, view, elements, $element);
      }

      // assume the footer is visible
      footer.show();

      // if the button for clearing a previously selected date needs to be visible all the time,
      // or the "Clear" button needs to be shown only when a date was previously selected, and now it's the case,
      // or the date picker is always visible and the "Clear" button was not explicitly disabled
      if (
        plugin.settings.show_clear_date === true ||
        (plugin.settings.show_clear_date === 0 && $element.val() !== '') ||
        (plugin.settings.always_visible && plugin.settings.show_clear_date !== false)
      ) {
        // show the "Clear" button
        cleardate.show();

        // if the "Today" button is visible
        if (show_select_today) {
          // show it, and set it's width to 50% of the available space
          selecttoday.css('width', '50%');

          // the "Clear date" button only takes up 50% of the available space
          cleardate.css('width', '50%');

          // if the "Today" button is not visible
        } else {
          // hide the "Today" button
          selecttoday.hide();

          // the "Clear date" button takes up 100% of the available space
          cleardate.css('width', '100%');
        }

        // otherwise
      } else {
        // hide the "Clear" button
        cleardate.hide();

        // if the "Today" button is visible, it will now take up all the available space
        if (show_select_today) selecttoday.show().css('width', '100%');
        // if the "Today" button is also not visible, hide the footer entirely
        else footer.hide();
      }
    };

    /**
     *  Puts the specified date in the element the plugin is attached to, and hides the date picker.
     *
     *  @param  integer     year    The year
     *
     *  @param  integer     month   The month
     *
     *  @param  integer     day     The day
     *
     *  @param  string      view    The view from where the method was called
     *
     *  @param  object      cell    The element that was clicked
     *
     *  @return void
     *
     *  @access private
     */
    var select_date = function(year, month, day, view, cell) {
      var // construct a new date object from the arguments
        default_date = new Date(year, month, day, 12, 0, 0),
        // pointer to the cells in the current view
        view_cells = view == 'days' ? daypicker_cells : view == 'months' ? monthpicker_cells : yearpicker_cells,
        // the selected date, formatted correctly
        selected_value = format(default_date);

      // set the currently selected and formated date as the value of the element the plugin is attached to
      $element.val(selected_value);

      // if date picker is always visible
      if (plugin.settings.always_visible) {
        // extract the date parts and reassign values to these variables
        // so that everything will be correctly highlighted
        default_month = default_date.getMonth();
        selected_month = default_date.getMonth();
        default_year = default_date.getFullYear();
        selected_year = default_date.getFullYear();
        default_day = default_date.getDate();

        // remove the "selected" class from all cells in the current view
        view_cells.removeClass('dp_selected');

        // add the "selected" class to the currently selected cell
        cell.addClass('dp_selected');

        // if we're on the "days" view and days from other months are selectable and one of those days was
        // selected, repaint the datepicker so it will take us to the selected month
        if (view == 'days' && cell.hasClass('dp_not_in_month_selectable')) plugin.show();
      }

      // hide the date picker
      plugin.hide();

      // updates value for the date picker whose starting date depends on the selected date (if any)
      update_dependent(default_date);

      // if a callback function exists for when selecting a date
      if (plugin.settings.onSelect && typeof plugin.settings.onSelect == 'function')
        // execute the callback function
        // make "this" inside the callback function refer to the element the date picker is attached to
        plugin.settings.onSelect.call(
          $element,
          selected_value,
          year + '-' + str_pad(month + 1, 2) + '-' + str_pad(day, 2),
          default_date,
          $element,
          getWeekNumber(default_date)
        );

      // move focus to the element the plugin is attached to
      $element.focus();
    };

    /**
     *  Concatenates any number of arguments and returns them as string.
     *
     *  @return string  Returns the concatenated values.
     *
     *  @access private
     */
    var str_concat = function() {
      var str = '';

      // concatenate as string
      for (var i = 0; i < arguments.length; i++) str += arguments[i] + '';

      // return the concatenated values
      return str;
    };

    /**
     *  Left-pad a string to a certain length with zeroes.
     *
     *  @param  string  str     The string to be padded.
     *
     *  @param  integer len     The length to which the string must be padded
     *
     *  @return string          Returns the string left-padded with leading zeroes
     *
     *  @access private
     */
    var str_pad = function(str, len) {
      // make sure argument is a string
      str += '';

      // pad with leading zeroes until we get to the desired length
      while (str.length < len) str = '0' + str;

      // return padded string
      return str;
    };

    /**
     *  Returns the integer representation of a string
     *
     *  @return int     Returns the integer representation of the string given as argument
     *
     *  @access private
     */
    var to_int = function(str) {
      // return the integer representation of the string given as argument
      return parseInt(str, 10);
    };

    /**
     *  Updates the paired date picker (whose starting date depends on the value of the current date picker)
     *
     *  @param  date    date    A JavaScript date object representing the currently selected date
     *
     *  @return void
     *
     *  @access private
     */
    var update_dependent = function(date) {
      // if the pair element exists
      if (plugin.settings.pair) {
        // iterate through the pair elements (as there may be more than just one)
        $.each(plugin.settings.pair, function() {
          var $pair = $(this);

          // chances are that in the beginning the pair element doesn't have the Zebra_DatePicker attached to it yet
          // (as the "start" element is usually created before the "end" element)
          // so we'll have to rely on "data" to send the starting date to the pair element

          // therefore, if Zebra_DatePicker is not yet attached
          if (!($pair.data && $pair.data('Zebra_DatePicker')))
            // set the starting date like this
            $pair.data('zdp_reference_date', date);
          // if Zebra_DatePicker is attached to the pair element
          else {
            // reference the date picker object attached to the other element
            var dp = $pair.data('Zebra_DatePicker');

            // update the other date picker's starting date
            // the value depends on the original value of the "direction" attribute
            // (also, if the pair date picker does not have a direction, set it to 1)
            dp.update({
              reference_date: date,
              direction: dp.settings.direction === 0 ? 1 : dp.settings.direction,
            });

            // if the other date picker is always visible, update the visuals now
            if (dp.settings.always_visible) dp.show();
          }
        });
      }
    };

    /**
     *  Calculate the ISO 8601 week number for a given date.
     *
     *  Code is based on the algorithm at http://www.tondering.dk/claus/cal/week.php#calcweekno
     */
    var getWeekNumber = function(date) {
      var y = date.getFullYear(),
        m = date.getMonth() + 1,
        d = date.getDate(),
        a,
        b,
        c,
        s,
        e,
        f,
        g,
        n,
        w;

      // If month jan. or feb.
      if (m < 3) {
        a = y - 1;
        b = ((a / 4) | 0) - ((a / 100) | 0) + ((a / 400) | 0);
        c = (((a - 1) / 4) | 0) - (((a - 1) / 100) | 0) + (((a - 1) / 400) | 0);
        s = b - c;
        e = 0;
        f = d - 1 + 31 * (m - 1);

        // If month mar. through dec.
      } else {
        a = y;
        b = ((a / 4) | 0) - ((a / 100) | 0) + ((a / 400) | 0);
        c = (((a - 1) / 4) | 0) - (((a - 1) / 100) | 0) + (((a - 1) / 400) | 0);
        s = b - c;
        e = s + 1;
        f = d + (((153 * (m - 3) + 2) / 5) | 0) + 58 + s;
      }

      g = (a + b) % 7;
      // ISO Weekday (0 is monday, 1 is tuesday etc.)
      d = (f + g - e) % 7;
      n = f + 3 - d;

      if (n < 0) w = 53 - (((g - s) / 5) | 0);
      else if (n > 364 + s) w = 1;
      else w = ((n / 7) | 0) + 1;

      return w;
    };

    // since with jQuery 1.9.0 the $.browser object was removed, we rely on this piece of code from
    // http://www.quirksmode.org/js/detect.html to detect the browser
    var browser = {
      init: function() {
        this.name = this.searchString(this.dataBrowser) || '';
        this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || '';
      },
      searchString: function(data) {
        for (var i = 0; i < data.length; i++) {
          var dataString = data[i].string;
          var dataProp = data[i].prop;
          this.versionSearchString = data[i].versionSearch || data[i].identity;
          if (dataString) {
            if (dataString.indexOf(data[i].subString) != -1) return data[i].identity;
          } else if (dataProp) return data[i].identity;
        }
      },
      searchVersion: function(dataString) {
        var index = dataString.indexOf(this.versionSearchString);
        if (index == -1) return;
        return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
      },
      dataBrowser: [
        {
          string: navigator.userAgent,
          subString: 'Firefox',
          identity: 'firefox',
        },
        {
          string: navigator.userAgent,
          subString: 'MSIE',
          identity: 'explorer',
          versionSearch: 'MSIE',
        },
      ],
    };

    browser.init();

    // initialize the plugin
    init();
  };

  $.fn.Zebra_DatePicker = function(options) {
    // iterate through all the elements to which we need to attach the date picker to
    return this.each(function() {
      // if element has a date picker already attached
      if (undefined !== $(this).data('Zebra_DatePicker'))
        // remove the attached date picker
        $(this)
          .data('Zebra_DatePicker')
          .destroy();

      // create an instance of the plugin
      var plugin = new $.Zebra_DatePicker(this, options);

      // save a reference to the newly created object
      $(this).data('Zebra_DatePicker', plugin);
    });
  };
});

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
!(function(a) {
  'use strict';
  'function' == typeof define && define.amd
    ? define(['jquery'], a)
    : 'undefined' != typeof exports
    ? (module.exports = a(require('jquery')))
    : a(jQuery);
})(function(a) {
  'use strict';
  var b = window.Slick || {};
  (b = (function() {
    function c(c, d) {
      var f,
        e = this;
      (e.defaults = {
        accessibility: !0,
        adaptiveHeight: !1,
        appendArrows: a(c),
        appendDots: a(c),
        arrows: !0,
        asNavFor: null,
        prevArrow:
          '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',
        nextArrow:
          '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',
        autoplay: !1,
        autoplaySpeed: 3e3,
        centerMode: !1,
        centerPadding: '50px',
        cssEase: 'ease',
        customPaging: function(b, c) {
          return a('<button type="button" data-role="none" role="button" tabindex="0" />').text(c + 1);
        },
        dots: !1,
        dotsClass: 'slick-dots',
        draggable: !0,
        easing: 'linear',
        edgeFriction: 0.35,
        fade: !1,
        focusOnSelect: !1,
        infinite: !0,
        initialSlide: 0,
        lazyLoad: 'ondemand',
        mobileFirst: !1,
        pauseOnHover: !0,
        pauseOnFocus: !0,
        pauseOnDotsHover: !1,
        respondTo: 'window',
        responsive: null,
        rows: 1,
        rtl: !1,
        slide: '',
        slidesPerRow: 1,
        slidesToShow: 1,
        slidesToScroll: 1,
        speed: 500,
        swipe: !0,
        swipeToSlide: !1,
        touchMove: !0,
        touchThreshold: 5,
        useCSS: !0,
        useTransform: !0,
        variableWidth: !1,
        vertical: !1,
        verticalSwiping: !1,
        waitForAnimate: !0,
        zIndex: 1e3,
      }),
        (e.initials = {
          animating: !1,
          dragging: !1,
          autoPlayTimer: null,
          currentDirection: 0,
          currentLeft: null,
          currentSlide: 0,
          direction: 1,
          $dots: null,
          listWidth: null,
          listHeight: null,
          loadIndex: 0,
          $nextArrow: null,
          $prevArrow: null,
          slideCount: null,
          slideWidth: null,
          $slideTrack: null,
          $slides: null,
          sliding: !1,
          slideOffset: 0,
          swipeLeft: null,
          $list: null,
          touchObject: {},
          transformsEnabled: !1,
          unslicked: !1,
        }),
        a.extend(e, e.initials),
        (e.activeBreakpoint = null),
        (e.animType = null),
        (e.animProp = null),
        (e.breakpoints = []),
        (e.breakpointSettings = []),
        (e.cssTransitions = !1),
        (e.focussed = !1),
        (e.interrupted = !1),
        (e.hidden = 'hidden'),
        (e.paused = !0),
        (e.positionProp = null),
        (e.respondTo = null),
        (e.rowCount = 1),
        (e.shouldClick = !0),
        (e.$slider = a(c)),
        (e.$slidesCache = null),
        (e.transformType = null),
        (e.transitionType = null),
        (e.visibilityChange = 'visibilitychange'),
        (e.windowWidth = 0),
        (e.windowTimer = null),
        (f = a(c).data('slick') || {}),
        (e.options = a.extend({}, e.defaults, d, f)),
        (e.currentSlide = e.options.initialSlide),
        (e.originalSettings = e.options),
        'undefined' != typeof document.mozHidden
          ? ((e.hidden = 'mozHidden'), (e.visibilityChange = 'mozvisibilitychange'))
          : 'undefined' != typeof document.webkitHidden &&
            ((e.hidden = 'webkitHidden'), (e.visibilityChange = 'webkitvisibilitychange')),
        (e.autoPlay = a.proxy(e.autoPlay, e)),
        (e.autoPlayClear = a.proxy(e.autoPlayClear, e)),
        (e.autoPlayIterator = a.proxy(e.autoPlayIterator, e)),
        (e.changeSlide = a.proxy(e.changeSlide, e)),
        (e.clickHandler = a.proxy(e.clickHandler, e)),
        (e.selectHandler = a.proxy(e.selectHandler, e)),
        (e.setPosition = a.proxy(e.setPosition, e)),
        (e.swipeHandler = a.proxy(e.swipeHandler, e)),
        (e.dragHandler = a.proxy(e.dragHandler, e)),
        (e.keyHandler = a.proxy(e.keyHandler, e)),
        (e.instanceUid = b++),
        (e.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/),
        e.registerBreakpoints(),
        e.init(!0);
    }
    var b = 0;
    return c;
  })()),
    (b.prototype.activateADA = function() {
      var a = this;
      a.$slideTrack
        .find('.slick-active')
        .attr({ 'aria-hidden': 'false' })
        .find('a, input, button, select')
        .attr({ tabindex: '0' });
    }),
    (b.prototype.addSlide = b.prototype.slickAdd = function(b, c, d) {
      var e = this;
      if ('boolean' == typeof c) (d = c), (c = null);
      else if (0 > c || c >= e.slideCount) return !1;
      e.unload(),
        'number' == typeof c
          ? 0 === c && 0 === e.$slides.length
            ? a(b).appendTo(e.$slideTrack)
            : d
            ? a(b).insertBefore(e.$slides.eq(c))
            : a(b).insertAfter(e.$slides.eq(c))
          : d === !0
          ? a(b).prependTo(e.$slideTrack)
          : a(b).appendTo(e.$slideTrack),
        (e.$slides = e.$slideTrack.children(this.options.slide)),
        e.$slideTrack.children(this.options.slide).detach(),
        e.$slideTrack.append(e.$slides),
        e.$slides.each(function(b, c) {
          a(c).attr('data-slick-index', b);
        }),
        (e.$slidesCache = e.$slides),
        e.reinit();
    }),
    (b.prototype.animateHeight = function() {
      var a = this;
      if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
        var b = a.$slides.eq(a.currentSlide).outerHeight(!0);
        a.$list.animate({ height: b }, a.options.speed);
      }
    }),
    (b.prototype.animateSlide = function(b, c) {
      var d = {},
        e = this;
      e.animateHeight(),
        e.options.rtl === !0 && e.options.vertical === !1 && (b = -b),
        e.transformsEnabled === !1
          ? e.options.vertical === !1
            ? e.$slideTrack.animate({ left: b }, e.options.speed, e.options.easing, c)
            : e.$slideTrack.animate({ top: b }, e.options.speed, e.options.easing, c)
          : e.cssTransitions === !1
          ? (e.options.rtl === !0 && (e.currentLeft = -e.currentLeft),
            a({ animStart: e.currentLeft }).animate(
              { animStart: b },
              {
                duration: e.options.speed,
                easing: e.options.easing,
                step: function(a) {
                  (a = Math.ceil(a)),
                    e.options.vertical === !1
                      ? ((d[e.animType] = 'translate(' + a + 'px, 0px)'), e.$slideTrack.css(d))
                      : ((d[e.animType] = 'translate(0px,' + a + 'px)'), e.$slideTrack.css(d));
                },
                complete: function() {
                  c && c.call();
                },
              }
            ))
          : (e.applyTransition(),
            (b = Math.ceil(b)),
            e.options.vertical === !1
              ? (d[e.animType] = 'translate3d(' + b + 'px, 0px, 0px)')
              : (d[e.animType] = 'translate3d(0px,' + b + 'px, 0px)'),
            e.$slideTrack.css(d),
            c &&
              setTimeout(function() {
                e.disableTransition(), c.call();
              }, e.options.speed));
    }),
    (b.prototype.getNavTarget = function() {
      var b = this,
        c = b.options.asNavFor;
      return c && null !== c && (c = a(c).not(b.$slider)), c;
    }),
    (b.prototype.asNavFor = function(b) {
      var c = this,
        d = c.getNavTarget();
      null !== d &&
        'object' == typeof d &&
        d.each(function() {
          var c = a(this).slick('getSlick');
          c.unslicked || c.slideHandler(b, !0);
        });
    }),
    (b.prototype.applyTransition = function(a) {
      var b = this,
        c = {};
      b.options.fade === !1
        ? (c[b.transitionType] = b.transformType + ' ' + b.options.speed + 'ms ' + b.options.cssEase)
        : (c[b.transitionType] = 'opacity ' + b.options.speed + 'ms ' + b.options.cssEase),
        b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
    }),
    (b.prototype.autoPlay = function() {
      var a = this;
      a.autoPlayClear(),
        a.slideCount > a.options.slidesToShow &&
          (a.autoPlayTimer = setInterval(a.autoPlayIterator, a.options.autoplaySpeed));
    }),
    (b.prototype.autoPlayClear = function() {
      var a = this;
      a.autoPlayTimer && clearInterval(a.autoPlayTimer);
    }),
    (b.prototype.autoPlayIterator = function() {
      var a = this,
        b = a.currentSlide + a.options.slidesToScroll;
      a.paused ||
        a.interrupted ||
        a.focussed ||
        (a.options.infinite === !1 &&
          (1 === a.direction && a.currentSlide + 1 === a.slideCount - 1
            ? (a.direction = 0)
            : 0 === a.direction &&
              ((b = a.currentSlide - a.options.slidesToScroll), a.currentSlide - 1 === 0 && (a.direction = 1))),
        a.slideHandler(b));
    }),
    (b.prototype.buildArrows = function() {
      var b = this;
      b.options.arrows === !0 &&
        ((b.$prevArrow = a(b.options.prevArrow).addClass('slick-arrow')),
        (b.$nextArrow = a(b.options.nextArrow).addClass('slick-arrow')),
        b.slideCount > b.options.slidesToShow
          ? (b.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex'),
            b.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex'),
            b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.prependTo(b.options.appendArrows),
            b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.appendTo(b.options.appendArrows),
            b.options.infinite !== !0 && b.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true'))
          : b.$prevArrow
              .add(b.$nextArrow)
              .addClass('slick-hidden')
              .attr({ 'aria-disabled': 'true', tabindex: '-1' }));
    }),
    (b.prototype.buildDots = function() {
      var c,
        d,
        b = this;
      if (b.options.dots === !0 && b.slideCount > b.options.slidesToShow) {
        for (
          b.$slider.addClass('slick-dotted'), d = a('<ul />').addClass(b.options.dotsClass), c = 0;
          c <= b.getDotCount();
          c += 1
        )
          d.append(a('<li />').append(b.options.customPaging.call(this, b, c)));
        (b.$dots = d.appendTo(b.options.appendDots)),
          b.$dots
            .find('li')
            .first()
            .addClass('slick-active')
            .attr('aria-hidden', 'false');
      }
    }),
    (b.prototype.buildOut = function() {
      var b = this;
      (b.$slides = b.$slider.children(b.options.slide + ':not(.slick-cloned)').addClass('slick-slide')),
        (b.slideCount = b.$slides.length),
        b.$slides.each(function(b, c) {
          a(c)
            .attr('data-slick-index', b)
            .data('originalStyling', a(c).attr('style') || '');
        }),
        b.$slider.addClass('slick-slider'),
        (b.$slideTrack =
          0 === b.slideCount
            ? a('<div class="slick-track"/>').appendTo(b.$slider)
            : b.$slides.wrapAll('<div class="slick-track"/>').parent()),
        (b.$list = b.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent()),
        b.$slideTrack.css('opacity', 0),
        (b.options.centerMode === !0 || b.options.swipeToSlide === !0) && (b.options.slidesToScroll = 1),
        a('img[data-lazy]', b.$slider)
          .not('[src]')
          .addClass('slick-loading'),
        b.setupInfinite(),
        b.buildArrows(),
        b.buildDots(),
        b.updateDots(),
        b.setSlideClasses('number' == typeof b.currentSlide ? b.currentSlide : 0),
        b.options.draggable === !0 && b.$list.addClass('draggable');
    }),
    (b.prototype.buildRows = function() {
      var b,
        c,
        d,
        e,
        f,
        g,
        h,
        a = this;
      if (((e = document.createDocumentFragment()), (g = a.$slider.children()), a.options.rows > 1)) {
        for (h = a.options.slidesPerRow * a.options.rows, f = Math.ceil(g.length / h), b = 0; f > b; b++) {
          var i = document.createElement('div');
          for (c = 0; c < a.options.rows; c++) {
            var j = document.createElement('div');
            for (d = 0; d < a.options.slidesPerRow; d++) {
              var k = b * h + (c * a.options.slidesPerRow + d);
              g.get(k) && j.appendChild(g.get(k));
            }
            i.appendChild(j);
          }
          e.appendChild(i);
        }
        a.$slider.empty().append(e),
          a.$slider
            .children()
            .children()
            .children()
            .css({ width: 100 / a.options.slidesPerRow + '%', display: 'inline-block' });
      }
    }),
    (b.prototype.checkResponsive = function(b, c) {
      var e,
        f,
        g,
        d = this,
        h = !1,
        i = d.$slider.width(),
        j = window.innerWidth || a(window).width();
      if (
        ('window' === d.respondTo
          ? (g = j)
          : 'slider' === d.respondTo
          ? (g = i)
          : 'min' === d.respondTo && (g = Math.min(j, i)),
        d.options.responsive && d.options.responsive.length && null !== d.options.responsive)
      ) {
        f = null;
        for (e in d.breakpoints)
          d.breakpoints.hasOwnProperty(e) &&
            (d.originalSettings.mobileFirst === !1
              ? g < d.breakpoints[e] && (f = d.breakpoints[e])
              : g > d.breakpoints[e] && (f = d.breakpoints[e]));
        null !== f
          ? null !== d.activeBreakpoint
            ? (f !== d.activeBreakpoint || c) &&
              ((d.activeBreakpoint = f),
              'unslick' === d.breakpointSettings[f]
                ? d.unslick(f)
                : ((d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f])),
                  b === !0 && (d.currentSlide = d.options.initialSlide),
                  d.refresh(b)),
              (h = f))
            : ((d.activeBreakpoint = f),
              'unslick' === d.breakpointSettings[f]
                ? d.unslick(f)
                : ((d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f])),
                  b === !0 && (d.currentSlide = d.options.initialSlide),
                  d.refresh(b)),
              (h = f))
          : null !== d.activeBreakpoint &&
            ((d.activeBreakpoint = null),
            (d.options = d.originalSettings),
            b === !0 && (d.currentSlide = d.options.initialSlide),
            d.refresh(b),
            (h = f)),
          b || h === !1 || d.$slider.trigger('breakpoint', [d, h]);
      }
    }),
    (b.prototype.changeSlide = function(b, c) {
      var f,
        g,
        h,
        d = this,
        e = a(b.currentTarget);
      switch (
        (e.is('a') && b.preventDefault(),
        e.is('li') || (e = e.closest('li')),
        (h = d.slideCount % d.options.slidesToScroll !== 0),
        (f = h ? 0 : (d.slideCount - d.currentSlide) % d.options.slidesToScroll),
        b.data.message)
      ) {
        case 'previous':
          (g = 0 === f ? d.options.slidesToScroll : d.options.slidesToShow - f),
            d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide - g, !1, c);
          break;
        case 'next':
          (g = 0 === f ? d.options.slidesToScroll : f),
            d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide + g, !1, c);
          break;
        case 'index':
          var i = 0 === b.data.index ? 0 : b.data.index || e.index() * d.options.slidesToScroll;
          d.slideHandler(d.checkNavigable(i), !1, c), e.children().trigger('focus');
          break;
        default:
          return;
      }
    }),
    (b.prototype.checkNavigable = function(a) {
      var c,
        d,
        b = this;
      if (((c = b.getNavigableIndexes()), (d = 0), a > c[c.length - 1])) a = c[c.length - 1];
      else
        for (var e in c) {
          if (a < c[e]) {
            a = d;
            break;
          }
          d = c[e];
        }
      return a;
    }),
    (b.prototype.cleanUpEvents = function() {
      var b = this;
      b.options.dots &&
        null !== b.$dots &&
        a('li', b.$dots)
          .off('click.slick', b.changeSlide)
          .off('mouseenter.slick', a.proxy(b.interrupt, b, !0))
          .off('mouseleave.slick', a.proxy(b.interrupt, b, !1)),
        b.$slider.off('focus.slick blur.slick'),
        b.options.arrows === !0 &&
          b.slideCount > b.options.slidesToShow &&
          (b.$prevArrow && b.$prevArrow.off('click.slick', b.changeSlide),
          b.$nextArrow && b.$nextArrow.off('click.slick', b.changeSlide)),
        b.$list.off('touchstart.slick mousedown.slick', b.swipeHandler),
        b.$list.off('touchmove.slick mousemove.slick', b.swipeHandler),
        b.$list.off('touchend.slick mouseup.slick', b.swipeHandler),
        b.$list.off('touchcancel.slick mouseleave.slick', b.swipeHandler),
        b.$list.off('click.slick', b.clickHandler),
        a(document).off(b.visibilityChange, b.visibility),
        b.cleanUpSlideEvents(),
        b.options.accessibility === !0 && b.$list.off('keydown.slick', b.keyHandler),
        b.options.focusOnSelect === !0 &&
          a(b.$slideTrack)
            .children()
            .off('click.slick', b.selectHandler),
        a(window).off('orientationchange.slick.slick-' + b.instanceUid, b.orientationChange),
        a(window).off('resize.slick.slick-' + b.instanceUid, b.resize),
        a('[draggable!=true]', b.$slideTrack).off('dragstart', b.preventDefault),
        a(window).off('load.slick.slick-' + b.instanceUid, b.setPosition),
        a(document).off('ready.slick.slick-' + b.instanceUid, b.setPosition);
    }),
    (b.prototype.cleanUpSlideEvents = function() {
      var b = this;
      b.$list.off('mouseenter.slick', a.proxy(b.interrupt, b, !0)),
        b.$list.off('mouseleave.slick', a.proxy(b.interrupt, b, !1));
    }),
    (b.prototype.cleanUpRows = function() {
      var b,
        a = this;
      a.options.rows > 1 && ((b = a.$slides.children().children()), b.removeAttr('style'), a.$slider.empty().append(b));
    }),
    (b.prototype.clickHandler = function(a) {
      var b = this;
      b.shouldClick === !1 && (a.stopImmediatePropagation(), a.stopPropagation(), a.preventDefault());
    }),
    (b.prototype.destroy = function(b) {
      var c = this;
      c.autoPlayClear(),
        (c.touchObject = {}),
        c.cleanUpEvents(),
        a('.slick-cloned', c.$slider).detach(),
        c.$dots && c.$dots.remove(),
        c.$prevArrow &&
          c.$prevArrow.length &&
          (c.$prevArrow
            .removeClass('slick-disabled slick-arrow slick-hidden')
            .removeAttr('aria-hidden aria-disabled tabindex')
            .css('display', ''),
          c.htmlExpr.test(c.options.prevArrow) && c.$prevArrow.remove()),
        c.$nextArrow &&
          c.$nextArrow.length &&
          (c.$nextArrow
            .removeClass('slick-disabled slick-arrow slick-hidden')
            .removeAttr('aria-hidden aria-disabled tabindex')
            .css('display', ''),
          c.htmlExpr.test(c.options.nextArrow) && c.$nextArrow.remove()),
        c.$slides &&
          (c.$slides
            .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
            .removeAttr('aria-hidden')
            .removeAttr('data-slick-index')
            .each(function() {
              a(this).attr('style', a(this).data('originalStyling'));
            }),
          c.$slideTrack.children(this.options.slide).detach(),
          c.$slideTrack.detach(),
          c.$list.detach(),
          c.$slider.append(c.$slides)),
        c.cleanUpRows(),
        c.$slider.removeClass('slick-slider'),
        c.$slider.removeClass('slick-initialized'),
        c.$slider.removeClass('slick-dotted'),
        (c.unslicked = !0),
        b || c.$slider.trigger('destroy', [c]);
    }),
    (b.prototype.disableTransition = function(a) {
      var b = this,
        c = {};
      (c[b.transitionType] = ''), b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
    }),
    (b.prototype.fadeSlide = function(a, b) {
      var c = this;
      c.cssTransitions === !1
        ? (c.$slides.eq(a).css({ zIndex: c.options.zIndex }),
          c.$slides.eq(a).animate({ opacity: 1 }, c.options.speed, c.options.easing, b))
        : (c.applyTransition(a),
          c.$slides.eq(a).css({ opacity: 1, zIndex: c.options.zIndex }),
          b &&
            setTimeout(function() {
              c.disableTransition(a), b.call();
            }, c.options.speed));
    }),
    (b.prototype.fadeSlideOut = function(a) {
      var b = this;
      b.cssTransitions === !1
        ? b.$slides.eq(a).animate({ opacity: 0, zIndex: b.options.zIndex - 2 }, b.options.speed, b.options.easing)
        : (b.applyTransition(a), b.$slides.eq(a).css({ opacity: 0, zIndex: b.options.zIndex - 2 }));
    }),
    (b.prototype.filterSlides = b.prototype.slickFilter = function(a) {
      var b = this;
      null !== a &&
        ((b.$slidesCache = b.$slides),
        b.unload(),
        b.$slideTrack.children(this.options.slide).detach(),
        b.$slidesCache.filter(a).appendTo(b.$slideTrack),
        b.reinit());
    }),
    (b.prototype.focusHandler = function() {
      var b = this;
      b.$slider.off('focus.slick blur.slick').on('focus.slick blur.slick', '*:not(.slick-arrow)', function(c) {
        c.stopImmediatePropagation();
        var d = a(this);
        setTimeout(function() {
          b.options.pauseOnFocus && ((b.focussed = d.is(':focus')), b.autoPlay());
        }, 0);
      });
    }),
    (b.prototype.getCurrent = b.prototype.slickCurrentSlide = function() {
      var a = this;
      return a.currentSlide;
    }),
    (b.prototype.getDotCount = function() {
      var a = this,
        b = 0,
        c = 0,
        d = 0;
      if (a.options.infinite === !0)
        for (; b < a.slideCount; )
          ++d,
            (b = c + a.options.slidesToScroll),
            (c +=
              a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow);
      else if (a.options.centerMode === !0) d = a.slideCount;
      else if (a.options.asNavFor)
        for (; b < a.slideCount; )
          ++d,
            (b = c + a.options.slidesToScroll),
            (c +=
              a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow);
      else d = 1 + Math.ceil((a.slideCount - a.options.slidesToShow) / a.options.slidesToScroll);
      return d - 1;
    }),
    (b.prototype.getLeft = function(a) {
      var c,
        d,
        f,
        b = this,
        e = 0;
      return (
        (b.slideOffset = 0),
        (d = b.$slides.first().outerHeight(!0)),
        b.options.infinite === !0
          ? (b.slideCount > b.options.slidesToShow &&
              ((b.slideOffset = b.slideWidth * b.options.slidesToShow * -1), (e = d * b.options.slidesToShow * -1)),
            b.slideCount % b.options.slidesToScroll !== 0 &&
              a + b.options.slidesToScroll > b.slideCount &&
              b.slideCount > b.options.slidesToShow &&
              (a > b.slideCount
                ? ((b.slideOffset = (b.options.slidesToShow - (a - b.slideCount)) * b.slideWidth * -1),
                  (e = (b.options.slidesToShow - (a - b.slideCount)) * d * -1))
                : ((b.slideOffset = (b.slideCount % b.options.slidesToScroll) * b.slideWidth * -1),
                  (e = (b.slideCount % b.options.slidesToScroll) * d * -1))))
          : a + b.options.slidesToShow > b.slideCount &&
            ((b.slideOffset = (a + b.options.slidesToShow - b.slideCount) * b.slideWidth),
            (e = (a + b.options.slidesToShow - b.slideCount) * d)),
        b.slideCount <= b.options.slidesToShow && ((b.slideOffset = 0), (e = 0)),
        b.options.centerMode === !0 && b.options.infinite === !0
          ? (b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2) - b.slideWidth)
          : b.options.centerMode === !0 &&
            ((b.slideOffset = 0), (b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2))),
        (c = b.options.vertical === !1 ? a * b.slideWidth * -1 + b.slideOffset : a * d * -1 + e),
        b.options.variableWidth === !0 &&
          ((f =
            b.slideCount <= b.options.slidesToShow || b.options.infinite === !1
              ? b.$slideTrack.children('.slick-slide').eq(a)
              : b.$slideTrack.children('.slick-slide').eq(a + b.options.slidesToShow)),
          (c =
            b.options.rtl === !0
              ? f[0]
                ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width())
                : 0
              : f[0]
              ? -1 * f[0].offsetLeft
              : 0),
          b.options.centerMode === !0 &&
            ((f =
              b.slideCount <= b.options.slidesToShow || b.options.infinite === !1
                ? b.$slideTrack.children('.slick-slide').eq(a)
                : b.$slideTrack.children('.slick-slide').eq(a + b.options.slidesToShow + 1)),
            (c =
              b.options.rtl === !0
                ? f[0]
                  ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width())
                  : 0
                : f[0]
                ? -1 * f[0].offsetLeft
                : 0),
            (c += (b.$list.width() - f.outerWidth()) / 2))),
        c
      );
    }),
    (b.prototype.getOption = b.prototype.slickGetOption = function(a) {
      var b = this;
      return b.options[a];
    }),
    (b.prototype.getNavigableIndexes = function() {
      var e,
        a = this,
        b = 0,
        c = 0,
        d = [];
      for (
        a.options.infinite === !1
          ? (e = a.slideCount)
          : ((b = -1 * a.options.slidesToScroll), (c = -1 * a.options.slidesToScroll), (e = 2 * a.slideCount));
        e > b;

      )
        d.push(b),
          (b = c + a.options.slidesToScroll),
          (c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow);
      return d;
    }),
    (b.prototype.getSlick = function() {
      return this;
    }),
    (b.prototype.getSlideCount = function() {
      var c,
        d,
        e,
        b = this;
      return (
        (e = b.options.centerMode === !0 ? b.slideWidth * Math.floor(b.options.slidesToShow / 2) : 0),
        b.options.swipeToSlide === !0
          ? (b.$slideTrack.find('.slick-slide').each(function(c, f) {
              return f.offsetLeft - e + a(f).outerWidth() / 2 > -1 * b.swipeLeft ? ((d = f), !1) : void 0;
            }),
            (c = Math.abs(a(d).attr('data-slick-index') - b.currentSlide) || 1))
          : b.options.slidesToScroll
      );
    }),
    (b.prototype.goTo = b.prototype.slickGoTo = function(a, b) {
      var c = this;
      c.changeSlide({ data: { message: 'index', index: parseInt(a) } }, b);
    }),
    (b.prototype.init = function(b) {
      var c = this;
      a(c.$slider).hasClass('slick-initialized') ||
        (a(c.$slider).addClass('slick-initialized'),
        c.buildRows(),
        c.buildOut(),
        c.setProps(),
        c.startLoad(),
        c.loadSlider(),
        c.initializeEvents(),
        c.updateArrows(),
        c.updateDots(),
        c.checkResponsive(!0),
        c.focusHandler()),
        b && c.$slider.trigger('init', [c]),
        c.options.accessibility === !0 && c.initADA(),
        c.options.autoplay && ((c.paused = !1), c.autoPlay());
    }),
    (b.prototype.initADA = function() {
      var b = this;
      b.$slides
        .add(b.$slideTrack.find('.slick-cloned'))
        .attr({ 'aria-hidden': 'true', tabindex: '-1' })
        .find('a, input, button, select')
        .attr({ tabindex: '-1' }),
        b.$slideTrack.attr('role', 'listbox'),
        b.$slides.not(b.$slideTrack.find('.slick-cloned')).each(function(c) {
          a(this).attr({ role: 'option', 'aria-describedby': 'slick-slide' + b.instanceUid + c });
        }),
        null !== b.$dots &&
          b.$dots
            .attr('role', 'tablist')
            .find('li')
            .each(function(c) {
              a(this).attr({
                role: 'presentation',
                'aria-selected': 'false',
                'aria-controls': 'navigation' + b.instanceUid + c,
                id: 'slick-slide' + b.instanceUid + c,
              });
            })
            .first()
            .attr('aria-selected', 'true')
            .end()
            .find('button')
            .attr('role', 'button')
            .end()
            .closest('div')
            .attr('role', 'toolbar'),
        b.activateADA();
    }),
    (b.prototype.initArrowEvents = function() {
      var a = this;
      a.options.arrows === !0 &&
        a.slideCount > a.options.slidesToShow &&
        (a.$prevArrow.off('click.slick').on('click.slick', { message: 'previous' }, a.changeSlide),
        a.$nextArrow.off('click.slick').on('click.slick', { message: 'next' }, a.changeSlide));
    }),
    (b.prototype.initDotEvents = function() {
      var b = this;
      b.options.dots === !0 &&
        b.slideCount > b.options.slidesToShow &&
        a('li', b.$dots).on('click.slick', { message: 'index' }, b.changeSlide),
        b.options.dots === !0 &&
          b.options.pauseOnDotsHover === !0 &&
          a('li', b.$dots)
            .on('mouseenter.slick', a.proxy(b.interrupt, b, !0))
            .on('mouseleave.slick', a.proxy(b.interrupt, b, !1));
    }),
    (b.prototype.initSlideEvents = function() {
      var b = this;
      b.options.pauseOnHover &&
        (b.$list.on('mouseenter.slick', a.proxy(b.interrupt, b, !0)),
        b.$list.on('mouseleave.slick', a.proxy(b.interrupt, b, !1)));
    }),
    (b.prototype.initializeEvents = function() {
      var b = this;
      b.initArrowEvents(),
        b.initDotEvents(),
        b.initSlideEvents(),
        b.$list.on('touchstart.slick mousedown.slick', { action: 'start' }, b.swipeHandler),
        b.$list.on('touchmove.slick mousemove.slick', { action: 'move' }, b.swipeHandler),
        b.$list.on('touchend.slick mouseup.slick', { action: 'end' }, b.swipeHandler),
        b.$list.on('touchcancel.slick mouseleave.slick', { action: 'end' }, b.swipeHandler),
        b.$list.on('click.slick', b.clickHandler),
        a(document).on(b.visibilityChange, a.proxy(b.visibility, b)),
        b.options.accessibility === !0 && b.$list.on('keydown.slick', b.keyHandler),
        b.options.focusOnSelect === !0 &&
          a(b.$slideTrack)
            .children()
            .on('click.slick', b.selectHandler),
        a(window).on('orientationchange.slick.slick-' + b.instanceUid, a.proxy(b.orientationChange, b)),
        a(window).on('resize.slick.slick-' + b.instanceUid, a.proxy(b.resize, b)),
        a('[draggable!=true]', b.$slideTrack).on('dragstart', b.preventDefault),
        a(window).on('load.slick.slick-' + b.instanceUid, b.setPosition),
        a(document).on('ready.slick.slick-' + b.instanceUid, b.setPosition);
    }),
    (b.prototype.initUI = function() {
      var a = this;
      a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.show(), a.$nextArrow.show()),
        a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.show();
    }),
    (b.prototype.keyHandler = function(a) {
      var b = this;
      a.target.tagName.match('TEXTAREA|INPUT|SELECT') ||
        (37 === a.keyCode && b.options.accessibility === !0
          ? b.changeSlide({ data: { message: b.options.rtl === !0 ? 'next' : 'previous' } })
          : 39 === a.keyCode &&
            b.options.accessibility === !0 &&
            b.changeSlide({ data: { message: b.options.rtl === !0 ? 'previous' : 'next' } }));
    }),
    (b.prototype.lazyLoad = function() {
      function g(c) {
        a('img[data-lazy]', c).each(function() {
          var c = a(this),
            d = a(this).attr('data-lazy'),
            e = document.createElement('img');
          (e.onload = function() {
            c.animate({ opacity: 0 }, 100, function() {
              c.attr('src', d).animate({ opacity: 1 }, 200, function() {
                c.removeAttr('data-lazy').removeClass('slick-loading');
              }),
                b.$slider.trigger('lazyLoaded', [b, c, d]);
            });
          }),
            (e.onerror = function() {
              c
                .removeAttr('data-lazy')
                .removeClass('slick-loading')
                .addClass('slick-lazyload-error'),
                b.$slider.trigger('lazyLoadError', [b, c, d]);
            }),
            (e.src = d);
        });
      }
      var c,
        d,
        e,
        f,
        b = this;
      b.options.centerMode === !0
        ? b.options.infinite === !0
          ? ((e = b.currentSlide + (b.options.slidesToShow / 2 + 1)), (f = e + b.options.slidesToShow + 2))
          : ((e = Math.max(0, b.currentSlide - (b.options.slidesToShow / 2 + 1))),
            (f = 2 + (b.options.slidesToShow / 2 + 1) + b.currentSlide))
        : ((e = b.options.infinite ? b.options.slidesToShow + b.currentSlide : b.currentSlide),
          (f = Math.ceil(e + b.options.slidesToShow)),
          b.options.fade === !0 && (e > 0 && e--, f <= b.slideCount && f++)),
        (c = b.$slider.find('.slick-slide').slice(e, f)),
        g(c),
        b.slideCount <= b.options.slidesToShow
          ? ((d = b.$slider.find('.slick-slide')), g(d))
          : b.currentSlide >= b.slideCount - b.options.slidesToShow
          ? ((d = b.$slider.find('.slick-cloned').slice(0, b.options.slidesToShow)), g(d))
          : 0 === b.currentSlide && ((d = b.$slider.find('.slick-cloned').slice(-1 * b.options.slidesToShow)), g(d));
    }),
    (b.prototype.loadSlider = function() {
      var a = this;
      a.setPosition(),
        a.$slideTrack.css({ opacity: 1 }),
        a.$slider.removeClass('slick-loading'),
        a.initUI(),
        'progressive' === a.options.lazyLoad && a.progressiveLazyLoad();
    }),
    (b.prototype.next = b.prototype.slickNext = function() {
      var a = this;
      a.changeSlide({ data: { message: 'next' } });
    }),
    (b.prototype.orientationChange = function() {
      var a = this;
      a.checkResponsive(), a.setPosition();
    }),
    (b.prototype.pause = b.prototype.slickPause = function() {
      var a = this;
      a.autoPlayClear(), (a.paused = !0);
    }),
    (b.prototype.play = b.prototype.slickPlay = function() {
      var a = this;
      a.autoPlay(), (a.options.autoplay = !0), (a.paused = !1), (a.focussed = !1), (a.interrupted = !1);
    }),
    (b.prototype.postSlide = function(a) {
      var b = this;
      b.unslicked ||
        (b.$slider.trigger('afterChange', [b, a]),
        (b.animating = !1),
        b.setPosition(),
        (b.swipeLeft = null),
        b.options.autoplay && b.autoPlay(),
        b.options.accessibility === !0 && b.initADA());
    }),
    (b.prototype.prev = b.prototype.slickPrev = function() {
      var a = this;
      a.changeSlide({ data: { message: 'previous' } });
    }),
    (b.prototype.preventDefault = function(a) {
      a.preventDefault();
    }),
    (b.prototype.progressiveLazyLoad = function(b) {
      b = b || 1;
      var e,
        f,
        g,
        c = this,
        d = a('img[data-lazy]', c.$slider);
      d.length
        ? ((e = d.first()),
          (f = e.attr('data-lazy')),
          (g = document.createElement('img')),
          (g.onload = function() {
            e
              .attr('src', f)
              .removeAttr('data-lazy')
              .removeClass('slick-loading'),
              c.options.adaptiveHeight === !0 && c.setPosition(),
              c.$slider.trigger('lazyLoaded', [c, e, f]),
              c.progressiveLazyLoad();
          }),
          (g.onerror = function() {
            3 > b
              ? setTimeout(function() {
                  c.progressiveLazyLoad(b + 1);
                }, 500)
              : (e
                  .removeAttr('data-lazy')
                  .removeClass('slick-loading')
                  .addClass('slick-lazyload-error'),
                c.$slider.trigger('lazyLoadError', [c, e, f]),
                c.progressiveLazyLoad());
          }),
          (g.src = f))
        : c.$slider.trigger('allImagesLoaded', [c]);
    }),
    (b.prototype.refresh = function(b) {
      var d,
        e,
        c = this;
      (e = c.slideCount - c.options.slidesToShow),
        !c.options.infinite && c.currentSlide > e && (c.currentSlide = e),
        c.slideCount <= c.options.slidesToShow && (c.currentSlide = 0),
        (d = c.currentSlide),
        c.destroy(!0),
        a.extend(c, c.initials, { currentSlide: d }),
        c.init(),
        b || c.changeSlide({ data: { message: 'index', index: d } }, !1);
    }),
    (b.prototype.registerBreakpoints = function() {
      var c,
        d,
        e,
        b = this,
        f = b.options.responsive || null;
      if ('array' === a.type(f) && f.length) {
        b.respondTo = b.options.respondTo || 'window';
        for (c in f)
          if (((e = b.breakpoints.length - 1), (d = f[c].breakpoint), f.hasOwnProperty(c))) {
            for (; e >= 0; ) b.breakpoints[e] && b.breakpoints[e] === d && b.breakpoints.splice(e, 1), e--;
            b.breakpoints.push(d), (b.breakpointSettings[d] = f[c].settings);
          }
        b.breakpoints.sort(function(a, c) {
          return b.options.mobileFirst ? a - c : c - a;
        });
      }
    }),
    (b.prototype.reinit = function() {
      var b = this;
      (b.$slides = b.$slideTrack.children(b.options.slide).addClass('slick-slide')),
        (b.slideCount = b.$slides.length),
        b.currentSlide >= b.slideCount &&
          0 !== b.currentSlide &&
          (b.currentSlide = b.currentSlide - b.options.slidesToScroll),
        b.slideCount <= b.options.slidesToShow && (b.currentSlide = 0),
        b.registerBreakpoints(),
        b.setProps(),
        b.setupInfinite(),
        b.buildArrows(),
        b.updateArrows(),
        b.initArrowEvents(),
        b.buildDots(),
        b.updateDots(),
        b.initDotEvents(),
        b.cleanUpSlideEvents(),
        b.initSlideEvents(),
        b.checkResponsive(!1, !0),
        b.options.focusOnSelect === !0 &&
          a(b.$slideTrack)
            .children()
            .on('click.slick', b.selectHandler),
        b.setSlideClasses('number' == typeof b.currentSlide ? b.currentSlide : 0),
        b.setPosition(),
        b.focusHandler(),
        (b.paused = !b.options.autoplay),
        b.autoPlay(),
        b.$slider.trigger('reInit', [b]);
    }),
    (b.prototype.resize = function() {
      var b = this;
      a(window).width() !== b.windowWidth &&
        (clearTimeout(b.windowDelay),
        (b.windowDelay = window.setTimeout(function() {
          (b.windowWidth = a(window).width()), b.checkResponsive(), b.unslicked || b.setPosition();
        }, 50)));
    }),
    (b.prototype.removeSlide = b.prototype.slickRemove = function(a, b, c) {
      var d = this;
      return (
        'boolean' == typeof a ? ((b = a), (a = b === !0 ? 0 : d.slideCount - 1)) : (a = b === !0 ? --a : a),
        d.slideCount < 1 || 0 > a || a > d.slideCount - 1
          ? !1
          : (d.unload(),
            c === !0
              ? d.$slideTrack.children().remove()
              : d.$slideTrack
                  .children(this.options.slide)
                  .eq(a)
                  .remove(),
            (d.$slides = d.$slideTrack.children(this.options.slide)),
            d.$slideTrack.children(this.options.slide).detach(),
            d.$slideTrack.append(d.$slides),
            (d.$slidesCache = d.$slides),
            void d.reinit())
      );
    }),
    (b.prototype.setCSS = function(a) {
      var d,
        e,
        b = this,
        c = {};
      b.options.rtl === !0 && (a = -a),
        (d = 'left' == b.positionProp ? Math.ceil(a) + 'px' : '0px'),
        (e = 'top' == b.positionProp ? Math.ceil(a) + 'px' : '0px'),
        (c[b.positionProp] = a),
        b.transformsEnabled === !1
          ? b.$slideTrack.css(c)
          : ((c = {}),
            b.cssTransitions === !1
              ? ((c[b.animType] = 'translate(' + d + ', ' + e + ')'), b.$slideTrack.css(c))
              : ((c[b.animType] = 'translate3d(' + d + ', ' + e + ', 0px)'), b.$slideTrack.css(c)));
    }),
    (b.prototype.setDimensions = function() {
      var a = this;
      a.options.vertical === !1
        ? a.options.centerMode === !0 && a.$list.css({ padding: '0px ' + a.options.centerPadding })
        : (a.$list.height(a.$slides.first().outerHeight(!0) * a.options.slidesToShow),
          a.options.centerMode === !0 && a.$list.css({ padding: a.options.centerPadding + ' 0px' })),
        (a.listWidth = a.$list.width()),
        (a.listHeight = a.$list.height()),
        a.options.vertical === !1 && a.options.variableWidth === !1
          ? ((a.slideWidth = Math.ceil(a.listWidth / a.options.slidesToShow)),
            a.$slideTrack.width(Math.ceil(a.slideWidth * a.$slideTrack.children('.slick-slide').length)))
          : a.options.variableWidth === !0
          ? a.$slideTrack.width(5e3 * a.slideCount)
          : ((a.slideWidth = Math.ceil(a.listWidth)),
            a.$slideTrack.height(
              Math.ceil(a.$slides.first().outerHeight(!0) * a.$slideTrack.children('.slick-slide').length)
            ));
      var b = a.$slides.first().outerWidth(!0) - a.$slides.first().width();
      a.options.variableWidth === !1 && a.$slideTrack.children('.slick-slide').width(a.slideWidth - b);
    }),
    (b.prototype.setFade = function() {
      var c,
        b = this;
      b.$slides.each(function(d, e) {
        (c = b.slideWidth * d * -1),
          b.options.rtl === !0
            ? a(e).css({ position: 'relative', right: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 })
            : a(e).css({ position: 'relative', left: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 });
      }),
        b.$slides.eq(b.currentSlide).css({ zIndex: b.options.zIndex - 1, opacity: 1 });
    }),
    (b.prototype.setHeight = function() {
      var a = this;
      if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
        var b = a.$slides.eq(a.currentSlide).outerHeight(!0);
        a.$list.css('height', b);
      }
    }),
    (b.prototype.setOption = b.prototype.slickSetOption = function() {
      var c,
        d,
        e,
        f,
        h,
        b = this,
        g = !1;
      if (
        ('object' === a.type(arguments[0])
          ? ((e = arguments[0]), (g = arguments[1]), (h = 'multiple'))
          : 'string' === a.type(arguments[0]) &&
            ((e = arguments[0]),
            (f = arguments[1]),
            (g = arguments[2]),
            'responsive' === arguments[0] && 'array' === a.type(arguments[1])
              ? (h = 'responsive')
              : 'undefined' != typeof arguments[1] && (h = 'single')),
        'single' === h)
      )
        b.options[e] = f;
      else if ('multiple' === h)
        a.each(e, function(a, c) {
          b.options[a] = c;
        });
      else if ('responsive' === h)
        for (d in f)
          if ('array' !== a.type(b.options.responsive)) b.options.responsive = [f[d]];
          else {
            for (c = b.options.responsive.length - 1; c >= 0; )
              b.options.responsive[c].breakpoint === f[d].breakpoint && b.options.responsive.splice(c, 1), c--;
            b.options.responsive.push(f[d]);
          }
      g && (b.unload(), b.reinit());
    }),
    (b.prototype.setPosition = function() {
      var a = this;
      a.setDimensions(),
        a.setHeight(),
        a.options.fade === !1 ? a.setCSS(a.getLeft(a.currentSlide)) : a.setFade(),
        a.$slider.trigger('setPosition', [a]);
    }),
    (b.prototype.setProps = function() {
      var a = this,
        b = document.body.style;
      (a.positionProp = a.options.vertical === !0 ? 'top' : 'left'),
        'top' === a.positionProp ? a.$slider.addClass('slick-vertical') : a.$slider.removeClass('slick-vertical'),
        (void 0 !== b.WebkitTransition || void 0 !== b.MozTransition || void 0 !== b.msTransition) &&
          a.options.useCSS === !0 &&
          (a.cssTransitions = !0),
        a.options.fade &&
          ('number' == typeof a.options.zIndex
            ? a.options.zIndex < 3 && (a.options.zIndex = 3)
            : (a.options.zIndex = a.defaults.zIndex)),
        void 0 !== b.OTransform &&
          ((a.animType = 'OTransform'),
          (a.transformType = '-o-transform'),
          (a.transitionType = 'OTransition'),
          void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)),
        void 0 !== b.MozTransform &&
          ((a.animType = 'MozTransform'),
          (a.transformType = '-moz-transform'),
          (a.transitionType = 'MozTransition'),
          void 0 === b.perspectiveProperty && void 0 === b.MozPerspective && (a.animType = !1)),
        void 0 !== b.webkitTransform &&
          ((a.animType = 'webkitTransform'),
          (a.transformType = '-webkit-transform'),
          (a.transitionType = 'webkitTransition'),
          void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)),
        void 0 !== b.msTransform &&
          ((a.animType = 'msTransform'),
          (a.transformType = '-ms-transform'),
          (a.transitionType = 'msTransition'),
          void 0 === b.msTransform && (a.animType = !1)),
        void 0 !== b.transform &&
          a.animType !== !1 &&
          ((a.animType = 'transform'), (a.transformType = 'transform'), (a.transitionType = 'transition')),
        (a.transformsEnabled = a.options.useTransform && null !== a.animType && a.animType !== !1);
    }),
    (b.prototype.setSlideClasses = function(a) {
      var c,
        d,
        e,
        f,
        b = this;
      (d = b.$slider
        .find('.slick-slide')
        .removeClass('slick-active slick-center slick-current')
        .attr('aria-hidden', 'true')),
        b.$slides.eq(a).addClass('slick-current'),
        b.options.centerMode === !0
          ? ((c = Math.floor(b.options.slidesToShow / 2)),
            b.options.infinite === !0 &&
              (a >= c && a <= b.slideCount - 1 - c
                ? b.$slides
                    .slice(a - c, a + c + 1)
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false')
                : ((e = b.options.slidesToShow + a),
                  d
                    .slice(e - c + 1, e + c + 2)
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false')),
              0 === a
                ? d.eq(d.length - 1 - b.options.slidesToShow).addClass('slick-center')
                : a === b.slideCount - 1 && d.eq(b.options.slidesToShow).addClass('slick-center')),
            b.$slides.eq(a).addClass('slick-center'))
          : a >= 0 && a <= b.slideCount - b.options.slidesToShow
          ? b.$slides
              .slice(a, a + b.options.slidesToShow)
              .addClass('slick-active')
              .attr('aria-hidden', 'false')
          : d.length <= b.options.slidesToShow
          ? d.addClass('slick-active').attr('aria-hidden', 'false')
          : ((f = b.slideCount % b.options.slidesToShow),
            (e = b.options.infinite === !0 ? b.options.slidesToShow + a : a),
            b.options.slidesToShow == b.options.slidesToScroll && b.slideCount - a < b.options.slidesToShow
              ? d
                  .slice(e - (b.options.slidesToShow - f), e + f)
                  .addClass('slick-active')
                  .attr('aria-hidden', 'false')
              : d
                  .slice(e, e + b.options.slidesToShow)
                  .addClass('slick-active')
                  .attr('aria-hidden', 'false')),
        'ondemand' === b.options.lazyLoad && b.lazyLoad();
    }),
    (b.prototype.setupInfinite = function() {
      var c,
        d,
        e,
        b = this;
      if (
        (b.options.fade === !0 && (b.options.centerMode = !1),
        b.options.infinite === !0 && b.options.fade === !1 && ((d = null), b.slideCount > b.options.slidesToShow))
      ) {
        for (
          e = b.options.centerMode === !0 ? b.options.slidesToShow + 1 : b.options.slidesToShow, c = b.slideCount;
          c > b.slideCount - e;
          c -= 1
        )
          (d = c - 1),
            a(b.$slides[d])
              .clone(!0)
              .attr('id', '')
              .attr('data-slick-index', d - b.slideCount)
              .prependTo(b.$slideTrack)
              .addClass('slick-cloned');
        for (c = 0; e > c; c += 1)
          (d = c),
            a(b.$slides[d])
              .clone(!0)
              .attr('id', '')
              .attr('data-slick-index', d + b.slideCount)
              .appendTo(b.$slideTrack)
              .addClass('slick-cloned');
        b.$slideTrack
          .find('.slick-cloned')
          .find('[id]')
          .each(function() {
            a(this).attr('id', '');
          });
      }
    }),
    (b.prototype.interrupt = function(a) {
      var b = this;
      a || b.autoPlay(), (b.interrupted = a);
    }),
    (b.prototype.selectHandler = function(b) {
      var c = this,
        d = a(b.target).is('.slick-slide') ? a(b.target) : a(b.target).parents('.slick-slide'),
        e = parseInt(d.attr('data-slick-index'));
      return (
        e || (e = 0),
        c.slideCount <= c.options.slidesToShow ? (c.setSlideClasses(e), void c.asNavFor(e)) : void c.slideHandler(e)
      );
    }),
    (b.prototype.slideHandler = function(a, b, c) {
      var d,
        e,
        f,
        g,
        j,
        h = null,
        i = this;
      return (
        (b = b || !1),
        (i.animating === !0 && i.options.waitForAnimate === !0) ||
        (i.options.fade === !0 && i.currentSlide === a) ||
        i.slideCount <= i.options.slidesToShow
          ? void 0
          : (b === !1 && i.asNavFor(a),
            (d = a),
            (h = i.getLeft(d)),
            (g = i.getLeft(i.currentSlide)),
            (i.currentLeft = null === i.swipeLeft ? g : i.swipeLeft),
            i.options.infinite === !1 &&
            i.options.centerMode === !1 &&
            (0 > a || a > i.getDotCount() * i.options.slidesToScroll)
              ? void (
                  i.options.fade === !1 &&
                  ((d = i.currentSlide),
                  c !== !0
                    ? i.animateSlide(g, function() {
                        i.postSlide(d);
                      })
                    : i.postSlide(d))
                )
              : i.options.infinite === !1 &&
                i.options.centerMode === !0 &&
                (0 > a || a > i.slideCount - i.options.slidesToScroll)
              ? void (
                  i.options.fade === !1 &&
                  ((d = i.currentSlide),
                  c !== !0
                    ? i.animateSlide(g, function() {
                        i.postSlide(d);
                      })
                    : i.postSlide(d))
                )
              : (i.options.autoplay && clearInterval(i.autoPlayTimer),
                (e =
                  0 > d
                    ? i.slideCount % i.options.slidesToScroll !== 0
                      ? i.slideCount - (i.slideCount % i.options.slidesToScroll)
                      : i.slideCount + d
                    : d >= i.slideCount
                    ? i.slideCount % i.options.slidesToScroll !== 0
                      ? 0
                      : d - i.slideCount
                    : d),
                (i.animating = !0),
                i.$slider.trigger('beforeChange', [i, i.currentSlide, e]),
                (f = i.currentSlide),
                (i.currentSlide = e),
                i.setSlideClasses(i.currentSlide),
                i.options.asNavFor &&
                  ((j = i.getNavTarget()),
                  (j = j.slick('getSlick')),
                  j.slideCount <= j.options.slidesToShow && j.setSlideClasses(i.currentSlide)),
                i.updateDots(),
                i.updateArrows(),
                i.options.fade === !0
                  ? (c !== !0
                      ? (i.fadeSlideOut(f),
                        i.fadeSlide(e, function() {
                          i.postSlide(e);
                        }))
                      : i.postSlide(e),
                    void i.animateHeight())
                  : void (c !== !0
                      ? i.animateSlide(h, function() {
                          i.postSlide(e);
                        })
                      : i.postSlide(e))))
      );
    }),
    (b.prototype.startLoad = function() {
      var a = this;
      a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.hide(), a.$nextArrow.hide()),
        a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.hide(),
        a.$slider.addClass('slick-loading');
    }),
    (b.prototype.swipeDirection = function() {
      var a,
        b,
        c,
        d,
        e = this;
      return (
        (a = e.touchObject.startX - e.touchObject.curX),
        (b = e.touchObject.startY - e.touchObject.curY),
        (c = Math.atan2(b, a)),
        (d = Math.round((180 * c) / Math.PI)),
        0 > d && (d = 360 - Math.abs(d)),
        45 >= d && d >= 0
          ? e.options.rtl === !1
            ? 'left'
            : 'right'
          : 360 >= d && d >= 315
          ? e.options.rtl === !1
            ? 'left'
            : 'right'
          : d >= 135 && 225 >= d
          ? e.options.rtl === !1
            ? 'right'
            : 'left'
          : e.options.verticalSwiping === !0
          ? d >= 35 && 135 >= d
            ? 'down'
            : 'up'
          : 'vertical'
      );
    }),
    (b.prototype.swipeEnd = function(a) {
      var c,
        d,
        b = this;
      if (
        ((b.dragging = !1),
        (b.interrupted = !1),
        (b.shouldClick = b.touchObject.swipeLength > 10 ? !1 : !0),
        void 0 === b.touchObject.curX)
      )
        return !1;
      if (
        (b.touchObject.edgeHit === !0 && b.$slider.trigger('edge', [b, b.swipeDirection()]),
        b.touchObject.swipeLength >= b.touchObject.minSwipe)
      ) {
        switch ((d = b.swipeDirection())) {
          case 'left':
          case 'down':
            (c = b.options.swipeToSlide
              ? b.checkNavigable(b.currentSlide + b.getSlideCount())
              : b.currentSlide + b.getSlideCount()),
              (b.currentDirection = 0);
            break;
          case 'right':
          case 'up':
            (c = b.options.swipeToSlide
              ? b.checkNavigable(b.currentSlide - b.getSlideCount())
              : b.currentSlide - b.getSlideCount()),
              (b.currentDirection = 1);
        }
        'vertical' != d && (b.slideHandler(c), (b.touchObject = {}), b.$slider.trigger('swipe', [b, d]));
      } else b.touchObject.startX !== b.touchObject.curX && (b.slideHandler(b.currentSlide), (b.touchObject = {}));
    }),
    (b.prototype.swipeHandler = function(a) {
      var b = this;
      if (
        !(
          b.options.swipe === !1 ||
          ('ontouchend' in document && b.options.swipe === !1) ||
          (b.options.draggable === !1 && -1 !== a.type.indexOf('mouse'))
        )
      )
        switch (
          ((b.touchObject.fingerCount =
            a.originalEvent && void 0 !== a.originalEvent.touches ? a.originalEvent.touches.length : 1),
          (b.touchObject.minSwipe = b.listWidth / b.options.touchThreshold),
          b.options.verticalSwiping === !0 && (b.touchObject.minSwipe = b.listHeight / b.options.touchThreshold),
          a.data.action)
        ) {
          case 'start':
            b.swipeStart(a);
            break;
          case 'move':
            b.swipeMove(a);
            break;
          case 'end':
            b.swipeEnd(a);
        }
    }),
    (b.prototype.swipeMove = function(a) {
      var d,
        e,
        f,
        g,
        h,
        b = this;
      return (
        (h = void 0 !== a.originalEvent ? a.originalEvent.touches : null),
        !b.dragging || (h && 1 !== h.length)
          ? !1
          : ((d = b.getLeft(b.currentSlide)),
            (b.touchObject.curX = void 0 !== h ? h[0].pageX : a.clientX),
            (b.touchObject.curY = void 0 !== h ? h[0].pageY : a.clientY),
            (b.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(b.touchObject.curX - b.touchObject.startX, 2)))),
            b.options.verticalSwiping === !0 &&
              (b.touchObject.swipeLength = Math.round(
                Math.sqrt(Math.pow(b.touchObject.curY - b.touchObject.startY, 2))
              )),
            (e = b.swipeDirection()),
            'vertical' !== e
              ? (void 0 !== a.originalEvent && b.touchObject.swipeLength > 4 && a.preventDefault(),
                (g = (b.options.rtl === !1 ? 1 : -1) * (b.touchObject.curX > b.touchObject.startX ? 1 : -1)),
                b.options.verticalSwiping === !0 && (g = b.touchObject.curY > b.touchObject.startY ? 1 : -1),
                (f = b.touchObject.swipeLength),
                (b.touchObject.edgeHit = !1),
                b.options.infinite === !1 &&
                  ((0 === b.currentSlide && 'right' === e) || (b.currentSlide >= b.getDotCount() && 'left' === e)) &&
                  ((f = b.touchObject.swipeLength * b.options.edgeFriction), (b.touchObject.edgeHit = !0)),
                b.options.vertical === !1
                  ? (b.swipeLeft = d + f * g)
                  : (b.swipeLeft = d + f * (b.$list.height() / b.listWidth) * g),
                b.options.verticalSwiping === !0 && (b.swipeLeft = d + f * g),
                b.options.fade === !0 || b.options.touchMove === !1
                  ? !1
                  : b.animating === !0
                  ? ((b.swipeLeft = null), !1)
                  : void b.setCSS(b.swipeLeft))
              : void 0)
      );
    }),
    (b.prototype.swipeStart = function(a) {
      var c,
        b = this;
      return (
        (b.interrupted = !0),
        1 !== b.touchObject.fingerCount || b.slideCount <= b.options.slidesToShow
          ? ((b.touchObject = {}), !1)
          : (void 0 !== a.originalEvent && void 0 !== a.originalEvent.touches && (c = a.originalEvent.touches[0]),
            (b.touchObject.startX = b.touchObject.curX = void 0 !== c ? c.pageX : a.clientX),
            (b.touchObject.startY = b.touchObject.curY = void 0 !== c ? c.pageY : a.clientY),
            void (b.dragging = !0))
      );
    }),
    (b.prototype.unfilterSlides = b.prototype.slickUnfilter = function() {
      var a = this;
      null !== a.$slidesCache &&
        (a.unload(),
        a.$slideTrack.children(this.options.slide).detach(),
        a.$slidesCache.appendTo(a.$slideTrack),
        a.reinit());
    }),
    (b.prototype.unload = function() {
      var b = this;
      a('.slick-cloned', b.$slider).remove(),
        b.$dots && b.$dots.remove(),
        b.$prevArrow && b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.remove(),
        b.$nextArrow && b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.remove(),
        b.$slides
          .removeClass('slick-slide slick-active slick-visible slick-current')
          .attr('aria-hidden', 'true')
          .css('width', '');
    }),
    (b.prototype.unslick = function(a) {
      var b = this;
      b.$slider.trigger('unslick', [b, a]), b.destroy();
    }),
    (b.prototype.updateArrows = function() {
      var b,
        a = this;
      (b = Math.floor(a.options.slidesToShow / 2)),
        a.options.arrows === !0 &&
          a.slideCount > a.options.slidesToShow &&
          !a.options.infinite &&
          (a.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false'),
          a.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false'),
          0 === a.currentSlide
            ? (a.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true'),
              a.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false'))
            : a.currentSlide >= a.slideCount - a.options.slidesToShow && a.options.centerMode === !1
            ? (a.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true'),
              a.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false'))
            : a.currentSlide >= a.slideCount - 1 &&
              a.options.centerMode === !0 &&
              (a.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true'),
              a.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false')));
    }),
    (b.prototype.updateDots = function() {
      var a = this;
      null !== a.$dots &&
        (a.$dots
          .find('li')
          .removeClass('slick-active')
          .attr('aria-hidden', 'true'),
        a.$dots
          .find('li')
          .eq(Math.floor(a.currentSlide / a.options.slidesToScroll))
          .addClass('slick-active')
          .attr('aria-hidden', 'false'));
    }),
    (b.prototype.visibility = function() {
      var a = this;
      a.options.autoplay && (document[a.hidden] ? (a.interrupted = !0) : (a.interrupted = !1));
    }),
    (a.fn.slick = function() {
      var f,
        g,
        a = this,
        c = arguments[0],
        d = Array.prototype.slice.call(arguments, 1),
        e = a.length;
      for (f = 0; e > f; f++)
        if (
          ('object' == typeof c || 'undefined' == typeof c
            ? (a[f].slick = new b(a[f], c))
            : (g = a[f].slick[c].apply(a[f].slick, d)),
          'undefined' != typeof g)
        )
          return g;
      return a;
    });
});

/*!
  hey, [be]Lazy.js - v1.8.2 - 2016.10.25
  A fast, small and dependency free lazy load script (https://github.com/dinbror/blazy)
  (c) Bjoern Klinggaard - @bklinggaard - http://dinbror.dk/blazy
*/
(function(q, m) {
  'function' === typeof define && define.amd
    ? define(m)
    : 'object' === typeof exports
    ? (module.exports = m())
    : (q.Blazy = m());
})(this, function() {
  function q(b) {
    var c = b._util;
    c.elements = E(b.options);
    c.count = c.elements.length;
    c.destroyed &&
      ((c.destroyed = !1),
      b.options.container &&
        l(b.options.container, function(a) {
          n(a, 'scroll', c.validateT);
        }),
      n(window, 'resize', c.saveViewportOffsetT),
      n(window, 'resize', c.validateT),
      n(window, 'scroll', c.validateT));
    m(b);
  }
  function m(b) {
    for (var c = b._util, a = 0; a < c.count; a++) {
      var d = c.elements[a],
        e;
      a: {
        var g = d;
        e = b.options;
        var p = g.getBoundingClientRect();
        if (e.container && y && (g = g.closest(e.containerClass))) {
          g = g.getBoundingClientRect();
          e = r(g, f)
            ? r(p, {
                top: g.top - e.offset,
                right: g.right + e.offset,
                bottom: g.bottom + e.offset,
                left: g.left - e.offset,
              })
            : !1;
          break a;
        }
        e = r(p, f);
      }
      if (e || t(d, b.options.successClass)) b.load(d), c.elements.splice(a, 1), c.count--, a--;
    }
    0 === c.count && b.destroy();
  }
  function r(b, c) {
    return b.right >= c.left && b.bottom >= c.top && b.left <= c.right && b.top <= c.bottom;
  }
  function z(b, c, a) {
    if (!t(b, a.successClass) && (c || a.loadInvisible || (0 < b.offsetWidth && 0 < b.offsetHeight)))
      if ((c = b.getAttribute(u) || b.getAttribute(a.src))) {
        c = c.split(a.separator);
        var d = c[A && 1 < c.length ? 1 : 0],
          e = b.getAttribute(a.srcset),
          g = 'img' === b.nodeName.toLowerCase(),
          p = (c = b.parentNode) && 'picture' === c.nodeName.toLowerCase();
        if (g || void 0 === b.src) {
          var h = new Image(),
            w = function() {
              a.error && a.error(b, 'invalid');
              v(b, a.errorClass);
              k(h, 'error', w);
              k(h, 'load', f);
            },
            f = function() {
              g ? p || B(b, d, e) : (b.style.backgroundImage = 'url("' + d + '")');
              x(b, a);
              k(h, 'load', f);
              k(h, 'error', w);
            };
          p &&
            ((h = b),
            l(c.getElementsByTagName('source'), function(b) {
              var c = a.srcset,
                e = b.getAttribute(c);
              e && (b.setAttribute('srcset', e), b.removeAttribute(c));
            }));
          n(h, 'error', w);
          n(h, 'load', f);
          B(h, d, e);
        } else (b.src = d), x(b, a);
      } else
        'video' === b.nodeName.toLowerCase()
          ? (l(b.getElementsByTagName('source'), function(b) {
              var c = a.src,
                e = b.getAttribute(c);
              e && (b.setAttribute('src', e), b.removeAttribute(c));
            }),
            b.load(),
            x(b, a))
          : (a.error && a.error(b, 'missing'), v(b, a.errorClass));
  }
  function x(b, c) {
    v(b, c.successClass);
    c.success && c.success(b);
    b.removeAttribute(c.src);
    b.removeAttribute(c.srcset);
    l(c.breakpoints, function(a) {
      b.removeAttribute(a.src);
    });
  }
  function B(b, c, a) {
    a && b.setAttribute('srcset', a);
    b.src = c;
  }
  function t(b, c) {
    return -1 !== (' ' + b.className + ' ').indexOf(' ' + c + ' ');
  }
  function v(b, c) {
    t(b, c) || (b.className += ' ' + c);
  }
  function E(b) {
    var c = [];
    b = b.root.querySelectorAll(b.selector);
    for (var a = b.length; a--; c.unshift(b[a]));
    return c;
  }
  function C(b) {
    f.bottom = (window.innerHeight || document.documentElement.clientHeight) + b;
    f.right = (window.innerWidth || document.documentElement.clientWidth) + b;
  }
  function n(b, c, a) {
    b.attachEvent
      ? b.attachEvent && b.attachEvent('on' + c, a)
      : b.addEventListener(c, a, { capture: !1, passive: !0 });
  }
  function k(b, c, a) {
    b.detachEvent
      ? b.detachEvent && b.detachEvent('on' + c, a)
      : b.removeEventListener(c, a, { capture: !1, passive: !0 });
  }
  function l(b, c) {
    if (b && c) for (var a = b.length, d = 0; d < a && !1 !== c(b[d], d); d++);
  }
  function D(b, c, a) {
    var d = 0;
    return function() {
      var e = +new Date();
      e - d < c || ((d = e), b.apply(a, arguments));
    };
  }
  var u, f, A, y;
  return function(b) {
    if (!document.querySelectorAll) {
      var c = document.createStyleSheet();
      document.querySelectorAll = function(a, b, d, h, f) {
        f = document.all;
        b = [];
        a = a.replace(/\[for\b/gi, '[htmlFor').split(',');
        for (d = a.length; d--; ) {
          c.addRule(a[d], 'k:v');
          for (h = f.length; h--; ) f[h].currentStyle.k && b.push(f[h]);
          c.removeRule(0);
        }
        return b;
      };
    }
    var a = this,
      d = (a._util = {});
    d.elements = [];
    d.destroyed = !0;
    a.options = b || {};
    a.options.error = a.options.error || !1;
    a.options.offset = a.options.offset || 100;
    a.options.root = a.options.root || document;
    a.options.success = a.options.success || !1;
    a.options.selector = a.options.selector || '.b-lazy';
    a.options.separator = a.options.separator || '|';
    a.options.containerClass = a.options.container;
    a.options.container = a.options.containerClass ? document.querySelectorAll(a.options.containerClass) : !1;
    a.options.errorClass = a.options.errorClass || 'b-error';
    a.options.breakpoints = a.options.breakpoints || !1;
    a.options.loadInvisible = a.options.loadInvisible || !1;
    a.options.successClass = a.options.successClass || 'b-loaded';
    a.options.validateDelay = a.options.validateDelay || 25;
    a.options.saveViewportOffsetDelay = a.options.saveViewportOffsetDelay || 50;
    a.options.srcset = a.options.srcset || 'data-srcset';
    a.options.src = u = a.options.src || 'data-src';
    y = Element.prototype.closest;
    A = 1 < window.devicePixelRatio;
    f = {};
    f.top = 0 - a.options.offset;
    f.left = 0 - a.options.offset;
    a.revalidate = function() {
      q(a);
    };
    a.load = function(a, b) {
      var c = this.options;
      void 0 === a.length
        ? z(a, b, c)
        : l(a, function(a) {
            z(a, b, c);
          });
    };
    a.destroy = function() {
      var a = this._util;
      this.options.container &&
        l(this.options.container, function(b) {
          k(b, 'scroll', a.validateT);
        });
      k(window, 'scroll', a.validateT);
      k(window, 'resize', a.validateT);
      k(window, 'resize', a.saveViewportOffsetT);
      a.count = 0;
      a.elements.length = 0;
      a.destroyed = !0;
    };
    d.validateT = D(
      function() {
        m(a);
      },
      a.options.validateDelay,
      a
    );
    d.saveViewportOffsetT = D(
      function() {
        C(a.options.offset);
      },
      a.options.saveViewportOffsetDelay,
      a
    );
    C(a.options.offset);
    l(a.options.breakpoints, function(a) {
      if (a.width >= window.screen.width) return (u = a.src), !1;
    });
    setTimeout(function() {
      q(a);
    });
  };
});
